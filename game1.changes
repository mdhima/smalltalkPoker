----QUIT----2020-01-22T20:54:30.239682+01:00 Pharo8.0-SNAPSHOT-32bit-0932da8.image priorSource: 0!----QUIT----2020-01-22T20:54:52.539489+01:00 Pharo8.0-SNAPSHOT-32bit-0932da8.image priorSource: 0!Object subclass: #Poker	instanceVariableNames: ''	classVariableNames: ''	package: 'CPS506'!!Poker methodsFor: 'as yet unclassified' stamp: 'MagdalenaDhima 1/24/2021 15:55'!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| temp values suits output val newShuf |	newShuf := Array new.	values := #('ace' '2' '3' '4' '5' '6' '7' '8' '9' '10' 'Jack' 'Queen' 'King').	suits := #('Clubs' 'Diamonds' 'Hearts' 'Spades').	9 timesRepeat: [ :i | 		val := shuf at: i.		temp := val % 13.		(temp == 0) 			ifFalse: [output := ( values at: temp )]			ifTrue: [output := ( values at: 0 )] 		.		temp := (val-1 / 13 floor) + 1.		output at: (output size+1) put: (suits at: temp). 		newShuf at: i put: output.	].	^ newShuf.! !!Poker methodsFor: 'as yet unclassified' stamp: 'MagdalenaDhima 1/24/2021 16:01' prior: 33554811!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| temp values suits output val newShuf |	newShuf := Array new.	values := #('ace' '2' '3' '4' '5' '6' '7' '8' '9' '10' 'Jack' 'Queen' 'King').	suits := #('Clubs' 'Diamonds' 'Hearts' 'Spades').	9 timesRepeat: [ :i | 		val := shuf at: i.		temp := val % 13.		(temp == 0) 			ifFalse: [output := ( values at: temp )]			ifTrue: [output := ( values at: 0 )]		. 		temp := val-1 / 13 floor. 		val at: (output size +1) put: (suits at: temp). 		newShuf at: i put: output.	].	^ newShuf.! !Poker removeSelector: #deal:!!Poker methodsFor: 'as yet unclassified' stamp: 'MagdalenaDhima 1/24/2021 16:03'!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| temp values suits output val newShuf |	newShuf := Array new.	values := #('ace' '2' '3' '4' '5' '6' '7' '8' '9' '10' 'Jack' 'Queen' 'King').	suits := #('Clubs' 'Diamonds' 'Hearts' 'Spades').	9 timesRepeat: [ :i | 		val := shuf at: i.		temp := val % 13.		(temp == 0) 			ifFalse: [output := ( values at: temp )]			ifTrue: [output := ( values at: 0 )]		. 		temp := val-1 / 13 floor. 		val at: (output size +1) put: (suits at: temp). 		newShuf at: i put: output.	].	^ newShuf! !Object subclass: #Poker	instanceVariableNames: 'deal'	classVariableNames: ''	package: 'CPS506'!!Poker methodsFor: 'as yet unclassified' stamp: 'MagdalenaDhima 1/24/2021 16:14'!messageSelectorAndArgumentNames	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"				! !Poker removeSelector: #messageSelectorAndArgumentNames!!Poker methodsFor: 'as yet unclassified' stamp: 'MagdalenaDhima 1/24/2021 16:17' prior: 33556249!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| temp values suits output val newShuf |	newShuf := Array new.	values := #('ace' '2' '3' '4' '5' '6' '7' '8' '9' '10' 'Jack' 'Queen' 'King').	suits := #('Clubs' 'Diamonds' 'Hearts' 'Spades').	9 timesRepeat: [ :i | 		val := shuf at: i.		temp := val % 13.		(temp == 0) 			ifFalse: [output := ( values at: temp )]			ifTrue: [output := ( values at: 0 )]		. 		temp := val-1 / 13 floor. 		val at: (output size +1) put: (suits at: temp). 		newShuf at: i put: output.	].	^ newShuf! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/24/2021 16:24' prior: 33557337!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| temp values suits output val newShuf |	newShuf := Array new.	values := #('ace' '2' '3' '4' '5' '6' '7' '8' '9' '10' 'Jack' 'Queen' 'King').	suits := #('Clubs' 'Diamonds' 'Hearts' 'Spades').	9 timesRepeat: [ :i | 		val := shuf at: i.		temp := val % 13.		output := (temp == 0) 			ifFalse: [values at: temp]			ifTrue: [values at: 0]		. 		temp := val-1 / 13 floor. 		val at: (output size +1) put: (suits at: temp). 		newShuf at: i put: output.	].	^ newShuf! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/24/2021 16:26' prior: 33558034!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| temp values suits output val newShuf |	newShuf := Array new.	values := #('ace' '2' '3' '4' '5' '6' '7' '8' '9' '10' 'Jack' 'Queen' 'King').	suits := #('Clubs' 'Diamonds' 'Hearts' 'Spades').	9 timesRepeat: [ :i | 		val := shuf at: i.		Transcript show: val; cr.		temp := val % 13.		Transcript show: temp; cr.		output := (temp == 0) 			ifFalse: [values at: temp]			ifTrue: [values at: 0]		. 		Transcript show: output; cr.		temp := val-1 / 13 floor. 		Transcript show: temp; cr.		val at: (output size +1) put: (suits at: temp). 		Transcript show: val; cr.		newShuf at: i put: output.		Transcript show: newShuf; cr.	].	^ newShuf! !----SNAPSHOT----2021-01-24T22:07:59.468761-05:00 Pharo 8.0 - 64bit (stable).image priorSource: 100!Object subclass: #Lab01	instanceVariableNames: ''	classVariableNames: ''	package: 'CPS506'!Object subclass: #Lab01	instanceVariableNames: 'arr'	classVariableNames: ''	package: 'CPS506'!!Lab01 methodsFor: 'as yet unclassified' stamp: 'MagdalenaDhima 1/26/2021 12:32'!bufferInit: inp_array	arr := inp_array.! !!EyeInspector methodsFor: 'event-handling' stamp: 'AutoDeprecationRefactoring 1/26/2021 15:00' prior: 24456561!updateList	"update the list of elements displayed according to the new object"	| elements |	"	self haltOnce."	elements := self generateElements.	self list items = elements		ifTrue: [ ^ self ].	"first reset the items to make sure we don't interfere with the display block"	"self list items: #()."	self list display: [ :eyeElement | self labelFor: eyeElement ].	self list items: elements.	"handle when last item of list is removed"	self list selection selectedIndex > self list items size		ifTrue: [ self list setSelectedIndex: self list listItems size ].	"handle when selected dictionary key is removed"	self list selectIndex: self list selection selectedIndex.	self list menu: [ :aMenu | self inspectionMenu: aMenu ]! !ProfStef class removeSelector: #goToNextLesson!!Lab01 methodsFor: 'as yet unclassified' stamp: 'MagdalenaDhima 1/26/2021 19:14' prior: 33559859!bufferInit: inp_array	arr := inp_array.! !Object subclass: #Poker	instanceVariableNames: ''	classVariableNames: ''	package: 'CPS506'!!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/28/2021 20:58' prior: 33558713!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"				| deckOfNumerals card deck winner val values suits temp |deck := Array new: 9."get random deck"1 to: 9 do: [ :i | deckOfNumerals at: i put: (1 to: 52) atRandom].values := #('1' '2' '3' '4' '5' '6' '7' '8' '9' '10' '11' '12' '13').suits := #('C' 'D' 'H' 'S')."convert deck"1 to: 9 do: [ :i | 	val := deckOfNumerals at: i.	temp := val % 13.	card := (temp == 0) 		ifFalse: [values at: temp]		ifTrue: [values at: 13]	. 	temp := val-1 // 13 + 1 floor. 	card := card , (suits at: temp). 	deck at: i put: card.].	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/28/2021 20:58' prior: 33561129!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"				| deckOfNumerals card deck winner val values suits temp |deckOfNumerals := Array new: 9.deck := Array new: 9."get random deck"1 to: 9 do: [ :i | deckOfNumerals at: i put: (1 to: 52) atRandom].values := #('1' '2' '3' '4' '5' '6' '7' '8' '9' '10' '11' '12' '13').suits := #('C' 'D' 'H' 'S')."convert deck"1 to: 9 do: [ :i | 	val := deckOfNumerals at: i.	temp := val % 13.	card := (temp == 0) 		ifFalse: [values at: temp]		ifTrue: [values at: 13]	. 	temp := val-1 // 13 + 1 floor. 	card := card , (suits at: temp). 	deck at: i put: card.].	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/28/2021 21:24' prior: 33561874!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"				| deckOfNumerals card deck winner val values suits temp twoDigits threeDigitsclubs diamonds hearts spades hand |deckOfNumerals := Array new: 9.deck := Array new: 9."get random deck"1 to: 9 do: [ :i | deckOfNumerals at: i put: (1 to: 52) atRandom].values := #('1' '2' '3' '4' '5' '6' '7' '8' '9' '10' '11' '12' '13').suits := #('C' 'D' 'H' 'S')."convert deck"1 to: 9 do: [ :i | 	val := deckOfNumerals at: i.	temp := val % 13.	card := (temp == 0) 		ifFalse: [values at: temp]		ifTrue: [values at: 13]	. 	temp := val-1 // 13 + 1 floor. 	card := card , (suits at: temp). 	deck at: i put: card.].clubs := OrderedCollection new.diamonds := OrderedCollection new.hearts := OrderedCollection new.spades := OrderedCollection new.twoDigits := SortedCollection new.threeDigits := SortedCollection new. 1 to: 9 do: [ :i | ((deck at: i) size == 3) ifTrue: [threeDigits add: (deck at: i)] ifFalse: [twoDigits add: (deck at: i)]. ].hand :=  (twoDigits asArray) , (threeDigits asArray).1 to: 9 do: [ :i |    card := hand at: i.	temp := card at: (card size).	(temp == $C) ifTrue: [clubs add: temp].	(temp == $D) ifTrue: [diamonds add: temp].	(temp == $H) ifTrue: [hearts add: temp].	(temp == $S) ifTrue: [spades add: temp].    ].Transcript show: clubs; cr.Transcript show: diamonds; cr.Transcript show: hearts; cr.Transcript show: spades; cr.Transcript show: hand; cr.	! !!Poker methodsFor: 'as yet unclassified' stamp: 'MagdalenaDhima 1/30/2021 09:56'!sort: newShuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| threeDigits twoDigits |threeDigits := SortedCollection new. twoDigits := SortedCollection new.Transcript show: newShuf; cr.1 to: 9 do: [ :i | ((newShuf at: i) size == 3) ifTrue: [threeDigits add: (newShuf at: i)] ifFalse: [twoDigits add: (newShuf at: i)]. ].! !!Poker methodsFor: 'sorting' stamp: 'MagdalenaDhima 1/30/2021 09:57' prior: 33564265!sort: newShuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| threeDigits twoDigits nice |threeDigits := SortedCollection new. twoDigits := SortedCollection new.Transcript show: newShuf; cr.1 to: 9 do: [ :i | ((newShuf at: i) size == 3) ifTrue: [threeDigits add: (newShuf at: i)] ifFalse: [twoDigits add: (newShuf at: i)]. ].nice :=  (twoDigits asArray) , (threeDigits asArray).^nice! !!Poker methodsFor: 'sorting' stamp: 'MagdalenaDhima 1/30/2021 09:57' prior: 33564740!sort: newShuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| threeDigits twoDigits nice |threeDigits := SortedCollection new. twoDigits := SortedCollection new.1 to: 9 do: [ :i | ((newShuf at: i) size == 3) ifTrue: [threeDigits add: (newShuf at: i)] ifFalse: [twoDigits add: (newShuf at: i)]. ].nice :=  (twoDigits asArray) , (threeDigits asArray).^nice! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 09:58' prior: 33558713!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| temp values suits output val newShuf |	newShuf := Array new.	values := #('ace' '2' '3' '4' '5' '6' '7' '8' '9' '10' 'Jack' 'Queen' 'King').	suits := #('Clubs' 'Diamonds' 'Hearts' 'Spades').	9 timesRepeat: [ :i | 		val := shuf at: i.		temp := val % 13.		output := (temp == 0) 			ifFalse: [values at: temp]			ifTrue: [values at: 0]		. 		temp := val-1 / 13 floor. 		val at: (output size +1) put: (suits at: temp). 		newShuf at: i put: output.	].	^ newShuf	! !!Poker methodsFor: 'as yet unclassified' stamp: 'MagdalenaDhima 1/30/2021 10:09'!getData: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| dataInHand card temp temp2 |	dataInHand := Dictionary new. dataInHand := Dictionary new. 1 to: 13 do: [ :i | dataInHand at: i put: 0].dataInHand at: 'C' put: 0. dataInHand at: 'D' put: 0. dataInHand at: 'H' put: 0. dataInHand at: 'S' put: 0.1 to: 9 do: [ :i |	card := nice at: i.	temp := (card copyFrom: 1 to: (card size-1)).	temp2 := card at: (card size).	dataInHand at: temp asNumber put: ((dataInHand at: temp asNumber) +1 ).	dataInHand at: temp2 asString put: ((dataInHand at: temp2 asString) +1 ). ].^dataInHand! !!Poker methodsFor: 'as yet unclassified' stamp: 'MagdalenaDhima 1/30/2021 10:10' prior: 33566469!getData: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| dataInHand card temp temp2 |	dataInHand := Dictionary new. dataInHand := Dictionary new. 1 to: 13 do: [ :i | dataInHand at: i put: 0].dataInHand at: 'C' put: 0. dataInHand at: 'D' put: 0. dataInHand at: 'H' put: 0. dataInHand at: 'S' put: 0.1 to: 9 do: [ :i |	card := nice at: i.	temp := (card copyFrom: 1 to: (card size-1)).	temp2 := card at: card size.	dataInHand at: temp asNumber put: ((dataInHand at: temp asNumber) +1 ).	dataInHand at: temp2 asString put: ((dataInHand at: temp2 asString) +1 ). ].^dataInHand! !!Poker methodsFor: 'as yet unclassified' stamp: 'MagdalenaDhima 1/30/2021 10:10' prior: 33567224!getData: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| dataInHand card temp temp2 |	dataInHand := Dictionary new. dataInHand := Dictionary new. 1 to: 13 do: [ :i | dataInHand at: i put: 0].dataInHand at: 'C' put: 0. dataInHand at: 'D' put: 0. dataInHand at: 'H' put: 0. dataInHand at: 'S' put: 0.1 to: 9 do: [ :i |	card := nice at: i.	temp := (card copyFrom: 1 to: (card size-1)).	temp2 := card at: (card size).	dataInHand at: temp asNumber put: ((dataInHand at: temp asNumber) +1 ).	dataInHand at: temp2 asString put: ((dataInHand at: temp2 asString) +1 ). ].^dataInHand! !!Poker methodsFor: 'as yet unclassified' stamp: 'MagdalenaDhima 1/30/2021 10:10' prior: 33567977!getData: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| dataInHand card temp temp2 |	dataInHand := Dictionary new. 1 to: 13 do: [ :i | dataInHand at: i put: 0].dataInHand at: 'C' put: 0. dataInHand at: 'D' put: 0. dataInHand at: 'H' put: 0. dataInHand at: 'S' put: 0.1 to: 9 do: [ :i |	card := nice at: i.	temp := (card copyFrom: 1 to: (card size-1)).	temp2 := card at: (card size).	dataInHand at: temp asNumber put: ((dataInHand at: temp asNumber) +1 ).	dataInHand at: temp2 asString put: ((dataInHand at: temp2 asString) +1 ). ].^dataInHand! !!Poker methodsFor: 'as yet unclassified' stamp: 'MagdalenaDhima 1/30/2021 10:36'!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak |streaks := OrderedCollection new.notFound := true.2 to: 9 do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).		(previous asNumber == (current asNumber -1) & notFound)		ifTrue: [(streaks size == 0) ifTrue: [streaks add: previousCard]. streaks add: card]		ifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]]].Transcript show: streaks; cr.highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size) to: (streaks size -4) by: -1 do: [ :i | highestStreak add: (streaks at: i) ]].Transcript show: highestStreak; cr.^streaks! !!Poker methodsFor: 'as yet unclassified' stamp: 'MagdalenaDhima 1/30/2021 10:36' prior: 33569441!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak |streaks := OrderedCollection new.notFound := true.2 to: 9 do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).		(previous asNumber == (current asNumber -1) & notFound)		ifTrue: [(streaks size == 0) ifTrue: [streaks add: previousCard]. streaks add: card]		ifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]]].highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size) to: (streaks size -4) by: -1 do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak! !!Poker methodsFor: 'as yet unclassified' stamp: 'MagdalenaDhima 1/30/2021 10:38' prior: 33570476!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak |streaks := OrderedCollection new.notFound := true.2 to: 9 do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).		(previous asNumber == (current asNumber -1) & notFound)		ifTrue: [(streaks size == 0) ifTrue: [streaks add: previousCard]. streaks add: card]		ifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]]].highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak! !!Poker methodsFor: 'as yet unclassified' stamp: 'MagdalenaDhima 1/30/2021 11:09'!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak |suitStreak := OrderedCollection new.2 to: streaks size do: [ :i | 	previousCard := streaks at: (i-1).	previous := previousCard at: previousCard size.	card := streaks at: i.	current := card at: card size.	(previous == current)		ifTrue: [(suitStreak size == 0) ifTrue:[suitStreak add: previousCard]. suitStreak add: card]].	highestSuitStreak := OrderedCollection new.(suitStreak size >= 5) ifTrue: [	(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]].^highestSuitStreak! !!Poker methodsFor: 'as yet unclassified' stamp: 'MagdalenaDhima 1/30/2021 11:09' prior: 33572403!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak |suitStreak := OrderedCollection new.2 to: streaks size do: [ :i | 	previousCard := streaks at: (i-1).	previous := previousCard at: previousCard size.	card := streaks at: i.	current := card at: card size.	(previous == current)		ifTrue: [(suitStreak isEmpty) ifTrue:[suitStreak add: previousCard]. suitStreak add: card]].	highestSuitStreak := OrderedCollection new.(suitStreak size >= 5) ifTrue: [	(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]].^highestSuitStreak! !!Poker methodsFor: 'as yet unclassified' stamp: 'MagdalenaDhima 1/30/2021 11:11' prior: 33571451!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak |streaks := OrderedCollection new.notFound := true.2 to: 9 do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).		(previous asNumber == (current asNumber -1) & notFound)		ifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]		ifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]]].highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak! !Object subclass: #Poker	instanceVariableNames: ''	classVariableNames: ''	package: 'CPS506'!Object subclass: #Poker	instanceVariableNames: 'hand'	classVariableNames: ''	package: 'CPS506'!!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 12:05' prior: 33565793!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| temp values suits output val |	hand := Array new.	values := #('ace' '2' '3' '4' '5' '6' '7' '8' '9' '10' 'Jack' 'Queen' 'King').	suits := #('Clubs' 'Diamonds' 'Hearts' 'Spades').	9 timesRepeat: [ :i | 		val := shuf at: i.		temp := val % 13.		output := (temp == 0) 			ifFalse: [values at: temp]			ifTrue: [values at: 0]		. 		temp := val-1 / 13 floor. 		val at: (output size +1) put: (suits at: temp). 		hand at: i put: output.	].	^hand	! !Object subclass: #Poker	instanceVariableNames: 'hand shuf'	classVariableNames: ''	package: 'CPS506'!Object subclass: #Poker	instanceVariableNames: 'hand'	classVariableNames: ''	package: 'CPS506'!!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 12:14' prior: 33575219!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| temp values suits output val |	hand := Array new.	values := #('ace' '2' '3' '4' '5' '6' '7' '8' '9' '10' 'Jack' 'Queen' 'King').	suits := #('Clubs' 'Diamonds' 'Hearts' 'Spades').	shuf size timesRepeat: [ :i | 		val := shuf at: i.		temp := val % 13.		output := (temp == 0) 			ifFalse: [values at: temp]			ifTrue: [values at: 0]		. 		temp := val-1 / 13 floor. 		val at: (output size +1) put: (suits at: temp). 		hand at: i put: output.	].	^hand	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 12:15' prior: 33576088!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| temp values suits output val |	hand := Array new.	values := #('ace' '2' '3' '4' '5' '6' '7' '8' '9' '10' 'Jack' 'Queen' 'King').	suits := #('Clubs' 'Diamonds' 'Hearts' 'Spades').	9 timesRepeat: [ :i | 		val := shuf at: i.		temp := val % 13.		output := (temp == 0) 			ifFalse: [values at: temp]			ifTrue: [values at: 0]		. 		temp := val-1 / 13 floor. 		val at: (output size +1) put: (suits at: temp). 		hand at: i put: output.	].	^hand	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 12:29' prior: 33576760!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| temp values suits output val |	hand := Array new.	values := #('ace' '2' '3' '4' '5' '6' '7' '8' '9' '10' 'Jack' 'Queen' 'King').	suits := #('Clubs' 'Diamonds' 'Hearts' 'Spades').	1 to: 9 do: [ :i | 		val := shuf at: i.		temp := val % 13.		output := (temp == 0) 			ifFalse: [values at: temp]			ifTrue: [values at: 13]		. 		temp := val-1 // 13 + 1 floor. 		output := output , (suits at: temp). 		hand at: i put: output.].^hand	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 12:30' prior: 33577424!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| temp values suits output val |	hand := Array new.	values := #('ace' '2' '3' '4' '5' '6' '7' '8' '9' '10' 'Jack' 'Queen' 'King').	suits := #('Clubs' 'Diamonds' 'Hearts' 'Spades').	1 to: (shuf size) do: [ :i | 		val := shuf at: i.		temp := val % 13.		output := (temp == 0) 			ifFalse: [values at: temp]			ifTrue: [values at: 13]		. 		temp := val-1 // 13 + 1 floor. 		output := output , (suits at: temp). 		hand at: i put: output.].^hand	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 12:30' prior: 33578078!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| temp values suits output val |	hand := Array new.	values := #('ace' '2' '3' '4' '5' '6' '7' '8' '9' '10' 'Jack' 'Queen' 'King').	suits := #('Clubs' 'Diamonds' 'Hearts' 'Spades').	1 to: (shuf size) do: [ :i | 		val := shuf at: i.		temp := val % 13.		output := (temp == 0) 			ifTrue: [values at: 13]			ifFalse: [values at: temp]		. 		temp := val-1 // 13 + 1 floor. 		output := output , (suits at: temp). 		hand at: i put: output.].^hand	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 12:34' prior: 33578742!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| temp values suits output val |	hand := Array new.	values := #('ace' '2' '3' '4' '5' '6' '7' '8' '9' '10' 'Jack' 'Queen' 'King').	suits := #('Clubs' 'Diamonds' 'Hearts' 'Spades').	(shuf size) timesRepeat: [ :i | 		val := shuf at: i.		temp := val % 13.		output := (temp == 0) 			ifTrue: [values at: 13]			ifFalse: [values at: temp]		. 		temp := val-1 // 13 + 1 floor. 		output := output , (suits at: temp). 		hand at: i put: output.].^hand	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 12:35' prior: 33579406!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| temp values suits output val |	hand := Array new.	values := #('ace' '2' '3' '4' '5' '6' '7' '8' '9' '10' 'Jack' 'Queen' 'King').	suits := #('Clubs' 'Diamonds' 'Hearts' 'Spades').	1 to: (shuf size) do: [ :i | 		val := shuf at: i.		temp := val % 13.		output := (temp == 0) 			ifTrue: [values at: 13]			ifFalse: [values at: temp]		. 		temp := val-1 // 13 + 1 floor. 		output := output , (suits at: temp). 		hand at: i put: output.].^hand	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 12:38' prior: 33580073!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| temp values suits output val |	hand := Array new: 9.	values := #('ace' '2' '3' '4' '5' '6' '7' '8' '9' '10' 'Jack' 'Queen' 'King').	suits := #('Clubs' 'Diamonds' 'Hearts' 'Spades').1 to: 9 do: [ :i | 	Transcript cr.	Transcript show: i; cr.	val := shuf at: i.	Transcript show: val; cr.	temp := val % 13.	Transcript show: temp; cr.	output := (temp == 0) 		ifFalse: [values at: temp]		ifTrue: [values at: 13]	. 	Transcript show: output; cr.	temp := val-1 // 13 + 1 floor. 	Transcript show: temp; cr.	output := output , (suits at: temp). 	Transcript show: output; cr.	hand at: i put: output.	Transcript show: hand; cr.].^hand	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 12:46' prior: 33580737!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| temp values suits output val |	hand := Array new: 9.	values := #('1' '2' '3' '4' '5' '6' '7' '8' '9' '10' '11' '12' '13').	suits := #('C' 'D' 'H' 'S').1 to: 9 do: [ :i | 	Transcript cr.	Transcript show: i; cr.	val := shuf at: i.	Transcript show: val; cr.	temp := val % 13.	Transcript show: temp; cr.	output := (temp == 0) 		ifFalse: [values at: temp]		ifTrue: [values at: 13]	. 	Transcript show: output; cr.	temp := val-1 // 13 + 1 floor. 	Transcript show: temp; cr.	output := output , (suits at: temp). 	Transcript show: output; cr.	hand at: i put: output.	Transcript show: hand; cr.].^hand	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 12:47' prior: 33581596!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| temp values suits output val |	hand := Array new: 9.	values := #('1' '2' '3' '4' '5' '6' '7' '8' '9' '10' '11' '12' '13').	suits := #('C' 'D' 'H' 'S').1 to: 9 do: [ :i | 	val := shuf at: i.	temp := val % 13.	output := (temp == 0) 		ifFalse: [values at: temp]		ifTrue: [values at: 13]	. 	temp := val-1 // 13 + 1 floor. 	output := output , (suits at: temp). 	hand at: i put: output.].^hand	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 12:48' prior: 33582425!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| temp values suits output val |	hand := Array new: 9.	values := #('1' '2' '3' '4' '5' '6' '7' '8' '9' '10' '11' '12' '13').	suits := #('C' 'D' 'H' 'S').9 timesRepeat: [ :i | 	val := shuf at: i.	temp := val % 13.	output := (temp == 0) 		ifFalse: [values at: temp]		ifTrue: [values at: 13]	. 	temp := val-1 // 13 + 1 floor. 	output := output , (suits at: temp). 	hand at: i put: output.].^hand	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 12:48' prior: 33583042!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| temp values suits output val |	hand := Array new: 9.	values := #('1' '2' '3' '4' '5' '6' '7' '8' '9' '10' '11' '12' '13').	suits := #('C' 'D' 'H' 'S').1 to: 9 do: [ :i | 	val := shuf at: i.	temp := val % 13.	output := (temp == 0) 		ifFalse: [values at: temp]		ifTrue: [values at: 13]	. 	temp := val-1 // 13 + 1 floor. 	output := output , (suits at: temp). 	hand at: i put: output.].^hand	! !!Poker methodsFor: 'as yet unclassified' stamp: 'MagdalenaDhima 1/30/2021 12:51'!convert: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| temp values suits output val |	hand := Array new: 9.	values := #('1' '2' '3' '4' '5' '6' '7' '8' '9' '10' '11' '12' '13').	suits := #('C' 'D' 'H' 'S').	1 to: 9 do: [ :i | 		val := shuf at: i.		temp := val % 13.		output := (temp == 0) 			ifFalse: [values at: temp]			ifTrue: [values at: 13]		. 		temp := val-1 // 13 + 1 floor. 		output := output , (suits at: temp). 		hand at: i put: output.	].	^hand! !!Poker methodsFor: 'actions' stamp: 'MagdalenaDhima 1/30/2021 12:52' prior: 33584273!convert: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| temp values suits output val |	hand := Array new: 9.	values := #('1' '2' '3' '4' '5' '6' '7' '8' '9' '10' '11' '12' '13').	suits := #('C' 'D' 'H' 'S').	1 to: 9 do: [ :i | 		val := shuf at: i.		temp := val % 13.		output := (temp == 0) 			ifFalse: [values at: temp]			ifTrue: [values at: 13]		. 		temp := val-1 // 13 + 1 floor. 		output := output , (suits at: temp). 		hand at: i put: output.	].! !!Poker methodsFor: 'actions' stamp: 'MagdalenaDhima 1/30/2021 12:54'!convert	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| temp values suits output val |	hand := Array new: 9.	values := #('1' '2' '3' '4' '5' '6' '7' '8' '9' '10' '11' '12' '13').	suits := #('C' 'D' 'H' 'S').	1 to: 9 do: [ :i | 		val := hand at: i.		temp := val % 13.		output := (temp == 0) 			ifFalse: [values at: temp]			ifTrue: [values at: 13]		. 		temp := val-1 // 13 + 1 floor. 		output := output , (suits at: temp). 		hand at: i put: output.	].! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 12:54' prior: 33583662!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					hand := shuf.	hand := hand convert.	^hand	! !Poker removeSelector: #convert:!!Poker methodsFor: 'actions' stamp: 'MagdalenaDhima 1/30/2021 12:56'!convert: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| temp values suits output val |	hand := Array new: 9.	values := #('1' '2' '3' '4' '5' '6' '7' '8' '9' '10' '11' '12' '13').	suits := #('C' 'D' 'H' 'S').	1 to: 9 do: [ :i | 		val := shuf at: i.		temp := val % 13.		output := (temp == 0) 			ifFalse: [values at: temp]			ifTrue: [values at: 13]		. 		temp := val-1 // 13 + 1 floor. 		output := output , (suits at: temp). 		hand at: i put: output.	].! !Poker removeSelector: #convert:!!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 13:02' prior: 33586120!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					hand := self convert.	^hand	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 13:03' prior: 33587048!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					hand := self convert: shuf.	^hand	! !!Poker methodsFor: 'actions' stamp: 'MagdalenaDhima 1/30/2021 13:03'!convert: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| temp values suits output val |	hand := Array new: 9.	values := #('1' '2' '3' '4' '5' '6' '7' '8' '9' '10' '11' '12' '13').	suits := #('C' 'D' 'H' 'S').	1 to: 9 do: [ :i | 		val := shuf at: i.		temp := val % 13.		output := (temp == 0) 			ifFalse: [values at: temp]			ifTrue: [values at: 13]		. 		temp := val-1 // 13 + 1 floor. 		output := output , (suits at: temp). 		hand at: i put: output.	].! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 13:04' prior: 33587289!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					self convert: shuf.	^hand	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 13:05'!getData	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| dataInHand card temp temp2 |	dataInHand := Dictionary new. 1 to: 13 do: [ :i | dataInHand at: i put: 0].dataInHand at: 'C' put: 0. dataInHand at: 'D' put: 0. dataInHand at: 'H' put: 0. dataInHand at: 'S' put: 0.1 to: (hand size) do: [ :i |	card := hand at: i.	temp := (card copyFrom: 1 to: (card size-1)).	temp2 := card at: (card size).	dataInHand at: temp asNumber put: ((dataInHand at: temp asNumber) +1 ).	dataInHand at: temp2 asString put: ((dataInHand at: temp2 asString) +1 ). ].^dataInHand! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 13:06' prior: 33588140!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| sorted |	self convert: shuf.	sorted := self getData.	^hand	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 13:06' prior: 33589082!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| sorted |	self convert: shuf.	sorted := self getData.	^sorted	! !Poker removeSelector: #getData:!!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 13:09' prior: 33589354!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| sorted data |	self convert: shuf.	Transcript show: hand.				data := self getData.	Transcript show: data.	^sorted	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 13:09' prior: 33589662!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| sorted data |	self convert: shuf.	Transcript show: hand; cr.				data := self getData.	Transcript show: data; cr.	^sorted	! !!Poker methodsFor: 'sorting' stamp: 'MagdalenaDhima 1/30/2021 13:11' prior: 33565280!sort: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| threeDigits twoDigits sorted |threeDigits := SortedCollection new. twoDigits := SortedCollection new.1 to: 9 do: [ :i | ((shuf at: i) size == 3) ifTrue: [threeDigits add: (shuf at: i)] ifFalse: [twoDigits add: (shuf at: i)]. ].sorted :=  (twoDigits asArray) , (threeDigits asArray).^sorted! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 13:12' prior: 33589993!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| sorted data |	self convert: shuf.	Transcript show: hand; cr.		sorted := self sort: hand.	Transcript show: sorted; cr.		data := self getData.	Transcript show: data; cr.	^sorted	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 13:16' prior: 33590837!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| sorted data topFive |	self convert: shuf.	Transcript show: hand; cr.		sorted := self sort: hand.	Transcript show: sorted; cr.		data := self getData.	Transcript show: data; cr.		topFive := self getHighestStreak: sorted.	Transcript show: topFive; cr.		^sorted	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 13:19' prior: 33591232!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| sorted data straight flush |	self convert: shuf.	Transcript show: hand; cr.		sorted := self sort: hand.	Transcript show: sorted; cr.		data := self getData.	Transcript show: data; cr.		straight := self getHighestStreak: sorted.	Transcript show: straight; cr.		flush := self getHighestSuitStreak: sorted.	Transcript show: flush; cr.		^sorted	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 13:51' prior: 33591713!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| sorted data straight flush straightFlush |	self convert: shuf.	Transcript show: hand; cr.		sorted := self sort: hand.	Transcript show: sorted; cr.		data := self getData.	Transcript show: data; cr.		straight := self getHighestStreak: sorted.	Transcript show: straight; cr.		flush := self getHighestSuitStreak: sorted.	Transcript show: flush; cr.		straightFlush := self getHighestStreak: flush.	Transcript show: straightFlush; cr.		^sorted	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 13:53' prior: 33592279!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| sorted data straight flush straightFlush |	self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		sorted := self sort: hand.	Transcript show: 'sorted'; cr.	Transcript show: sorted; cr.		data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.		straight := self getHighestStreak: sorted.	Transcript show: 'straight'; cr.	Transcript show: straight; cr.		flush := self getHighestSuitStreak: sorted.	Transcript show: 'flush'; cr.	Transcript show: flush; cr.		straightFlush := self getHighestStreak: flush.	Transcript show: straightFlush; cr.		^sorted	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 13:55' prior: 33574067!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak |streaks := OrderedCollection new.notFound := true.2 to: (nice size) do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).		(previous asNumber == (current asNumber -1) & notFound)		ifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]		ifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]]].highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 13:56' prior: 33593770!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak |streaks := OrderedCollection new.notFound := true.2 to: nice size do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).		(previous asNumber == (current asNumber -1) & notFound)		ifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]		ifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]]].highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 13:56' prior: 33592946!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| sorted data straight flush straightFlush |	self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		sorted := self sort: hand.	Transcript show: 'sorted'; cr.	Transcript show: sorted; cr.		data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.		straight := self getHighestStreak: sorted.	Transcript show: 'straight'; cr.	Transcript show: straight; cr.		flush := self getHighestSuitStreak: sorted.	Transcript show: 'flush'; cr.	Transcript show: flush; cr.		straightFlush := self getHighestStreak: flush.	Transcript show: 'straightFlush'; cr.	Transcript show: straightFlush; cr.		^sorted	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 14:45'!returnSuitCards: suitCard	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| cardsOfAKind card temp |	cardsOfAKind := OrderedCollection new.	1 to: (hand size) do: [ :i | 		card := hand at: i.		temp := card at: (card size).		(temp == suitCard) ifTrue: [cardsOfAKind add: card].].^cardsOfAKind! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 14:46' prior: 33595700!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |	self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		sorted := self sort: hand.	Transcript show: 'sorted'; cr.	Transcript show: sorted; cr.		data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.		straight := self getHighestStreak: sorted.	Transcript show: 'straight'; cr.	Transcript show: straight; cr.		flush := self getHighestSuitStreak: sorted.	Transcript show: 'flush'; cr.	Transcript show: flush; cr.		straightFlush := self getHighestStreak: flush.	Transcript show: 'straightFlush'; cr.	Transcript show: straightFlush; cr.		maxNumOfAKind := data inject: 0 into: [:a :c | (a  > c )   ifTrue: [a]   ifFalse: [c]].	suitOfAKind := data keyAtValue: maxNumOfAKind.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitCards; cr.	^sorted	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 14:47' prior: 33596997!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |	self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		sorted := self sort: hand.	Transcript show: 'sorted'; cr.	Transcript show: sorted; cr.		data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.		straight := self getHighestStreak: sorted.	Transcript show: 'straight'; cr.	Transcript show: straight; cr.		flush := self getHighestSuitStreak: sorted.	Transcript show: 'flush'; cr.	Transcript show: flush; cr.		straightFlush := self getHighestStreak: flush.	Transcript show: 'straightFlush'; cr.	Transcript show: straightFlush; cr.		maxNumOfAKind := data inject: 0 into: [:a :c | (a  > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: suitCards; cr.	suitOfAKind := data keyAtValue: maxNumOfAKind.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitCards; cr.	^sorted	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 14:48' prior: 33598119!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |	self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		sorted := self sort: hand.	Transcript show: 'sorted'; cr.	Transcript show: sorted; cr.		data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.		straight := self getHighestStreak: sorted.	Transcript show: 'straight'; cr.	Transcript show: straight; cr.		flush := self getHighestSuitStreak: sorted.	Transcript show: 'flush'; cr.	Transcript show: flush; cr.		straightFlush := self getHighestStreak: flush.	Transcript show: 'straightFlush'; cr.	Transcript show: straightFlush; cr.		maxNumOfAKind := data inject: 0 into: [:a :c | (a value  > c value )   ifTrue: [a]   ifFalse: [c]].	Transcript show: suitCards; cr.	suitOfAKind := data keyAtValue: maxNumOfAKind.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitCards; cr.	^sorted	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 14:51' prior: 33599274!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |	self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		sorted := self sort: hand.	Transcript show: 'sorted'; cr.	Transcript show: sorted; cr.		data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.		straight := self getHighestStreak: sorted.	Transcript show: 'straight'; cr.	Transcript show: straight; cr.		flush := self getHighestSuitStreak: sorted.	Transcript show: 'flush'; cr.	Transcript show: flush; cr.		straightFlush := self getHighestStreak: flush.	Transcript show: 'straightFlush'; cr.	Transcript show: straightFlush; cr.		maxNumOfAKind := (data copyFrom: 1 to: 4) inject: 0 into: [:a :c | (a value  > c value )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := data keyAtValue: maxNumOfAKind.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitCards; cr.	^sorted	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 14:52' prior: 33600441!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |	self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		sorted := self sort: hand.	Transcript show: 'sorted'; cr.	Transcript show: sorted; cr.		data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.		straight := self getHighestStreak: sorted.	Transcript show: 'straight'; cr.	Transcript show: straight; cr.		flush := self getHighestSuitStreak: sorted.	Transcript show: 'flush'; cr.	Transcript show: flush; cr.		straightFlush := self getHighestStreak: flush.	Transcript show: 'straightFlush'; cr.	Transcript show: straightFlush; cr.		maxNumOfAKind := (data keys copyFrom: 1 to: 4) inject: 0 into: [:a :c | (a value  > c value )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := data keyAtValue: maxNumOfAKind.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitCards; cr.	^sorted	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 14:53' prior: 33601632!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |	self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		sorted := self sort: hand.	Transcript show: 'sorted'; cr.	Transcript show: sorted; cr.		data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.		straight := self getHighestStreak: sorted.	Transcript show: 'straight'; cr.	Transcript show: straight; cr.		flush := self getHighestSuitStreak: sorted.	Transcript show: 'flush'; cr.	Transcript show: flush; cr.		straightFlush := self getHighestStreak: flush.	Transcript show: 'straightFlush'; cr.	Transcript show: straightFlush; cr.		maxNumOfAKind := ((data values) copyFrom: 1 to: 4) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := data keyAtValue: maxNumOfAKind.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitCards; cr.	^sorted	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 14:54' prior: 33602828!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |	self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		sorted := self sort: hand.	Transcript show: 'sorted'; cr.	Transcript show: sorted; cr.		data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.		straight := self getHighestStreak: sorted.	Transcript show: 'straight'; cr.	Transcript show: straight; cr.		flush := self getHighestSuitStreak: sorted.	Transcript show: 'flush'; cr.	Transcript show: flush; cr.		straightFlush := self getHighestStreak: flush.	Transcript show: 'straightFlush'; cr.	Transcript show: straightFlush; cr.		Transcript show: ((data values) copyFrom: 1 to: 4); cr.	maxNumOfAKind := ((data values) copyFrom: 1 to: 4) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := data keyAtValue: maxNumOfAKind.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitCards; cr.	^sorted	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 14:54' prior: 33604015!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |	self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		sorted := self sort: hand.	Transcript show: 'sorted'; cr.	Transcript show: sorted; cr.		data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.		straight := self getHighestStreak: sorted.	Transcript show: 'straight'; cr.	Transcript show: straight; cr.		flush := self getHighestSuitStreak: sorted.	Transcript show: 'flush'; cr.	Transcript show: flush; cr.		straightFlush := self getHighestStreak: flush.	Transcript show: 'straightFlush'; cr.	Transcript show: straightFlush; cr.		Transcript show: (data values); cr.	Transcript show: ((data values) copyFrom: 1 to: 4); cr.	maxNumOfAKind := ((data values) copyFrom: 1 to: 4) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := data keyAtValue: maxNumOfAKind.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitCards; cr.	^sorted	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 14:55' prior: 33605259!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |	self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		sorted := self sort: hand.	Transcript show: 'sorted'; cr.	Transcript show: sorted; cr.		data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.		straight := self getHighestStreak: sorted.	Transcript show: 'straight'; cr.	Transcript show: straight; cr.		flush := self getHighestSuitStreak: sorted.	Transcript show: 'flush'; cr.	Transcript show: flush; cr.		straightFlush := self getHighestStreak: flush.	Transcript show: 'straightFlush'; cr.	Transcript show: straightFlush; cr.		Transcript show: (data values); cr.	Transcript show: ((data values) copyFrom: 13 to: 17); cr.	maxNumOfAKind := ((data values) copyFrom: 1 to: 4) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := data keyAtValue: maxNumOfAKind.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitCards; cr.	^sorted	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 14:56' prior: 33606540!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |	self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		sorted := self sort: hand.	Transcript show: 'sorted'; cr.	Transcript show: sorted; cr.		data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.		straight := self getHighestStreak: sorted.	Transcript show: 'straight'; cr.	Transcript show: straight; cr.		flush := self getHighestSuitStreak: sorted.	Transcript show: 'flush'; cr.	Transcript show: flush; cr.		straightFlush := self getHighestStreak: flush.	Transcript show: 'straightFlush'; cr.	Transcript show: straightFlush; cr.		Transcript show: (data values); cr.	Transcript show: ((data values) copyFrom: 14 to: 17); cr.	maxNumOfAKind := ((data values) copyFrom: 1 to: 4) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := data keyAtValue: maxNumOfAKind.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitCards; cr.	^sorted	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 14:57' prior: 33607823!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |	self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		sorted := self sort: hand.	Transcript show: 'sorted'; cr.	Transcript show: sorted; cr.		data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.		straight := self getHighestStreak: sorted.	Transcript show: 'straight'; cr.	Transcript show: straight; cr.		flush := self getHighestSuitStreak: sorted.	Transcript show: 'flush'; cr.	Transcript show: flush; cr.		straightFlush := self getHighestStreak: flush.	Transcript show: 'straightFlush'; cr.	Transcript show: straightFlush; cr.		maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := data keyAtValue: maxNumOfAKind.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitCards; cr.	^sorted	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 14:57' prior: 33609106!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |	self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		sorted := self sort: hand.	Transcript show: 'sorted'; cr.	Transcript show: sorted; cr.		data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.		straight := self getHighestStreak: sorted.	Transcript show: 'straight'; cr.	Transcript show: straight; cr.		flush := self getHighestSuitStreak: sorted.	Transcript show: 'flush'; cr.	Transcript show: flush; cr.		straightFlush := self getHighestStreak: flush.	Transcript show: 'straightFlush'; cr.	Transcript show: straightFlush; cr.		maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := data keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitCards; cr.	^sorted	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 14:58' prior: 33596547!returnSuitCards: suit	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| cardsOfAKind card temp |	cardsOfAKind := OrderedCollection new.	1 to: (hand size) do: [ :i | 		card := hand at: i.		temp := card at: (card size).		(temp == suit) ifTrue: [cardsOfAKind add: card].].^cardsOfAKind! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 14:59' prior: 33611519!returnSuitCards: suit	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| cardsOfAKind card temp |	cardsOfAKind := OrderedCollection new.	1 to: (hand size) do: [ :i | 		card := hand at: i.		temp := card at: (card size).		(temp = suit) ifTrue: [cardsOfAKind add: card].].^cardsOfAKind! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 15:00' prior: 33611961!returnSuitCards: suit	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| cardsOfAKind card temp |	cardsOfAKind := OrderedCollection new.	1 to: (hand size) do: [ :i | 		card := hand at: i.		temp := card at: (card size).		Transcript show: temp class; cr.		Transcript show: suit class; cr.		(temp = suit) ifTrue: [cardsOfAKind add: card].].^cardsOfAKind! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 15:01' prior: 33612402!returnSuitCards: suit	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| cardsOfAKind card temp |	cardsOfAKind := OrderedCollection new.	1 to: (hand size) do: [ :i | 		card := hand at: i.		temp := card at: (card size).		Transcript show: temp class; cr.		Transcript show: suit class; cr.		(temp == suit asCharacter) ifTrue: [cardsOfAKind add: card].].^cardsOfAKind! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 15:01' prior: 33612913!returnSuitCards: suit	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| cardsOfAKind card temp |	cardsOfAKind := OrderedCollection new.	1 to: (hand size) do: [ :i | 		card := hand at: i.		temp := card at: (card size).		Transcript show: temp class; cr.		Transcript show: suit class; cr.		(temp == suit asString) ifTrue: [cardsOfAKind add: card].].^cardsOfAKind! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 15:01' prior: 33613437!returnSuitCards: suit	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| cardsOfAKind card temp |	cardsOfAKind := OrderedCollection new.	1 to: (hand size) do: [ :i | 		card := hand at: i.		temp := card at: (card size).		Transcript show: temp class; cr.		Transcript show: suit class; cr.		(temp asString == suit asString) ifTrue: [cardsOfAKind add: card].].^cardsOfAKind! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 15:02' prior: 33613958!returnSuitCards: suit	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| cardsOfAKind card temp |	cardsOfAKind := OrderedCollection new.	1 to: (hand size) do: [ :i | 		card := hand at: i.		temp := card at: (card size).		Transcript show: temp ; cr.		Transcript show: suit ; cr.		(temp asString == suit asString) ifTrue: [cardsOfAKind add: card].].^cardsOfAKind! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 15:02' prior: 33614488!returnSuitCards: suit	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| cardsOfAKind card temp |	cardsOfAKind := OrderedCollection new.	1 to: (hand size) do: [ :i | 		card := hand at: i.		temp := card at: (card size).		Transcript show: temp ; cr.		Transcript show: suit ; cr.		(temp asString == suit) ifTrue: [cardsOfAKind add: card].].^cardsOfAKind! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 15:03' prior: 33615008!returnSuitCards: suit	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| cardsOfAKind card temp |	cardsOfAKind := OrderedCollection new.	1 to: (hand size) do: [ :i | 		card := hand at: i.		temp := card at: (card size).		Transcript show: temp ; cr.		Transcript show: suit ; cr.		(temp asSymbol == suit asSymbol) ifTrue: [cardsOfAKind add: card].].^cardsOfAKind! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 15:03' prior: 33615519!returnSuitCards: suit	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| cardsOfAKind card temp |	cardsOfAKind := OrderedCollection new.	1 to: (hand size) do: [ :i | 		card := hand at: i.		temp := card at: (card size).		(temp asSymbol == suit asSymbol) ifTrue: [cardsOfAKind add: card].].^cardsOfAKind! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 15:15' prior: 33610295!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |	self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		sorted := self sort: hand.	Transcript show: 'sorted'; cr.	Transcript show: sorted; cr.		data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.		straight := self getHighestStreak: sorted.	Transcript show: 'straight'; cr.	Transcript show: straight; cr.		flush := self getHighestSuitStreak: sorted.	Transcript show: 'flush'; cr.	Transcript show: flush; cr.		straightFlush := self getHighestStreak: flush.	Transcript show: 'straightFlush'; cr.	Transcript show: straightFlush; cr.		(straightFlush size == 5) ifTrue: [^straightFlush].		maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := data keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitCards; cr.	^sorted	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 15:16' prior: 33616499!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |	self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		sorted := self sort: hand.	Transcript show: 'sorted'; cr.	Transcript show: sorted; cr.		data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.		straight := self getHighestStreak: sorted.	Transcript show: 'straight'; cr.	Transcript show: straight; cr.		flush := self getHighestSuitStreak: sorted.	Transcript show: 'flush'; cr.	Transcript show: flush; cr.		straightFlush := self getHighestStreak: flush.	Transcript show: 'straightFlush'; cr.	Transcript show: straightFlush; cr.		(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].		maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := data keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitCards; cr.	^sorted	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 15:38' prior: 33617778!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |	self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		sorted := self sort: hand.	Transcript show: 'sorted'; cr.	Transcript show: sorted; cr.		data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.		straight := self getHighestStreak: sorted.	Transcript show: 'straight'; cr.	Transcript show: straight; cr.		flush := self getHighestSuitStreak: sorted.	Transcript show: 'flush'; cr.	Transcript show: flush; cr.		straightFlush := self getHighestStreak: flush.	Transcript show: 'straightFlush'; cr.	Transcript show: straightFlush; cr.		(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].		maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := data keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	(suitCards size == 4) ifTrue: [Transcript show: 3; cr. ^suitCards].	^sorted	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 15:40' prior: 33619081!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |	self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		sorted := self sort: hand.	Transcript show: 'sorted'; cr.	Transcript show: sorted; cr.		data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.		straight := self getHighestStreak: sorted.	Transcript show: 'straight'; cr.	Transcript show: straight; cr.		flush := self getHighestSuitStreak: sorted.	Transcript show: 'flush'; cr.	Transcript show: flush; cr.		straightFlush := self getHighestStreak: flush.	Transcript show: 'straightFlush'; cr.	Transcript show: straightFlush; cr.		(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].		maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	(suitCards size == 4) ifTrue: [Transcript show: 3; cr. ^suitCards].	^sorted	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 15:43'!getStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak |suitStreak := OrderedCollection new.2 to: streaks size do: [ :i | 	previousCard := streaks at: (i-1).	previous := previousCard at: previousCard size.	card := streaks at: i.	current := card at: card size.	(previous == current)		ifTrue: [(suitStreak isEmpty) ifTrue:[suitStreak add: previousCard]. suitStreak add: card]].	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 15:45' prior: 33621800!getStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak |suitStreak := OrderedCollection new.2 to: streaks size do: [ :i | 	previousCard := streaks at: (i-1).	previous := previousCard at: previousCard size.	card := streaks at: i.	current := card at: card size.	(previous == current)		ifTrue: [(suitStreak isEmpty) ifTrue:[suitStreak add: previousCard]. suitStreak add: card]].	^suitStreak	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 15:49' prior: 33573236!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak |suitStreak := OrderedCollection new.2 to: streaks size do: [ :i | 	previousCard := streaks at: (i-1).	previous := previousCard at: previousCard size.	card := streaks at: i.	current := card at: card size.	(previous == current)		ifTrue: [(suitStreak isEmpty) ifTrue:[suitStreak add: previousCard]. suitStreak add: card]].highestSuitStreak := OrderedCollection new.(suitStreak size >= 5) 	ifTrue: [	(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].^highestSuitStreak! !Object subclass: #Poker	instanceVariableNames: 'hand', 'data'	classVariableNames: ''	package: 'CPS506'!Object subclass: #Poker	instanceVariableNames: 'hand data'	classVariableNames: ''	package: 'CPS506'!Object subclass: #Poker	instanceVariableNames: 'data'	classVariableNames: ''	package: 'CPS506'!Object subclass: #Poker	instanceVariableNames: 'hand'	classVariableNames: ''	package: 'CPS506'!Poker removeSelector: #convert!!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 16:21' prior: 33623041!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak dataInHand newList max |suitStreak := OrderedCollection new.dataInHand := Dictionary new.newList := OrderedCollection.dataInHand at: 'C' put: nil. dataInHand at: 'D' put: nil. dataInHand at: 'H' put: nil. dataInHand at: 'S' put: nil.2 to: streaks size do: [ :i | 	previousCard := streaks at: (i-1).	previous := previousCard at: previousCard size.	card := streaks at: i.	current := card at: card size.	(previous == current)		ifTrue: [(suitStreak isEmpty) ifTrue:[suitStreak add: previousCard]. suitStreak add: card]		ifFalse: [(suitStreak size ~= 0) ifTrue: [dataInHand at: previous put: suitStreak. suitStreak := 			OrderedCollection new] ] ].	(suitStreak size ~= 0) ifTrue: [dataInHand at: previous put: suitStreak].	suitStreak := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 16:21' prior: 33624354!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak dataInHand max |suitStreak := OrderedCollection new.dataInHand := Dictionary new.dataInHand at: 'C' put: nil. dataInHand at: 'D' put: nil. dataInHand at: 'H' put: nil. dataInHand at: 'S' put: nil.2 to: streaks size do: [ :i | 	previousCard := streaks at: (i-1).	previous := previousCard at: previousCard size.	card := streaks at: i.	current := card at: card size.	(previous == current)		ifTrue: [(suitStreak isEmpty) ifTrue:[suitStreak add: previousCard]. suitStreak add: card]		ifFalse: [(suitStreak size ~= 0) ifTrue: [dataInHand at: previous put: suitStreak. suitStreak := 			OrderedCollection new] ] ].	(suitStreak size ~= 0) ifTrue: [dataInHand at: previous put: suitStreak].	suitStreak := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 16:24' prior: 33620420!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |	self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		sorted := self sort: hand.	Transcript show: 'sorted'; cr.	Transcript show: sorted; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight := self getHighestStreak: sorted.	Transcript show: 'straight'; cr.	Transcript show: straight; cr.		flush := self getHighestSuitStreak: sorted.	Transcript show: 'flush'; cr.	Transcript show: flush; cr.		straightFlush := self getHighestStreak: flush.	Transcript show: 'straightFlush'; cr.	Transcript show: straightFlush; cr.		(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].		maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	(suitCards size == 4) ifTrue: [Transcript show: 3; cr. ^suitCards].	^sorted	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 16:25' prior: 33625801!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |suitStreak := OrderedCollection new.newList :=  OrderedCollection new.dataInHand := Dictionary new.dataInHand at: 'C' put: newList. dataInHand at: 'D' put: newList. dataInHand at: 'H' put: newList. dataInHand at: 'S' put: newList.2 to: streaks size do: [ :i | 	previousCard := streaks at: (i-1).	previous := previousCard at: previousCard size.	card := streaks at: i.	current := card at: card size.	(previous == current)		ifTrue: [(suitStreak isEmpty) ifTrue:[suitStreak add: previousCard]. suitStreak add: card]		ifFalse: [(suitStreak size ~= 0) ifTrue: [dataInHand at: previous put: suitStreak. suitStreak := 			OrderedCollection new] ] ].	(suitStreak size ~= 0) ifTrue: [dataInHand at: previous put: suitStreak].	suitStreak := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 16:26' prior: 33627210!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |	self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		sorted := self sort: hand.	Transcript show: 'sorted'; cr.	Transcript show: sorted; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight := self getHighestStreak: sorted.	Transcript show: 'straight'; cr.	Transcript show: straight; cr.		flush := self getHighestSuitStreak: sorted.	Transcript show: 'flush'; cr.	Transcript show: flush; cr.		straightFlush := self getHighestStreak: flush.	Transcript show: 'straightFlush'; cr.	Transcript show: straightFlush; cr.		(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.	"		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	(suitCards size == 4) ifTrue: [Transcript show: 3; cr. ^suitCards].	^sorted	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 16:26' prior: 33630076!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |	self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		sorted := self sort: hand.	Transcript show: 'sorted'; cr.	Transcript show: sorted; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight := self getHighestStreak: sorted.	Transcript show: 'straight'; cr.	Transcript show: straight; cr.		flush := self getHighestSuitStreak: sorted.	Transcript show: 'flush'; cr.	Transcript show: flush; cr.		straightFlush := self getHighestStreak: flush.	Transcript show: 'straightFlush'; cr.	Transcript show: straightFlush; cr.		(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	(suitCards size == 4) ifTrue: [Transcript show: 3; cr. ^suitCards].	^sorted	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 16:32' prior: 33631480!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| sorted data straight flushOrSuitStreak straightFlush maxNumOfAKind suitOfAKind suitCards |	self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		sorted := self sort: hand.	Transcript show: 'sorted'; cr.	Transcript show: sorted; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight := self getHighestStreak: sorted.	Transcript show: 'straight'; cr.	Transcript show: straight; cr.		flushOrSuitStreak := self getHighestSuitStreak: sorted.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak; cr.		(flushOrSuitStreak size > 4) ifTrue: [  		straightFlush := self getHighestStreak: flushOrSuitStreak.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush; cr.].		(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].	(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^suitCards].	^sorted			"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 16:32' prior: 33632884!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| sorted data straight flushOrSuitStreak straightFlush maxNumOfAKind suitOfAKind suitCards |	self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		sorted := self sort: hand.	Transcript show: 'sorted'; cr.	Transcript show: sorted; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight := self getHighestStreak: sorted.	Transcript show: 'straight'; cr.	Transcript show: straight; cr.		flushOrSuitStreak := self getHighestSuitStreak: sorted.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak; cr.		(flushOrSuitStreak size > 4) ifTrue: [  		straightFlush := self getHighestStreak: flushOrSuitStreak.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush; cr.].		(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].	(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].	^sorted			"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 16:42' prior: 33634406!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| sorted data straight flushOrSuitStreak straightFlush maxNumOfAKind suitOfAKind suitCards |	self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		sorted := self sort: hand.	Transcript show: 'sorted'; cr.	Transcript show: sorted; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight := self getHighestStreak: sorted.	Transcript show: 'straight'; cr.	Transcript show: straight; cr.		flushOrSuitStreak := self getHighestSuitStreak: sorted.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak; cr.		straightFlush := OrderedCollection new.	(flushOrSuitStreak size > 4) ifTrue: [  		straightFlush := self getHighestStreak: flushOrSuitStreak.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush; cr.].		(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].	(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].	^sorted			"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'as yet unclassified' stamp: 'MagdalenaDhima 1/30/2021 17:03'!getHighestValueStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| previousCard previous card current valueStreak newList dataInHand max highestValueStreak |	valueStreak := OrderedCollection new.	newList :=  OrderedCollection new.	dataInHand := Dictionary new. 	1 to: 13 do: [ :i | dataInHand at: i put: newList].	2 to: streaks size do: [ :i | 		previousCard := streaks at: (i-1).		previous := previousCard copyFrom: 1 to: (previousCard size-1).		card := streaks at: i.		current := card copyFrom: 1 to: (card size-1).		(previous == current)			ifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]			ifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. 		valueStreak := OrderedCollection new] ] ].	(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].	valueStreak := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > max) ifTrue: [max := aValue size. valueStreak := aValue ] ].	highestValueStreak := OrderedCollection new.	(valueStreak size >= 5) 	ifTrue: [		(valueStreak size -4) to: (valueStreak size) do: [:i | highestValueStreak add: (valueStreak at: 	i)]]	ifFalse: [highestValueStreak := valueStreak].	^highestValueStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 17:04' prior: 33635936!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| sorted data straight flushOrSuitStreak straightFlush straightOrValueStreak maxNumOfAKind suitOfAKind suitCards |	self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		sorted := self sort: hand.	Transcript show: 'sorted'; cr.	Transcript show: sorted; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight := self getHighestStreak: sorted.	Transcript show: 'straight'; cr.	Transcript show: straight; cr.		straightOrValueStreak := self getHighestValueStreak: sorted.	Transcript show: 'straightOrValueStreak'; cr.	Transcript show: straightOrValueStreak; cr.		flushOrSuitStreak := self getHighestSuitStreak: sorted.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak; cr.		straightFlush := OrderedCollection new.	(flushOrSuitStreak size > 4) ifTrue: [  		straightFlush := self getHighestStreak: flushOrSuitStreak.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush; cr.].		(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].	(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].	^sorted			"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 17:09' prior: 33637501!getHighestValueStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| previousCard previous card current valueStreak newList dataInHand max highestValueStreak |	valueStreak := OrderedCollection new.	newList :=  OrderedCollection new.	dataInHand := Dictionary new. 	1 to: 13 do: [ :i | dataInHand at: i put: newList].	2 to: streaks size do: [ :i | 		previousCard := streaks at: (i-1).		previous := previousCard copyFrom: 1 to: (previousCard size-1).		card := streaks at: i.		current := card copyFrom: 1 to: (card size-1).		Transcript show: card; cr.		Transcript show: previous; cr.		(previous == current)			ifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]			ifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. 		valueStreak := OrderedCollection new] ] ].	(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].	valueStreak := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > max) ifTrue: [max := aValue size. valueStreak := aValue ] ].	highestValueStreak := OrderedCollection new.	(valueStreak size >= 5) 	ifTrue: [		(valueStreak size -4) to: (valueStreak size) do: [:i | highestValueStreak add: (valueStreak at: 	i)]]	ifFalse: [highestValueStreak := valueStreak].	^highestValueStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 17:10' prior: 33640715!getHighestValueStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| previousCard previous card current valueStreak newList dataInHand max highestValueStreak |	valueStreak := OrderedCollection new.	newList :=  OrderedCollection new.	dataInHand := Dictionary new. 	1 to: 13 do: [ :i | dataInHand at: i put: newList].	2 to: streaks size do: [ :i | 		previousCard := streaks at: (i-1).		previous := previousCard copyFrom: 1 to: (previousCard size-1).		card := streaks at: i.		current := card copyFrom: 1 to: (card size-1).		Transcript show: card; cr.		Transcript show: 'd'; cr.		Transcript show: previous; cr.		(previous == current)			ifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]			ifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. 		valueStreak := OrderedCollection new] ] ].	(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].	valueStreak := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > max) ifTrue: [max := aValue size. valueStreak := aValue ] ].	highestValueStreak := OrderedCollection new.	(valueStreak size >= 5) 	ifTrue: [		(valueStreak size -4) to: (valueStreak size) do: [:i | highestValueStreak add: (valueStreak at: 	i)]]	ifFalse: [highestValueStreak := valueStreak].	^highestValueStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 17:11' prior: 33642242!getHighestValueStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| previousCard previous card current valueStreak newList dataInHand max highestValueStreak |	valueStreak := OrderedCollection new.	newList :=  OrderedCollection new.	dataInHand := Dictionary new. 	1 to: 13 do: [ :i | dataInHand at: i put: newList].	2 to: streaks size do: [ :i | 		previousCard := streaks at: (i-1).		previous := previousCard copyFrom: 1 to: (previousCard size-1).		card := streaks at: i.		current := card copyFrom: 1 to: (card size-1).		Transcript show: card; cr.		(previous == current)			ifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]			ifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. 		valueStreak := OrderedCollection new] ] ].	(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].	valueStreak := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > max) ifTrue: [max := aValue size. valueStreak := aValue ] ].	highestValueStreak := OrderedCollection new.	(valueStreak size >= 5) 	ifTrue: [		(valueStreak size -4) to: (valueStreak size) do: [:i | highestValueStreak add: (valueStreak at: 	i)]]	ifFalse: [highestValueStreak := valueStreak].	^highestValueStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 17:11' prior: 33643797!getHighestValueStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| previousCard previous card current valueStreak newList dataInHand max highestValueStreak |	valueStreak := OrderedCollection new.	newList :=  OrderedCollection new.	dataInHand := Dictionary new. 	1 to: 13 do: [ :i | dataInHand at: i put: newList].	2 to: streaks size do: [ :i | 		previousCard := streaks at: (i-1).		previous := previousCard copyFrom: 1 to: (previousCard size-1).		card := streaks at: i.		current := card copyFrom: 1 to: (card size-1).		Transcript show: current; cr.		(previous == current)			ifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]			ifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. 		valueStreak := OrderedCollection new] ] ].	(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].	valueStreak := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > max) ifTrue: [max := aValue size. valueStreak := aValue ] ].	highestValueStreak := OrderedCollection new.	(valueStreak size >= 5) 	ifTrue: [		(valueStreak size -4) to: (valueStreak size) do: [:i | highestValueStreak add: (valueStreak at: 	i)]]	ifFalse: [highestValueStreak := valueStreak].	^highestValueStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 17:12' prior: 33645291!getHighestValueStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| previousCard previous card current valueStreak newList dataInHand max highestValueStreak |	valueStreak := OrderedCollection new.	newList :=  OrderedCollection new.	dataInHand := Dictionary new. 	1 to: 13 do: [ :i | dataInHand at: i put: newList].	2 to: streaks size do: [ :i | 		previousCard := streaks at: (i-1).		previous := previousCard copyFrom: 1 to: (previousCard size-1).		card := streaks at: i.		current := card copyFrom: 1 to: (card size-1).		Transcript show: valueStreak; cr.		(previous == current)			ifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]			ifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. 		valueStreak := OrderedCollection new] ] ].	(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].	valueStreak := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > max) ifTrue: [max := aValue size. valueStreak := aValue ] ].	highestValueStreak := OrderedCollection new.	(valueStreak size >= 5) 	ifTrue: [		(valueStreak size -4) to: (valueStreak size) do: [:i | highestValueStreak add: (valueStreak at: 	i)]]	ifFalse: [highestValueStreak := valueStreak].	^highestValueStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 17:13' prior: 33646788!getHighestValueStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| previousCard previous card current valueStreak newList dataInHand max highestValueStreak |	valueStreak := OrderedCollection new.	newList :=  OrderedCollection new.	dataInHand := Dictionary new. 	1 to: 13 do: [ :i | dataInHand at: i put: newList].	2 to: streaks size do: [ :i | 		previousCard := streaks at: (i-1).		previous := previousCard copyFrom: 1 to: (previousCard size-1).		card := streaks at: i.		current := card copyFrom: 1 to: (card size-1).		(previous == current)			ifTrue: [Transcript show: 'h'; cr. (valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]			ifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. 		valueStreak := OrderedCollection new] ] ].	(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].	valueStreak := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > max) ifTrue: [max := aValue size. valueStreak := aValue ] ].	highestValueStreak := OrderedCollection new.	(valueStreak size >= 5) 	ifTrue: [		(valueStreak size -4) to: (valueStreak size) do: [:i | highestValueStreak add: (valueStreak at: 	i)]]	ifFalse: [highestValueStreak := valueStreak].	^highestValueStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 17:14' prior: 33648289!getHighestValueStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| previousCard previous card current valueStreak newList dataInHand max highestValueStreak |	valueStreak := OrderedCollection new.	newList :=  OrderedCollection new.	dataInHand := Dictionary new. 	1 to: 13 do: [ :i | dataInHand at: i put: newList].	2 to: streaks size do: [ :i | 		previousCard := streaks at: (i-1).		previous := previousCard copyFrom: 1 to: (previousCard size-1).		card := streaks at: i.		current := card copyFrom: 1 to: (card size-1).		Transcript show: previous; cr.		Transcript show: current; cr.		(previous == current)			ifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]			ifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. 		valueStreak := OrderedCollection new] ] ].	(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].	valueStreak := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > max) ifTrue: [max := aValue size. valueStreak := aValue ] ].	highestValueStreak := OrderedCollection new.	(valueStreak size >= 5) 	ifTrue: [		(valueStreak size -4) to: (valueStreak size) do: [:i | highestValueStreak add: (valueStreak at: 	i)]]	ifFalse: [highestValueStreak := valueStreak].	^highestValueStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 17:14' prior: 33649780!getHighestValueStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| previousCard previous card current valueStreak newList dataInHand max highestValueStreak |	valueStreak := OrderedCollection new.	newList :=  OrderedCollection new.	dataInHand := Dictionary new. 	1 to: 13 do: [ :i | dataInHand at: i put: newList].	2 to: streaks size do: [ :i | 		previousCard := streaks at: (i-1).		previous := previousCard copyFrom: 1 to: (previousCard size-1).		card := streaks at: i.		current := card copyFrom: 1 to: (card size-1).		Transcript show: previous class; cr.		Transcript show: current class; cr.		(previous == current)			ifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]			ifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. 		valueStreak := OrderedCollection new] ] ].	(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].	valueStreak := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > max) ifTrue: [max := aValue size. valueStreak := aValue ] ].	highestValueStreak := OrderedCollection new.	(valueStreak size >= 5) 	ifTrue: [		(valueStreak size -4) to: (valueStreak size) do: [:i | highestValueStreak add: (valueStreak at: 	i)]]	ifFalse: [highestValueStreak := valueStreak].	^highestValueStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 17:14' prior: 33651310!getHighestValueStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| previousCard previous card current valueStreak newList dataInHand max highestValueStreak |	valueStreak := OrderedCollection new.	newList :=  OrderedCollection new.	dataInHand := Dictionary new. 	1 to: 13 do: [ :i | dataInHand at: i put: newList].	2 to: streaks size do: [ :i | 		previousCard := streaks at: (i-1).		previous := previousCard copyFrom: 1 to: (previousCard size-1).		card := streaks at: i.		current := card copyFrom: 1 to: (card size-1).		(previous == current)			ifTrue: [		Transcript show: current class; cr. (valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]			ifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. 		valueStreak := OrderedCollection new] ] ].	(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].	valueStreak := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > max) ifTrue: [max := aValue size. valueStreak := aValue ] ].	highestValueStreak := OrderedCollection new.	(valueStreak size >= 5) 	ifTrue: [		(valueStreak size -4) to: (valueStreak size) do: [:i | highestValueStreak add: (valueStreak at: 	i)]]	ifFalse: [highestValueStreak := valueStreak].	^highestValueStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 17:16' prior: 33652852!getHighestValueStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| previousCard previous card current valueStreak newList dataInHand max highestValueStreak |	valueStreak := OrderedCollection new.	newList :=  OrderedCollection new.	dataInHand := Dictionary new. 	1 to: 13 do: [ :i | dataInHand at: i put: newList].	2 to: streaks size do: [ :i | 		previousCard := streaks at: (i-1).		previous := previousCard copyFrom: 1 to: (previousCard size-1).		card := streaks at: i.		current := card copyFrom: 1 to: (card size-1).		(previous asNumber == current asNumber)			ifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]			ifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. 		valueStreak := OrderedCollection new] ] ].	(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].	valueStreak := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > max) ifTrue: [max := aValue size. valueStreak := aValue ] ].	highestValueStreak := OrderedCollection new.	(valueStreak size >= 5) 	ifTrue: [		(valueStreak size -4) to: (valueStreak size) do: [:i | highestValueStreak add: (valueStreak at: 	i)]]	ifFalse: [highestValueStreak := valueStreak].	^highestValueStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 17:28' prior: 33654355!getHighestValueStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |	valueStreak := OrderedCollection new.	newList :=  OrderedCollection new.	dataInHand := Dictionary new. 	1 to: 13 do: [ :i | dataInHand at: i put: newList].	2 to: streaks size do: [ :i | 		previousCard := streaks at: (i-1).		previous := previousCard copyFrom: 1 to: (previousCard size-1).		card := streaks at: i.		current := card copyFrom: 1 to: (card size-1).		(previous asNumber == current asNumber)			ifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]			ifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. 		valueStreak := OrderedCollection new] ] ].	(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].	valueStreak := OrderedCollection new.	maxCount := 0.	maxVal := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > maxCount | (aKey > maxVal & (aValue size >= maxCount))) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue ] ].	highestValueStreak := valueStreak.	^highestValueStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 17:54' prior: 33638966!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| sorted data straight flushOrSuitStreak straightFlush valueStreak maxNumOfAKind suitOfAKind suitCards |	self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		sorted := self sort: hand.	Transcript show: 'sorted'; cr.	Transcript show: sorted; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight := self getHighestStreak: sorted.	Transcript show: 'straight'; cr.	Transcript show: straight; cr.		valueStreak := self getHighestValueStreak: sorted.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak; cr.		flushOrSuitStreak := self getHighestSuitStreak: sorted.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak; cr.		straightFlush := OrderedCollection new.	(flushOrSuitStreak size > 4) ifTrue: [  		straightFlush := self getHighestStreak: flushOrSuitStreak.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush; cr.].		(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].	(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].	^sorted			"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !----SNAPSHOT----2021-01-30T17:55:40.504794-05:00 Pharo 8.0 - 64bit (stable).image priorSource: 5048!----SNAPSHOT----2021-01-30T18:16:09.830794-05:00 Pharo 8.0 - 64bit (stable).image priorSource: 104414!!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 18:17' prior: 33594736!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak |streaks := OrderedCollection new.notFound := true.2 to: nice size do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).		(previous asNumber == (current asNumber -1) & notFound)		ifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]		ifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]]].Transcript show: 'h', highestStreak; cr.highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 18:19' prior: 33659141!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak |streaks := OrderedCollection new.notFound := true.2 to: nice size do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).		(previous asNumber == (current asNumber -1) & notFound)		ifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]		ifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]]].Transcript show: highestStreak; cr.highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 18:21' prior: 33660145!getHighestStreak: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak |streaks := OrderedCollection new.notFound := true.2 to: shuf size do: [ :i | 	previousCard := shuf at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := shuf at: i.	current := card copyFrom: 1 to: (card size-1).		(previous asNumber == (current asNumber -1) & notFound)		ifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]		ifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]]].Transcript show: streaks; cr.highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 18:22' prior: 33661144!getHighestStreak: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak |streaks := OrderedCollection new.notFound := true.2 to: shuf size do: [ :i | 	previousCard := shuf at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := shuf at: i.	current := card copyFrom: 1 to: (card size-1).		(previous asNumber == (current asNumber -1) & notFound)		ifTrue: [(streaks isEmpty) ifTrue: [Transcript show: current; cr. streaks add: previousCard]. streaks add: card]		ifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]]].Transcript show: streaks; cr.highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 18:29' prior: 33662137!getHighestStreak: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak |streaks := OrderedCollection new.notFound := true.2 to: shuf size do: [ :i | 	previousCard := shuf at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := shuf at: i.	current := card copyFrom: 1 to: (card size-1).	(previous ~= current) ifTrue: [  	(previous asNumber == (current asNumber -1) & notFound)		ifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]		ifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]]] ].Transcript show: streaks; cr.highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 18:33' prior: 33657226!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| sorted data straight flushOrSuitStreak straightFlush valueStreak maxNumOfAKind suitOfAKind suitCards |	self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		sorted := self sort: hand.	Transcript show: 'sorted'; cr.	Transcript show: sorted; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight := self getHighestStreak: sorted.	Transcript show: 'straight'; cr.	Transcript show: straight; cr.		valueStreak := self getHighestValueStreak: sorted.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak; cr.		flushOrSuitStreak := self getHighestSuitStreak: sorted.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak; cr.		straightFlush := OrderedCollection new.	(flushOrSuitStreak size > 4) ifTrue: [  		straightFlush := self getHighestStreak: flushOrSuitStreak.		Transcript show: flushOrSuitStreak; cr.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush; cr.].		(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].	(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].	^sorted			"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 18:34' prior: 33664188!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| sorted data straight flushOrSuitStreak straightFlush valueStreak maxNumOfAKind suitOfAKind suitCards |	self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		sorted := self sort: hand.	Transcript show: 'sorted'; cr.	Transcript show: sorted; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight := self getHighestStreak: sorted.	Transcript show: 'straight'; cr.	Transcript show: straight; cr.		valueStreak := self getHighestValueStreak: sorted.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak; cr.		flushOrSuitStreak := self getHighestSuitStreak: sorted.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak; cr.		straightFlush := OrderedCollection new.	(flushOrSuitStreak size > 4) ifTrue: [  		straightFlush := self getHighestStreak: flushOrSuitStreak.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush; cr.].		(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].	(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].	^sorted			"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 18:36' prior: 33663160!getHighestStreak: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak |streaks := OrderedCollection new.notFound := true.2 to: shuf size do: [ :i | 	previousCard := shuf at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := shuf at: i.	current := card copyFrom: 1 to: (card size-1).	(previous ~= current) ifTrue: [  	(previous asNumber == (current asNumber -1) & notFound)		ifTrue: [(streaks isEmpty) ifTrue: [Transcript show: previousCard; cr. streaks add: previousCard]. streaks add: card]		ifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]]] ].Transcript show: streaks; cr.highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 18:37' prior: 33667648!getHighestStreak: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak |streaks := OrderedCollection new.notFound := true.2 to: shuf size do: [ :i | 	previousCard := shuf at: (i-1).	Transcript show: previousCard; cr.	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := shuf at: i.	current := card copyFrom: 1 to: (card size-1).	(previous ~= current) ifTrue: [  	(previous asNumber == (current asNumber -1) & notFound)		ifTrue: [(streaks isEmpty) ifTrue: [Transcript show: previousCard; cr. streaks add: previousCard]. streaks add: card]		ifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]]] ].Transcript show: streaks; cr.highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 18:41' prior: 33655838!getHighestValueStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |	valueStreak := OrderedCollection new.	newList :=  OrderedCollection new.		TTranscript show: streaks.	dataInHand := Dictionary new. 	1 to: 13 do: [ :i | dataInHand at: i put: newList].	2 to: streaks size do: [ :i | 		previousCard := streaks at: (i-1).		previous := previousCard copyFrom: 1 to: (previousCard size-1).		card := streaks at: i.		current := card copyFrom: 1 to: (card size-1).		(previous asNumber == current asNumber)			ifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]			ifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. 		valueStreak := OrderedCollection new] ] ].	(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].	valueStreak := OrderedCollection new.	maxCount := 0.	maxVal := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > maxCount | (aKey > maxVal & (aValue size >= maxCount))) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue ] ].	highestValueStreak := valueStreak.	^highestValueStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 18:41' prior: 33669810!getHighestValueStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |	valueStreak := OrderedCollection new.	newList :=  OrderedCollection new.		Transcript show: streaks.	dataInHand := Dictionary new. 	1 to: 13 do: [ :i | dataInHand at: i put: newList].	2 to: streaks size do: [ :i | 		previousCard := streaks at: (i-1).		previous := previousCard copyFrom: 1 to: (previousCard size-1).		card := streaks at: i.		current := card copyFrom: 1 to: (card size-1).		(previous asNumber == current asNumber)			ifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]			ifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. 		valueStreak := OrderedCollection new] ] ].	(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].	valueStreak := OrderedCollection new.	maxCount := 0.	maxVal := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > maxCount | (aKey > maxVal & (aValue size >= maxCount))) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue ] ].	highestValueStreak := valueStreak.	^highestValueStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 18:42' prior: 33671228!getHighestValueStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |	valueStreak := OrderedCollection new.	newList :=  OrderedCollection new.	dataInHand := Dictionary new. 	1 to: 13 do: [ :i | dataInHand at: i put: newList].	2 to: streaks size do: [ :i | 		previousCard := streaks at: (i-1).		previous := previousCard copyFrom: 1 to: (previousCard size-1).		card := streaks at: i.		current := card copyFrom: 1 to: (card size-1).		(previous asNumber == current asNumber)			ifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]			ifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. 		valueStreak := OrderedCollection new] ] ].	(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].	valueStreak := OrderedCollection new.	maxCount := 0.	maxVal := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > maxCount | (aKey > maxVal & (aValue size >= maxCount))) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue ] ].	highestValueStreak := valueStreak.	^highestValueStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 18:42' prior: 33628608!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |suitStreak := OrderedCollection new.newList :=  OrderedCollection new.Transcript show: streaks.dataInHand := Dictionary new.dataInHand at: 'C' put: newList. dataInHand at: 'D' put: newList. dataInHand at: 'H' put: newList. dataInHand at: 'S' put: newList.2 to: streaks size do: [ :i | 	previousCard := streaks at: (i-1).	previous := previousCard at: previousCard size.	card := streaks at: i.	current := card at: card size.	(previous == current)		ifTrue: [(suitStreak isEmpty) ifTrue:[suitStreak add: previousCard]. suitStreak add: card]		ifFalse: [(suitStreak size ~= 0) ifTrue: [dataInHand at: previous put: suitStreak. suitStreak := 			OrderedCollection new] ] ].	(suitStreak size ~= 0) ifTrue: [dataInHand at: previous put: suitStreak].	suitStreak := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 18:53' prior: 33674033!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |suitStreak := OrderedCollection new.newList :=  OrderedCollection new.dataInHand := Dictionary new.dataInHand at: 'C' put: newList. dataInHand at: 'D' put: newList. dataInHand at: 'H' put: newList. dataInHand at: 'S' put: newList.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	dataInHand at: current put: ( (dataInHand at: current) add: card ).	].	suitStreak := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 18:54' prior: 33675528!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |suitStreak := OrderedCollection new.newList :=  OrderedCollection new.dataInHand := Dictionary new.dataInHand at: 'C' put: newList. dataInHand at: 'D' put: newList. dataInHand at: 'H' put: newList. dataInHand at: 'S' put: newList.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	dataInHand at: current put: ( (dataInHand at: current) add: card ).	].	Transcript show: dataInHand.	suitStreak := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 18:55' prior: 33676663!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |suitStreak := OrderedCollection new.newList :=  OrderedCollection new.dataInHand := Dictionary new.dataInHand at: 'C' put: newList copy. dataInHand at: 'D' put: newList copy. dataInHand at: 'H' put: newList copy. dataInHand at: 'S' put: newList copy. 1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	dataInHand at: current put: ( (dataInHand at: current) add: card ).	].	Transcript show: dataInHand.	suitStreak := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 18:55' prior: 33677828!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |suitStreak := OrderedCollection new.newList :=  OrderedCollection new.dataInHand := Dictionary new.dataInHand at: 'C' put: newList copy. dataInHand at: 'D' put: newList copy. dataInHand at: 'H' put: newList copy. dataInHand at: 'S' put: newList copy. 1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	Transcript show: dataInHand.	dataInHand at: current put: ( (dataInHand at: current) add: card ).	].	Transcript show: dataInHand.	suitStreak := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 18:56' prior: 33679014!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |suitStreak := OrderedCollection new.newList :=  OrderedCollection new.dataInHand := Dictionary new.dataInHand at: 'C' put: newList copy. dataInHand at: 'D' put: newList copy. dataInHand at: 'H' put: newList copy. dataInHand at: 'S' put: newList copy. 1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	Transcript show: dataInHand.	dataInHand at: current asSymbol put: ( (dataInHand at: current) add: card ).	].	Transcript show: dataInHand.	suitStreak := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 18:57' prior: 33680230!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |suitStreak := OrderedCollection new.newList :=  OrderedCollection new.dataInHand := Dictionary new.dataInHand at: 'C' put: newList copy. dataInHand at: 'D' put: newList copy. dataInHand at: 'H' put: newList copy. dataInHand at: 'S' put: newList copy. 1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	Transcript show: dataInHand.	dataInHand at: current asString put: ( (dataInHand at: current) add: card ).	].	Transcript show: dataInHand.	suitStreak := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 18:58' prior: 33681455!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |suitStreak := OrderedCollection new.newList :=  OrderedCollection new.dataInHand := Dictionary new.dataInHand at: 'C' put: newList copy. dataInHand at: 'D' put: newList copy. dataInHand at: 'H' put: newList copy. dataInHand at: 'S' put: newList copy. 1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	Transcript show: (dataInHand at: current asSymbol).	dataInHand at: current asSymbol put: ( (dataInHand at: current) add: card ).	].	Transcript show: dataInHand.	suitStreak := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 18:58' prior: 33682680!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |suitStreak := OrderedCollection new.newList :=  OrderedCollection new.dataInHand := Dictionary new.dataInHand at: 'C' put: newList copy. dataInHand at: 'D' put: newList copy. dataInHand at: 'H' put: newList copy. dataInHand at: 'S' put: newList copy. 1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	Transcript show: (dataInHand at: current asSymbol).	dataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) add: card ).	].	Transcript show: dataInHand.	suitStreak := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 18:59' prior: 33683928!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |suitStreak := OrderedCollection new.newList :=  OrderedCollection new.dataInHand := Dictionary new.dataInHand at: 'C' put: newList. dataInHand at: 'D' put: newList. dataInHand at: 'H' put: newList. dataInHand at: 'S' put: newList. 1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	Transcript show: (dataInHand at: current asSymbol).	dataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) add: card ).	].	Transcript show: dataInHand.	suitStreak := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 19:00' prior: 33685185!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |suitStreak := OrderedCollection new.newList :=  OrderedCollection new.dataInHand := Dictionary new.dataInHand at: 'C' put: newList. dataInHand at: 'D' put: newList. dataInHand at: 'H' put: newList. dataInHand at: 'S' put: newList. 1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	Transcript show: (dataInHand at: current asSymbol).	dataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) add: card ).	Transcript show: (dataInHand at: current asSymbol) class.	].	Transcript show: dataInHand.	suitStreak := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 19:01' prior: 33686422!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |suitStreak := OrderedCollection new.newList :=  OrderedCollection new.dataInHand := Dictionary new.dataInHand at: 'C' put: OrderedCollection new. dataInHand at: 'D' put: OrderedCollection new. dataInHand at: 'H' put: OrderedCollection new. dataInHand at: 'S' put: OrderedCollection new. 1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	Transcript show: (dataInHand at: current asSymbol).	dataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) add: card ).	Transcript show: (dataInHand at: current asSymbol) class.	].	Transcript show: dataInHand.	suitStreak := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 19:01' prior: 33687718!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |suitStreak := OrderedCollection new.newList :=  OrderedCollection new.dataInHand := Dictionary new.dataInHand at: 'C' put: OrderedCollection new. dataInHand at: 'D' put: OrderedCollection new. dataInHand at: 'H' put: OrderedCollection new. dataInHand at: 'S' put: OrderedCollection new. 1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	Transcript show: (dataInHand at: current asSymbol).	dataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol), card ).	Transcript show: (dataInHand at: current asSymbol) class.	].	Transcript show: dataInHand.	suitStreak := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 19:02' prior: 33689070!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |suitStreak := OrderedCollection new.newList :=  OrderedCollection new.dataInHand := Dictionary new.dataInHand at: 'C' put: OrderedCollection new. dataInHand at: 'D' put: OrderedCollection new. dataInHand at: 'H' put: OrderedCollection new. dataInHand at: 'S' put: OrderedCollection new. 1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	Transcript show: (dataInHand at: current asSymbol); cr.	dataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol), card ).	Transcript show: (dataInHand at: current asSymbol); cr.	].	Transcript show: dataInHand; cr.	suitStreak := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 19:04' prior: 33690418!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |suitStreak := OrderedCollection new.newList :=  OrderedCollection new.dataInHand := Dictionary new.dataInHand at: 'C' put: OrderedCollection new. dataInHand at: 'D' put: OrderedCollection new. dataInHand at: 'H' put: OrderedCollection new. dataInHand at: 'S' put: OrderedCollection new. 1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	Transcript show: (dataInHand at: current asSymbol); cr.	dataInHand at: current asSymbol put: ( card ).	Transcript show: (dataInHand at: current asSymbol); cr.	].	Transcript show: dataInHand; cr.	suitStreak := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 19:05' prior: 33691772!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |suitStreak := OrderedCollection new.newList :=  OrderedCollection new.dataInHand := Dictionary new.dataInHand at: 'C' put: Array new. dataInHand at: 'D' put: Array new. dataInHand at: 'H' put: Array new. dataInHand at: 'S' put: Array new. 1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	Transcript show: (dataInHand at: current asSymbol); cr.	dataInHand at: current asSymbol put: ( card ).	Transcript show: (dataInHand at: current asSymbol); cr.	].	Transcript show: dataInHand; cr.	suitStreak := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 19:07' prior: 33693091!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |suitStreak := OrderedCollection new.newList :=  OrderedCollection new.dataInHand := Dictionary new.dataInHand at: 'C' put: newList. dataInHand at: 'D' put: newList. dataInHand at: 'H' put: newList. dataInHand at: 'S' put: newList.2 to: streaks size do: [ :i | 	previousCard := streaks at: (i-1).	previous := previousCard at: previousCard size.	card := streaks at: i.	current := card at: card size.	(previous == current)		ifTrue: [(suitStreak isEmpty) ifTrue:[suitStreak add: previousCard]. suitStreak add: card]		ifFalse: [(suitStreak size ~= 0) ifTrue: [dataInHand at: previous put: suitStreak. suitStreak := 			OrderedCollection new] ] ].	(suitStreak size ~= 0) ifTrue: [dataInHand at: previous put: suitStreak].	suitStreak := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 19:10' prior: 33694362!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |suitStreak := OrderedCollection new.newList :=  OrderedCollection new.dataInHand := Dictionary new.dataInHand at: 'C' put: newList. dataInHand at: 'D' put: newList. dataInHand at: 'H' put: newList. dataInHand at: 'S' put: newList.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	dataInHand at: current put: ((dataInHand at: current) add: card)].	suitStreak := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 19:11' prior: 33695830!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |suitStreak := OrderedCollection new.newList :=  OrderedCollection new.dataInHand := Dictionary new.dataInHand at: 'C' put: newList. dataInHand at: 'D' put: newList. dataInHand at: 'H' put: newList. dataInHand at: 'S' put: newList.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	Transcript show: (dataInHand at: current); cr.	dataInHand at: current put: ((dataInHand at: current) add: card)].	suitStreak := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 19:13' prior: 33696960!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |suitStreak := OrderedCollection new.newList :=  OrderedCollection new.dataInHand := Dictionary new.dataInHand at: 'C' put: ''. dataInHand at: 'D' put: ''. dataInHand at: 'H' put: ''. dataInHand at: 'S' put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	Transcript show: (dataInHand at: current); cr.	dataInHand at: current put: ((dataInHand at: current) , card).	Transcript show: (dataInHand at: current); cr.].	suitStreak := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 19:14' prior: 33698138!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |suitStreak := OrderedCollection new.newList :=  OrderedCollection new.dataInHand := Dictionary new.dataInHand at: $C put: ''. dataInHand at: $D put: ''. dataInHand at: $H put: ''. dataInHand at: $S put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	Transcript show: (dataInHand at: current); cr.	dataInHand at: current put: ((dataInHand at: current) , card).	Transcript show: (dataInHand at: current); cr.].	suitStreak := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 19:15' prior: 33699342!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |suitStreak := OrderedCollection new.newList :=  OrderedCollection new.dataInHand := Dictionary new.dataInHand at: $C put: OrderedCollection new. dataInHand at: $D put: OrderedCollection new. dataInHand at: $H put: OrderedCollection new. dataInHand at: $S put: OrderedCollection new.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	Transcript show: (dataInHand at: current); cr.	dataInHand at: current put: ((dataInHand at: current) add: card).	Transcript show: (dataInHand at: current); cr.].	suitStreak := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 19:16' prior: 33700542!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |suitStreak := OrderedCollection new.newList :=  OrderedCollection new.dataInHand := Dictionary new.dataInHand at: $C put: ''. dataInHand at: $D put: ''. dataInHand at: $H put: ''. dataInHand at: $S put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	Transcript show: (dataInHand at: current); cr.	dataInHand at: current put: ((dataInHand at: current) , card).	Transcript show: (dataInHand at: current); cr.].	suitStreak := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 19:19' prior: 33701821!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |suitStreak := OrderedCollection new.newList :=  OrderedCollection new.dataInHand := Dictionary new.dataInHand at: $C put: ''. dataInHand at: $D put: ''. dataInHand at: $H put: ''. dataInHand at: $S put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	Transcript show: (dataInHand at: current); cr.	dataInHand at: current put: ((dataInHand at: current) , ' ' , card).	Transcript show: (dataInHand at: current); cr.].	suitStreak := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 19:45' prior: 33703021!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |suitStreak := OrderedCollection new.dataInHand := Dictionary new.dataInHand at: $C put: ''. dataInHand at: $D put: ''. dataInHand at: $H put: ''. dataInHand at: $S put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	Transcript show: (dataInHand at: current); cr.	dataInHand at: current put: ((dataInHand at: current) , ' ' , card).	Transcript show: (dataInHand at: current); cr.].	suitStreak := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		count := 0. word := ''.		aValue do: [:a | (a ~= ' ' & count ~= 0) ifTrue: [count := count + 1. word at: count put: a							ifFalse: [ count := count + 1. suitStreak add: word. word := '' ] ] ]. 		(count size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 19:45' prior: 33704227!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |suitStreak := OrderedCollection new.dataInHand := Dictionary new.dataInHand at: $C put: ''. dataInHand at: $D put: ''. dataInHand at: $H put: ''. dataInHand at: $S put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	Transcript show: (dataInHand at: current); cr.	dataInHand at: current put: ((dataInHand at: current) , ' ' , card).	Transcript show: (dataInHand at: current); cr.].		Transcript show: (dataInHand); cr.		suitStreak := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		count := 0. word := ''.		aValue do: [:a | (a ~= ' ' & count ~= 0) ifTrue: [count := count + 1. word at: count put: a							ifFalse: [ count := count + 1. suitStreak add: word. word := '' ] ] ]. 		(count size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 19:50' prior: 33705599!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |suitStreak := OrderedCollection new.dataInHand := Dictionary new.dataInHand at: $C put: ''. dataInHand at: $D put: ''. dataInHand at: $H put: ''. dataInHand at: $S put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	Transcript show: (dataInHand at: current); cr.	dataInHand at: current put: ((dataInHand at: current) , ' ' , card).	Transcript show: (dataInHand at: current); cr.].		Transcript show: (dataInHand); cr.		suitStreak := OrderedCollection new.	temp := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		count := 0. word := ''.		aValue do: [:a | (a ~= ' ' & (count ~= 0) ) ifTrue: [count := count + 1. word at: count put: a]							ifFalse: [ count := count + 1. temp add: word. word := '' ] ]. 		(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].		Transcript show: (suitStreak); cr.	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 19:51' prior: 33707010!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |suitStreak := OrderedCollection new.dataInHand := Dictionary new.dataInHand at: $C put: ''. dataInHand at: $D put: ''. dataInHand at: $H put: ''. dataInHand at: $S put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	Transcript show: (dataInHand at: current); cr.	dataInHand at: current put: ((dataInHand at: current) , ' ' , card).	Transcript show: (dataInHand at: current); cr.].		Transcript show: (dataInHand); cr.		suitStreak := OrderedCollection new.	temp := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		count := 0. word := ''.		aValue do: [:a | Transcript show: a. (a ~= ' ' & (count ~= 0) ) ifTrue: [count := count + 1. word at: count put: a]							ifFalse: [ count := count + 1. temp add: word. word := '' ] ]. 		(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].		Transcript show: (suitStreak); cr.	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 19:52' prior: 33708487!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |suitStreak := OrderedCollection new.dataInHand := Dictionary new.dataInHand at: $C put: ''. dataInHand at: $D put: ''. dataInHand at: $H put: ''. dataInHand at: $S put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	Transcript show: (dataInHand at: current); cr.	dataInHand at: current put: ((dataInHand at: current) , ' ' , card).	Transcript show: (dataInHand at: current); cr.].		Transcript show: (dataInHand); cr.		suitStreak := OrderedCollection new.	temp := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		count := 0. word := ''.		aValue do: [:a | (a ~= ' ' & (count ~= 0) ) ifTrue: [count := count + 1. word at: count put: a]							ifFalse: [ count := count + 1. temp add: word. word := '' ] ]. 		(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].		Transcript show: (suitStreak); cr.	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 19:52' prior: 33709984!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |suitStreak := OrderedCollection new.dataInHand := Dictionary new.dataInHand at: $C put: ''. dataInHand at: $D put: ''. dataInHand at: $H put: ''. dataInHand at: $S put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	Transcript show: (dataInHand at: current); cr.	dataInHand at: current put: ((dataInHand at: current) , ' ' , card).	Transcript show: (dataInHand at: current); cr.].		Transcript show: (dataInHand); cr.		suitStreak := OrderedCollection new.	temp := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		count := 0. word := ''.		aValue do: [:a | Transcript show: (temp); cr. (a ~= ' ' & (count ~= 0) ) ifTrue: [count := count + 1. word at: count put: a]							ifFalse: [ count := count + 1. temp add: word. word := '' ] ]. 		(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].		Transcript show: (suitStreak); cr.	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 19:53' prior: 33711461!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |suitStreak := OrderedCollection new.dataInHand := Dictionary new.dataInHand at: $C put: ''. dataInHand at: $D put: ''. dataInHand at: $H put: ''. dataInHand at: $S put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	Transcript show: (dataInHand at: current); cr.	dataInHand at: current put: ((dataInHand at: current) , ' ' , card).	Transcript show: (dataInHand at: current); cr.].		Transcript show: (dataInHand); cr.		suitStreak := OrderedCollection new.	temp := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		count := 0. word := ''.		aValue do: [:a | Transcript show: (a); cr. (a ~= ' ' & (count ~= 0) ) ifTrue: [count := count + 1. word at: count put: a]							ifFalse: [ count := count + 1. temp add: word. word := '' ] ]. 		(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].		Transcript show: (suitStreak); cr.	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 19:55' prior: 33712967!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |suitStreak := OrderedCollection new.dataInHand := Dictionary new.dataInHand at: $C put: ''. dataInHand at: $D put: ''. dataInHand at: $H put: ''. dataInHand at: $S put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	Transcript show: (dataInHand at: current); cr.	dataInHand at: current put: ((dataInHand at: current) , ' ' , card).	Transcript show: (dataInHand at: current); cr.].		Transcript show: (dataInHand); cr.		suitStreak := OrderedCollection new.	temp := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		count := 0. word := ''.		aValue do: [:a | (a ~= ' ' & (count ~= 0) ) ifTrue: [count := count + 1. word at: count put: a]							ifFalse: [ count := count + 1. (count ~= 0) ifTrue: [temp add: word. word := '' ]] ]. 		(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].		Transcript show: (suitStreak); cr.	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 19:56' prior: 33714470!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |suitStreak := OrderedCollection new.dataInHand := Dictionary new.dataInHand at: $C put: ''. dataInHand at: $D put: ''. dataInHand at: $H put: ''. dataInHand at: $S put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	Transcript show: (dataInHand at: current); cr.	dataInHand at: current put: ((dataInHand at: current) , ' ' , card).	Transcript show: (dataInHand at: current); cr.].		Transcript show: (dataInHand); cr.		suitStreak := OrderedCollection new.	temp := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		count := 0. word := ''.		aValue do: [:a | Transcript show: (a); cr. (a ~= ' ' & (count ~= 0) ) ifTrue: [count := count + 1. word at: count put: a]							ifFalse: [ count := count + 1. (count ~= 0) ifTrue: [temp add: word. word := '' ]] ]. 		(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].		Transcript show: (suitStreak); cr.	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 19:56' prior: 33715970!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |suitStreak := OrderedCollection new.dataInHand := Dictionary new.dataInHand at: $C put: ''. dataInHand at: $D put: ''. dataInHand at: $H put: ''. dataInHand at: $S put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	Transcript show: (dataInHand at: current); cr.	dataInHand at: current put: ((dataInHand at: current) , ' ' , card).	Transcript show: (dataInHand at: current); cr.].		Transcript show: (dataInHand); cr.		suitStreak := OrderedCollection new.	temp := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		count := 0. word := ''.		aValue do: [:a | Transcript show: (a); cr. (a ~= ' ' & (count ~= 0) ) ifTrue: [count := count + 1. word at: count put: a]							ifFalse: [ count := count + 1. (count ~= 1) ifTrue: [temp add: word. word := '' ]] ]. 		(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].		Transcript show: (suitStreak); cr.	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 19:57' prior: 33717496!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |suitStreak := OrderedCollection new.dataInHand := Dictionary new.dataInHand at: $C put: ''. dataInHand at: $D put: ''. dataInHand at: $H put: ''. dataInHand at: $S put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	Transcript show: (dataInHand at: current); cr.	dataInHand at: current put: ((dataInHand at: current) , ' ' , card).	Transcript show: (dataInHand at: current); cr.].		Transcript show: (dataInHand); cr.		suitStreak := OrderedCollection new.	temp := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		count := 0. word := ''.		aValue do: [:a | Transcript show: (a); cr. (a ~= ' ' & (count ~= 0) ) ifTrue: [count := count + 1. word at: count put: a]							ifFalse: [ (count ~= 0) ifTrue: [temp add: word. word := '' ]. count := count + 1. ] ]. 		(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].		Transcript show: (suitStreak); cr.	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 20:00' prior: 33719022!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |suitStreak := OrderedCollection new.dataInHand := Dictionary new.dataInHand at: $C put: ''. dataInHand at: $D put: ''. dataInHand at: $H put: ''. dataInHand at: $S put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	Transcript show: (dataInHand at: current); cr.	dataInHand at: current put: ((dataInHand at: current) , ' ' , card).	Transcript show: (dataInHand at: current); cr.].		Transcript show: (dataInHand); cr.		suitStreak := OrderedCollection new.	temp := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		count := 0. word := ''.		aValue do: [:a | Transcript show: (a); cr. (a ~= ' ' & (count ~= 0) ) 			ifTrue: [count := count + 1. word at: count put: a]			ifFalse: [ (count ~= 0) ifTrue: [temp add: word. word := '' ] ]  ]. 		(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].		Transcript show: (suitStreak); cr.	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 20:00' prior: 33720550!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |suitStreak := OrderedCollection new.dataInHand := Dictionary new.dataInHand at: $C put: ''. dataInHand at: $D put: ''. dataInHand at: $H put: ''. dataInHand at: $S put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	Transcript show: (dataInHand at: current); cr.	dataInHand at: current put: ((dataInHand at: current) , ' ' , card).	Transcript show: (dataInHand at: current); cr.].		Transcript show: (dataInHand); cr.		suitStreak := OrderedCollection new.	temp := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		count := 0. word := ''.		aValue do: [:a | Transcript show: (a); cr. (a ~= ' ' & (count ~= 0) ) 			ifTrue: [count := count + 1. word at: count put: a]			ifFalse: [ (count ~= 0) ifTrue: [temp add: word. word := '' ] ]  ]. 		Transcript show: (temp); cr.		(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].		Transcript show: (suitStreak); cr.	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 20:03' prior: 33722058!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| spaces temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |suitStreak := OrderedCollection new.dataInHand := Dictionary new.dataInHand at: $C put: ''. dataInHand at: $D put: ''. dataInHand at: $H put: ''. dataInHand at: $S put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	Transcript show: (dataInHand at: current); cr.	dataInHand at: current put: ((dataInHand at: current) , ' ' , card).	Transcript show: (dataInHand at: current); cr.].		Transcript show: (dataInHand); cr.		suitStreak := OrderedCollection new.	temp := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		count := 0. spaces := 0. word := ''.		aValue do: [:a | Transcript show: (a); cr. (a ~= ' ' & (count ~= 0) ) 			ifTrue: [count := count + 1. word at: count put: a]			ifFalse: [ (count ~= 0) ifTrue: [temp add: word. word := '' ] ]  ]. 		Transcript show: (temp); cr.		(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].		Transcript show: (suitStreak); cr.	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 20:04' prior: 33723597!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| spaces temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |suitStreak := OrderedCollection new.dataInHand := Dictionary new.dataInHand at: $C put: ''. dataInHand at: $D put: ''. dataInHand at: $H put: ''. dataInHand at: $S put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	Transcript show: (dataInHand at: current); cr.	dataInHand at: current put: ((dataInHand at: current) , ' ' , card).	Transcript show: (dataInHand at: current); cr.].		Transcript show: (dataInHand); cr.		suitStreak := OrderedCollection new.	temp := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		count := 0. spaces := 0. word := ''.		aValue do: [:a | Transcript show: (a); cr. (a ~= ' ' & (count ~= 0) ) 			ifTrue: [count := count + 1. word at: count put: a]			ifFalse: [ (count ~= 0) ifTrue: [temp add: word. word := '' ]. count := count + 1. spaces := spaces + 1. ]  ]. 		Transcript show: (temp); cr.		(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].		Transcript show: (suitStreak); cr.	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 20:09' prior: 33725156!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| spaces temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |suitStreak := OrderedCollection new.dataInHand := Dictionary new.dataInHand at: $C put: ''. dataInHand at: $D put: ''. dataInHand at: $H put: ''. dataInHand at: $S put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	Transcript show: (dataInHand at: current); cr.	dataInHand at: current put: ((dataInHand at: current) , ' ' , card).	Transcript show: (dataInHand at: current); cr.].		Transcript show: (dataInHand); cr.		suitStreak := OrderedCollection new.	temp := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		count := 1. spaces := 0. word := ''.		aValue do: [:a | Transcript show: (a); cr. (a ~= ' ' & (count ~= 1) ) 			ifTrue: [word at: (count - spaces) put: a]			ifFalse: [ (count ~= 1) ifTrue: [temp add: word. word := '' ]. count := count + 1. spaces := spaces + 1. ]  ]. 		Transcript show: (temp); cr.		(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].		Transcript show: (suitStreak); cr.	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 20:09' prior: 33726758!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| spaces temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |suitStreak := OrderedCollection new.dataInHand := Dictionary new.dataInHand at: $C put: ''. dataInHand at: $D put: ''. dataInHand at: $H put: ''. dataInHand at: $S put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	Transcript show: (dataInHand at: current); cr.	dataInHand at: current put: ((dataInHand at: current) , ' ' , card).	Transcript show: (dataInHand at: current); cr.].		Transcript show: (dataInHand); cr.		suitStreak := OrderedCollection new.	temp := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		count := 1. spaces := 0. word := ''.		aValue do: [:a | Transcript show: (a); cr. (a ~= ' ' & (count ~= 1) ) 			ifTrue: [word at: (count - spaces) put: a]			ifFalse: [ (count ~= 1) ifTrue: [temp add: word. word := '' ]. count := count + 1. spaces := spaces + 1. Transcript show: ((count - spaces)); cr.]  ]. 		Transcript show: (temp); cr.		(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].		Transcript show: (suitStreak); cr.	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 20:11' prior: 33728351!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| spaces temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |suitStreak := OrderedCollection new.dataInHand := Dictionary new.dataInHand at: $C put: ''. dataInHand at: $D put: ''. dataInHand at: $H put: ''. dataInHand at: $S put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	Transcript show: (dataInHand at: current); cr.	dataInHand at: current put: ((dataInHand at: current) , ' ' , card).	Transcript show: (dataInHand at: current); cr.].		Transcript show: (dataInHand); cr.		suitStreak := OrderedCollection new.	temp := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		count := 1. spaces := 0. word := ''.		aValue do: [:a | Transcript show: 'h'. Transcript show: (a); cr. (a ~= ' ' & (count ~= 1) ) 			ifTrue: [word at: (count - spaces) put: a]			ifFalse: [ (count ~= 1) ifTrue: [temp add: word. word := '' ]. count := count + 1. spaces := spaces + 1. Transcript show: ((count - spaces)); cr.]  ]. 		Transcript show: (temp); cr.		(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].		Transcript show: (suitStreak); cr.	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 20:12' prior: 33729984!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| spaces temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |suitStreak := OrderedCollection new.dataInHand := Dictionary new.dataInHand at: $C put: ''. dataInHand at: $D put: ''. dataInHand at: $H put: ''. dataInHand at: $S put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	Transcript show: (dataInHand at: current); cr.	dataInHand at: current put: ((dataInHand at: current) , ' ' , card).	Transcript show: (dataInHand at: current); cr.].		Transcript show: (dataInHand); cr.		suitStreak := OrderedCollection new.	temp := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		count := 1. spaces := 0. word := ''.		aValue do: [:a | Transcript show: 'h'. Transcript show: (a); cr. (a ~= ' ' & (count ~= 1) ) 			ifTrue: [word at: (count - spaces) put: a. count := count + 1.]			ifFalse: [ (count ~= 1) ifTrue: [temp add: word. word := '' ]. count := count + 1. spaces := spaces + 1. Transcript show: ((count - spaces)); cr.]  ]. 		Transcript show: (temp); cr.		(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].		Transcript show: (suitStreak); cr.	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 20:12' prior: 33731639!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| spaces temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |suitStreak := OrderedCollection new.dataInHand := Dictionary new.dataInHand at: $C put: ''. dataInHand at: $D put: ''. dataInHand at: $H put: ''. dataInHand at: $S put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	Transcript show: (dataInHand at: current); cr.	dataInHand at: current put: ((dataInHand at: current) , ' ' , card).	Transcript show: (dataInHand at: current); cr.].		Transcript show: (dataInHand); cr.		suitStreak := OrderedCollection new.	temp := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		count := 1. spaces := 0. word := ''.		aValue do: [:a | Transcript show: 'h'. Transcript show: (a); cr. (a ~= ' ' & (count ~= 1) ) 			ifTrue: [word at: (count - spaces) put: a. count := count + 1. Transcript show: word.]			ifFalse: [ (count ~= 1) ifTrue: [temp add: word. word := '' ]. count := count + 1. spaces := spaces + 1. Transcript show: ((count - spaces)); cr.]  ]. 		Transcript show: (temp); cr.		(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].		Transcript show: (suitStreak); cr.	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 20:14' prior: 33733315!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| spaces temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |suitStreak := OrderedCollection new.dataInHand := Dictionary new.dataInHand at: $C put: ''. dataInHand at: $D put: ''. dataInHand at: $H put: ''. dataInHand at: $S put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	Transcript show: (dataInHand at: current); cr.	dataInHand at: current put: ((dataInHand at: current) , ' ' , card).	Transcript show: (dataInHand at: current); cr.].		Transcript show: (dataInHand); cr.		suitStreak := OrderedCollection new.	temp := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		count := 1. spaces := 0. word := ''.		aValue do: [:a | Transcript show: 'h'. Transcript show: (a); cr. (a ~= ' ' & (count ~= 1) ) 			ifTrue: [word at: (count - spaces) put: a asString. count := count + 1. Transcript show: word.]			ifFalse: [ (count ~= 1) ifTrue: [temp add: word. word := '' ]. count := count + 1. spaces := spaces + 1. Transcript show: ((count - spaces)); cr.]  ]. 		Transcript show: (temp); cr.		(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].		Transcript show: (suitStreak); cr.	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 20:14' prior: 33735014!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| spaces temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |suitStreak := OrderedCollection new.dataInHand := Dictionary new.dataInHand at: $C put: ''. dataInHand at: $D put: ''. dataInHand at: $H put: ''. dataInHand at: $S put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	Transcript show: (dataInHand at: current); cr.	dataInHand at: current put: ((dataInHand at: current) , ' ' , card).	Transcript show: (dataInHand at: current); cr.].		Transcript show: (dataInHand); cr.		suitStreak := OrderedCollection new.	temp := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		count := 1. spaces := 0. word := ''.		aValue do: [:a | Transcript show: 'h'. Transcript show: (a); cr. (a ~= ' ' & (count ~= 1) ) 			ifTrue: [word at: (count - spaces) put: a asCharacter. count := count + 1. Transcript show: word.]			ifFalse: [ (count ~= 1) ifTrue: [temp add: word. word := '' ]. count := count + 1. spaces := spaces + 1. Transcript show: ((count - spaces)); cr.]  ]. 		Transcript show: (temp); cr.		(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].		Transcript show: (suitStreak); cr.	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 20:17' prior: 33736722!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| spaces temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |suitStreak := OrderedCollection new.dataInHand := Dictionary new.dataInHand at: $C put: ''. dataInHand at: $D put: ''. dataInHand at: $H put: ''. dataInHand at: $S put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	Transcript show: (dataInHand at: current); cr.	dataInHand at: current put: ((dataInHand at: current) , ' ' , card).	Transcript show: (dataInHand at: current); cr.].		Transcript show: (dataInHand); cr.		suitStreak := OrderedCollection new.	temp := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		count := 1. spaces := 0. word := ''.		aValue do: [:a | Transcript show: 'h'. Transcript show: (a); cr. (a ~= ' ' & (count ~= 1) ) 			ifTrue: [word at: (count - spaces) put: a asSymbol. count := count + 1. Transcript show: word.]			ifFalse: [ (count ~= 1) ifTrue: [temp add: word. word := '' ]. count := count + 1. spaces := spaces + 1. Transcript show: ((count - spaces)); cr.]  ]. 		Transcript show: (temp); cr.		(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].		Transcript show: (suitStreak); cr.	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 20:18' prior: 33738433!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| spaces temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |suitStreak := OrderedCollection new.dataInHand := Dictionary new.dataInHand at: $C put: ''. dataInHand at: $D put: ''. dataInHand at: $H put: ''. dataInHand at: $S put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	Transcript show: (dataInHand at: current); cr.	dataInHand at: current put: ((dataInHand at: current) , ' ' , card).	Transcript show: (dataInHand at: current); cr.].		Transcript show: (dataInHand); cr.		suitStreak := OrderedCollection new.	temp := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		count := 1. spaces := 0. word := ''.		aValue do: [:a | Transcript show: 'h'. Transcript show: (a); cr. (a ~= ' ' & (count ~= 1) ) 			ifTrue: [word , a. count := count + 1. Transcript show: word.]			ifFalse: [ (count ~= 1) ifTrue: [temp add: word. word := '' ]. count := count + 1. spaces := spaces + 1. Transcript show: ((count - spaces)); cr.]  ]. 		Transcript show: (temp); cr.		(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].		Transcript show: (suitStreak); cr.	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 20:19' prior: 33740141!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| spaces temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |suitStreak := OrderedCollection new.dataInHand := Dictionary new.dataInHand at: $C put: ''. dataInHand at: $D put: ''. dataInHand at: $H put: ''. dataInHand at: $S put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	Transcript show: (dataInHand at: current); cr.	dataInHand at: current put: ((dataInHand at: current) , ' ' , card).	Transcript show: (dataInHand at: current); cr.].		Transcript show: (dataInHand); cr.		suitStreak := OrderedCollection new.	temp := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		count := 1. spaces := 0. word := ''.		aValue do: [:a | Transcript show: 'h'. Transcript show: (a); cr. (a ~= ' ' & (count ~= 1) ) 			ifTrue: [word := word , a. Transcript show: word.]			ifFalse: [ (count ~= 1) ifTrue: [temp add: word. word := '' ]. count := count + 1. spaces := spaces + 1. Transcript show: ((count - spaces)); cr.]  ]. 		Transcript show: (temp); cr.		(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].		Transcript show: (suitStreak); cr.	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 20:19' prior: 33741816!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| spaces temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |suitStreak := OrderedCollection new.dataInHand := Dictionary new.dataInHand at: $C put: ''. dataInHand at: $D put: ''. dataInHand at: $H put: ''. dataInHand at: $S put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	Transcript show: (dataInHand at: current); cr.	dataInHand at: current put: ((dataInHand at: current) , ' ' , card).	Transcript show: (dataInHand at: current); cr.].		Transcript show: (dataInHand); cr.		suitStreak := OrderedCollection new.	temp := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		count := 1. spaces := 0. word := ''.		aValue do: [:a | Transcript show: 'h'. Transcript show: (a); cr. (a ~= ' ' & (count ~= 1) ) 			ifTrue: [word := word , a asString. Transcript show: word.]			ifFalse: [ (count ~= 1) ifTrue: [temp add: word. word := '' ]. count := count + 1. spaces := spaces + 1. Transcript show: ((count - spaces)); cr.]  ]. 		Transcript show: (temp); cr.		(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].		Transcript show: (suitStreak); cr.	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 20:33' prior: 33628608!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |suitStreak := OrderedCollection new.newList :=  OrderedCollection new.dataInHand := Dictionary new.dataInHand at: 'C' put: ''. dataInHand at: 'D' put: ''. dataInHand at: 'H' put: ''. dataInHand at: 'S' put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	dataInHand at: current put: ( (dataInHand at: current) , card , ' ' )]. 	suitStreak := OrderedCollection new.	temp := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		word := ''.		aValue do: [:a | (a ~= ' ') ifTrue: [word,a] ifFalse: [ temp add: word. word := '' ] ].		(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 20:33' prior: 33745151!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |suitStreak := OrderedCollection new.newList :=  OrderedCollection new.dataInHand := Dictionary new.dataInHand at: 'C' put: ''. dataInHand at: 'D' put: ''. dataInHand at: 'H' put: ''. dataInHand at: 'S' put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	dataInHand at: current put: ( (dataInHand at: current) , card , ' ' )]. 	suitStreak := OrderedCollection new.	temp := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		word := ''.		aValue do: [:a | (a ~= ' ') ifTrue: [word,a] ifFalse: [ temp add: word. word := '' ] ].		(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].		Transcript show: dataInHand; cr.	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 20:34' prior: 33746407!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |suitStreak := OrderedCollection new.newList :=  OrderedCollection new.dataInHand := Dictionary new.dataInHand at: 'C' put: ''. dataInHand at: 'D' put: ''. dataInHand at: 'H' put: ''. dataInHand at: 'S' put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	dataInHand at: current put: ( (dataInHand at: current) , card , ' ' )]. 	suitStreak := OrderedCollection new.	temp := OrderedCollection new.	max := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		word := ''.		aValue do: [:a | (a ~= ' ') ifTrue: [word,a] ifFalse: [ temp add: word. word := '' ] ].		(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].		Transcript show: dataInHand; cr.	Transcript show: suitStreak; cr.	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 20:35' prior: 33747699!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |suitStreak := OrderedCollection new.newList :=  OrderedCollection new.dataInHand := Dictionary new.dataInHand at: 'C' put: ''. dataInHand at: 'D' put: ''. dataInHand at: 'H' put: ''. dataInHand at: 'S' put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	dataInHand at: current put: ( (dataInHand at: current) , card , ' ' )]. 	suitStreak := OrderedCollection new.	temp := OrderedCollection new.	max := 0.		Transcript show: dataInHand; cr.		dataInHand keysAndValuesDo: [:aKey :aValue | 		word := ''.		aValue do: [:a | (a ~= ' ') ifTrue: [word,a] ifFalse: [ temp add: word. word := '' ] ].		(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].		Transcript show: dataInHand; cr.	Transcript show: suitStreak; cr.	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 20:35' prior: 33749025!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |suitStreak := OrderedCollection new.newList :=  OrderedCollection new.dataInHand := Dictionary new.dataInHand at: 'C' put: ''. dataInHand at: 'D' put: ''. dataInHand at: 'H' put: ''. dataInHand at: 'S' put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	dataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , ' ' )]. 	suitStreak := OrderedCollection new.	temp := OrderedCollection new.	max := 0.		Transcript show: dataInHand; cr.		dataInHand keysAndValuesDo: [:aKey :aValue | 		word := ''.		aValue do: [:a | (a ~= ' ') ifTrue: [word,a] ifFalse: [ temp add: word. word := '' ] ].		(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].		Transcript show: dataInHand; cr.	Transcript show: suitStreak; cr.	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 20:37' prior: 33750389!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |suitStreak := OrderedCollection new.newList :=  OrderedCollection new.dataInHand := Dictionary new.dataInHand at: 'C' put: ''. dataInHand at: 'D' put: ''. dataInHand at: 'H' put: ''. dataInHand at: 'S' put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	dataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , ' ' )]. 	suitStreak := OrderedCollection new.	temp := OrderedCollection new.	max := 0.	Transcript show: dataInHand; cr.		dataInHand keysAndValuesDo: [:aKey :aValue | 		word := ''.		aValue do: [:a | (a ~= ' ') ifTrue: [word,a. Transcript show: temp; cr.] ifFalse: [ temp add: word. word := '' ] ].		(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].		Transcript show: dataInHand; cr.	Transcript show: suitStreak; cr.	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 20:38' prior: 33751771!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |suitStreak := OrderedCollection new.newList :=  OrderedCollection new.dataInHand := Dictionary new.dataInHand at: 'C' put: ''. dataInHand at: 'D' put: ''. dataInHand at: 'H' put: ''. dataInHand at: 'S' put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	dataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , ' ' )]. 	suitStreak := OrderedCollection new.	temp := OrderedCollection new.	max := 0.	Transcript show: dataInHand; cr.		dataInHand keysAndValuesDo: [:aKey :aValue | 		word := ''.		aValue do: [:a | (a ~= ' ') ifTrue: [Transcript show: (word,a); cr. word,a] ifFalse: [ temp add: word. word := '' ] ].		(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].		Transcript show: dataInHand; cr.	Transcript show: suitStreak; cr.	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 20:39' prior: 33753179!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |suitStreak := OrderedCollection new.newList :=  OrderedCollection new.dataInHand := Dictionary new.dataInHand at: 'C' put: ''. dataInHand at: 'D' put: ''. dataInHand at: 'H' put: ''. dataInHand at: 'S' put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	dataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , ' ' )]. 	suitStreak := OrderedCollection new.	temp := OrderedCollection new.	max := 0.	Transcript show: dataInHand; cr.		dataInHand keysAndValuesDo: [:aKey :aValue | 		word := ''.		aValue do: [:a | (a ~= ' ') ifTrue: [Transcript show: (word,a asString); cr. word,a] ifFalse: [ temp add: word. word := '' ] ].		(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].		Transcript show: dataInHand; cr.	Transcript show: suitStreak; cr.	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 20:40' prior: 33754590!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |suitStreak := OrderedCollection new.newList :=  OrderedCollection new.dataInHand := Dictionary new.dataInHand at: 'C' put: ''. dataInHand at: 'D' put: ''. dataInHand at: 'H' put: ''. dataInHand at: 'S' put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	dataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , ' ' )]. 	suitStreak := OrderedCollection new.	temp := OrderedCollection new.	max := 0.	Transcript show: dataInHand; cr.		dataInHand keysAndValuesDo: [:aKey :aValue | 		word := ''.		aValue do: [:a | (a ~= ' ') ifTrue: [word := word , a asString] ifFalse: [ temp add: word. word := '' ] ].		(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].		Transcript show: dataInHand; cr.	Transcript show: suitStreak; cr.	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 20:40' prior: 33756010!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |suitStreak := OrderedCollection new.newList :=  OrderedCollection new.dataInHand := Dictionary new.dataInHand at: 'C' put: ''. dataInHand at: 'D' put: ''. dataInHand at: 'H' put: ''. dataInHand at: 'S' put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	dataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , ' ' )]. 	suitStreak := OrderedCollection new.	temp := OrderedCollection new.	max := 0.	Transcript show: dataInHand; cr.		dataInHand keysAndValuesDo: [:aKey :aValue | 		word := ''.		aValue do: [:a | (a ~= ' ') ifTrue: [word := word , a asString] ifFalse: [ temp add: word. word := '' ] ].		Transcript show: temp; cr.		(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].		Transcript show: dataInHand; cr.	Transcript show: suitStreak; cr.	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 20:41' prior: 33757409!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |suitStreak := OrderedCollection new.newList :=  OrderedCollection new.dataInHand := Dictionary new.dataInHand at: 'C' put: ''. dataInHand at: 'D' put: ''. dataInHand at: 'H' put: ''. dataInHand at: 'S' put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	dataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , ' ' )]. 	suitStreak := OrderedCollection new.	temp := OrderedCollection new.	max := 0.	Transcript show: dataInHand; cr.		dataInHand keysAndValuesDo: [:aKey :aValue | 		word := ''.		aValue do: [:a | (a ~= ' ') ifTrue: [Transcript show: word; cr. word := word , a asString] ifFalse: [ temp add: word. word := '' ] ].		Transcript show: temp; cr.		(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].		Transcript show: dataInHand; cr.	Transcript show: suitStreak; cr.	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 20:41' prior: 33758837!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |suitStreak := OrderedCollection new.newList :=  OrderedCollection new.dataInHand := Dictionary new.dataInHand at: 'C' put: ''. dataInHand at: 'D' put: ''. dataInHand at: 'H' put: ''. dataInHand at: 'S' put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	dataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , ' ' )]. 	suitStreak := OrderedCollection new.	temp := OrderedCollection new.	max := 0.	Transcript show: dataInHand; cr.		dataInHand keysAndValuesDo: [:aKey :aValue | 		word := ''.		aValue do: [:a | (a ~= ' ') ifTrue: [Transcript show: a; cr. word := word , a asString] ifFalse: [ temp add: word. word := '' ] ].		Transcript show: temp; cr.		(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].		Transcript show: dataInHand; cr.	Transcript show: suitStreak; cr.	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 20:42' prior: 33760292!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |suitStreak := OrderedCollection new.newList :=  OrderedCollection new.dataInHand := Dictionary new.dataInHand at: 'C' put: ''. dataInHand at: 'D' put: ''. dataInHand at: 'H' put: ''. dataInHand at: 'S' put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	dataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , ' ' )]. 	suitStreak := OrderedCollection new.	temp := OrderedCollection new.	max := 0.	Transcript show: dataInHand; cr.		dataInHand keysAndValuesDo: [:aKey :aValue | 		word := ''.		aValue do: [:a | (a ~= ' ' asCharacter) ifTrue: [Transcript show: a; cr. word := word , a asString] ifFalse: [ temp add: word. word := '' ] ].		Transcript show: temp; cr.		(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].		Transcript show: dataInHand; cr.	Transcript show: suitStreak; cr.	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 20:44' prior: 33761744!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |suitStreak := OrderedCollection new.newList :=  OrderedCollection new.dataInHand := Dictionary new.dataInHand at: 'C' put: ''. dataInHand at: 'D' put: ''. dataInHand at: 'H' put: ''. dataInHand at: 'S' put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	dataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , ' ' )]. 	suitStreak := OrderedCollection new.	temp := OrderedCollection new.	max := 0.	Transcript show: dataInHand; cr.		dataInHand keysAndValuesDo: [:aKey :aValue | 		word := ''.		aValue do: [:a | (a asString ~= ' ') ifTrue: [Transcript show: a; cr. word := word , a asString] ifFalse: [ temp add: word. word := '' ] ].		Transcript show: temp; cr.		(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].		Transcript show: dataInHand; cr.	Transcript show: suitStreak; cr.	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 20:45' prior: 33763208!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |suitStreak := OrderedCollection new.newList :=  OrderedCollection new.dataInHand := Dictionary new.dataInHand at: 'C' put: ''. dataInHand at: 'D' put: ''. dataInHand at: 'H' put: ''. dataInHand at: 'S' put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	dataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , ' ' )]. 	suitStreak := OrderedCollection new.	temp := OrderedCollection new.	max := 0.	Transcript show: dataInHand; cr.		dataInHand keysAndValuesDo: [:aKey :aValue | 		word := ''.		temp := OrderedCollection new.		aValue do: [:a | (a asString ~= ' ') ifTrue: [Transcript show: a; cr. word := word , a asString] ifFalse: [ temp add: word. word := '' ] ].		Transcript show: temp; cr.		(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].		Transcript show: dataInHand; cr.	Transcript show: suitStreak; cr.	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 20:45' prior: 33764669!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |suitStreak := OrderedCollection new.newList :=  OrderedCollection new.dataInHand := Dictionary new.dataInHand at: 'C' put: ''. dataInHand at: 'D' put: ''. dataInHand at: 'H' put: ''. dataInHand at: 'S' put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	dataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , ' ' )]. 	suitStreak := OrderedCollection new.	max := 0.	Transcript show: dataInHand; cr.		dataInHand keysAndValuesDo: [:aKey :aValue | 		word := ''.		temp := OrderedCollection new.		aValue do: [:a | (a asString ~= ' ') ifTrue: [Transcript show: a; cr. word := word , a asString] ifFalse: [ temp add: word. word := '' ] ].		(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 20:46' prior: 33766163!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |suitStreak := OrderedCollection new.newList :=  OrderedCollection new.dataInHand := Dictionary new.dataInHand at: 'C' put: ''. dataInHand at: 'D' put: ''. dataInHand at: 'H' put: ''. dataInHand at: 'S' put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	dataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , ' ' )]. 	suitStreak := OrderedCollection new.	max := 0.	Transcript show: dataInHand; cr.		dataInHand keysAndValuesDo: [:aKey :aValue | 		word := ''.		temp := OrderedCollection new.		aValue do: [:a | (a asString ~= ' ') ifTrue: [word := word , a asString] ifFalse: [ temp add: word. word := '' ] ].		(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !----SNAPSHOT----2021-01-30T20:46:58.946546-05:00 Pharo 8.0 - 64bit (stable).image priorSource: 104516!----SNAPSHOT----2021-01-30T20:47:27.926546-05:00 Pharo 8.0 - 64bit (stable).image priorSource: 214344!!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 20:50' prior: 33594736!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak |streaks := OrderedCollection new.notFound := true.2 to: nice size do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).		(previous asNumber == (current asNumber -1) & notFound)		ifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]		ifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]]].highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 20:51' prior: 33769073!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak |streaks := OrderedCollection new.notFound := true.2 to: nice size do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).		(previous asNumber == (current asNumber -1) & notFound)		ifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]		ifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]]].Transcript show: streaks; cr.highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 20:54' prior: 33770037!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak |streaks := OrderedCollection new.notFound := true.2 to: nice size do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).		(previous ~= current) ifTrue: [  	(previous asNumber == (current asNumber -1) & notFound)		ifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]		ifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]] ]].Transcript show: streaks; cr.highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 20:55' prior: 33657226!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| sorted data straight flushOrSuitStreak straightFlush valueStreak maxNumOfAKind suitOfAKind suitCards |	self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		sorted := self sort: hand.	Transcript show: 'sorted'; cr.	Transcript show: sorted; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight := self getHighestStreak: sorted.	Transcript show: 'straight'; cr.	Transcript show: straight; cr.		valueStreak := self getHighestValueStreak: sorted.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak; cr.		Transcript show: '-----'; cr.	flushOrSuitStreak := self getHighestSuitStreak: sorted.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak; cr.		straightFlush := OrderedCollection new.	(flushOrSuitStreak size > 4) ifTrue: [  		straightFlush := self getHighestStreak: flushOrSuitStreak.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush; cr.].		(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].	(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].	^sorted			"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !----SNAPSHOT----2021-01-30T20:59:02.642546-05:00 Pharo 8.0 - 64bit (stable).image priorSource: 214448!!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 21:01' prior: 33771032!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak |streaks := OrderedCollection new.notFound := true.2 to: nice size do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).		(previous ~= current) ifTrue: [  	(previous asNumber == (current asNumber -1) & notFound)		ifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]		ifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]] ]].highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 21:08' prior: 33772064!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| sorted data remaining straight flushOrSuitStreak straightFlush valueStreak maxNumOfAKind suitOfAKind suitCards |	self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		sorted := self sort: hand.	Transcript show: 'sorted'; cr.	Transcript show: sorted; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight := self getHighestStreak: sorted.	Transcript show: 'straight'; cr.	Transcript show: straight; cr.		valueStreak := self getHighestValueStreak: sorted.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak; cr.		Transcript show: '-----'; cr.	flushOrSuitStreak := self getHighestSuitStreak: sorted.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak; cr.		straightFlush := OrderedCollection new.	(flushOrSuitStreak size > 4) ifTrue: [  		straightFlush := self getHighestStreak: flushOrSuitStreak.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush; cr.].		(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].	(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].			remaining := sorted reject: [:a | valueStreak includes: a ].	Transcript show: 'remaining'; cr.	Transcript show: remaining; cr.		^sorted			"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 21:16' prior: 33774909!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| sorted data remaining temp straight flushOrSuitStreak straightFlush valueStreak valueStreak2 maxNumOfAKind suitOfAKind suitCards |	self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		sorted := self sort: hand.	Transcript show: 'sorted'; cr.	Transcript show: sorted; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight := self getHighestStreak: sorted.	Transcript show: 'straight'; cr.	Transcript show: straight; cr.		valueStreak := self getHighestValueStreak: sorted.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak; cr.		Transcript show: '-----'; cr.	flushOrSuitStreak := self getHighestSuitStreak: sorted.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak; cr.		straightFlush := OrderedCollection new.	(flushOrSuitStreak size > 4) ifTrue: [  		straightFlush := self getHighestStreak: flushOrSuitStreak.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush; cr.].		(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].	(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].			remaining := sorted reject: [:a | valueStreak includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining; cr.	temp := self getHighestValueStreak: remaining.	valueStreak2 := OrderedCollection new.	(temp size >= 2) ifTrue: [ (temp size -1) to: (temp size) do: [ :i | valueStreak2 add: (temp at: i ) ] ].		(valueStreak size == 3 & (valueStreak2 size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreak2 )].		^sorted			"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 21:18' prior: 33776795!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| sorted data remaining temp straight flushOrSuitStreak straightFlush valueStreak valueStreak2 maxNumOfAKind suitOfAKind suitCards |	self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		sorted := self sort: hand.	Transcript show: 'sorted'; cr.	Transcript show: sorted; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight := self getHighestStreak: sorted.	Transcript show: 'straight'; cr.	Transcript show: straight; cr.		valueStreak := self getHighestValueStreak: sorted.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak; cr.		Transcript show: '-----'; cr.	flushOrSuitStreak := self getHighestSuitStreak: sorted.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak; cr.		straightFlush := OrderedCollection new.	(flushOrSuitStreak size > 4) ifTrue: [  		straightFlush := self getHighestStreak: flushOrSuitStreak.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush; cr.].		(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].	(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].			remaining := sorted reject: [:a | valueStreak includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining; cr.	temp := self getHighestValueStreak: remaining.	valueStreak2 := OrderedCollection new.	(temp size >= 2) ifTrue: [ (temp size -1) to: (temp size) do: [ :i | valueStreak2 add: (temp at: i ) ] ].		(valueStreak size == 3 & (valueStreak2 size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreak2 )].	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		^sorted			"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 21:27' prior: 33779018!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| sorted data remaining temp straight flushOrSuitStreak straightFlush valueStreak valueStreak2 maxNumOfAKind suitOfAKind suitCards |	self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		sorted := self sort: hand.	Transcript show: 'sorted'; cr.	Transcript show: sorted; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight := self getHighestStreak: sorted.	Transcript show: 'straight'; cr.	Transcript show: straight; cr.		valueStreak := self getHighestValueStreak: sorted.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak; cr.		Transcript show: '-----'; cr.	flushOrSuitStreak := self getHighestSuitStreak: sorted.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak; cr.		straightFlush := OrderedCollection new.	(flushOrSuitStreak size > 4) ifTrue: [  		straightFlush := self getHighestStreak: flushOrSuitStreak.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush; cr.].		(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].	(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].			remaining := sorted reject: [:a | valueStreak includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining; cr.	temp := self getHighestValueStreak: remaining.	valueStreak2 := OrderedCollection new.	(temp size >= 2) ifTrue: [ (temp size -1) to: (temp size) do: [ :i | valueStreak2 add: (temp at: i ) ] ].		(valueStreak size == 3 & (valueStreak2 size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreak2 )].	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		(straight size == 5) ifTrue: [Transcript show: 6; cr. ^straight].		^sorted			"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 21:28' prior: 33781326!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| sorted data remaining temp straight flushOrSuitStreak straightFlush valueStreak valueStreak2 maxNumOfAKind suitOfAKind suitCards |	self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		sorted := self sort: hand.	Transcript show: 'sorted'; cr.	Transcript show: sorted; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight := self getHighestStreak: sorted.	Transcript show: 'straight'; cr.	Transcript show: straight; cr.		valueStreak := self getHighestValueStreak: sorted.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak; cr.		Transcript show: '-----'; cr.	flushOrSuitStreak := self getHighestSuitStreak: sorted.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak; cr.		straightFlush := OrderedCollection new.	(flushOrSuitStreak size > 4) ifTrue: [  		straightFlush := self getHighestStreak: flushOrSuitStreak.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush; cr.].		(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].	(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].			remaining := sorted reject: [:a | valueStreak includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining; cr.	temp := self getHighestValueStreak: remaining.	valueStreak2 := OrderedCollection new.	(temp size >= 2) ifTrue: [ (temp size -1) to: (temp size) do: [ :i | valueStreak2 add: (temp at: i ) ] ].		(valueStreak size == 3 & (valueStreak2 size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreak2 )].	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].		^sorted			"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 21:32' prior: 33773908!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak |streaks := OrderedCollection new.notFound := true.2 to: nice size do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).		(previous ~= current) ifTrue: [  	(previous asNumber == (current asNumber -1) & notFound)		ifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]		ifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]] ]].Transcript show: streaks.highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 21:33' prior: 33786086!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak |streaks := OrderedCollection new.notFound := true.2 to: nice size do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).		(previous ~= current) ifTrue: [  	(previous asNumber == (current asNumber -1) & notFound)		ifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]		ifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]] ]].highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].Transcript show: highestStreak.^highestStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 21:40' prior: 33655838!getHighestValueStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |	valueStreak := OrderedCollection new.	newList :=  OrderedCollection new.	dataInHand := Dictionary new. 	1 to: 13 do: [ :i | dataInHand at: i put: newList].	2 to: streaks size do: [ :i | 		previousCard := streaks at: (i-1).		previous := previousCard copyFrom: 1 to: (previousCard size-1).		card := streaks at: i.		current := card copyFrom: 1 to: (card size-1).		(previous asNumber == current asNumber)			ifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]			ifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].	(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].	Transcript show: dataInHand; cr.  	valueStreak := OrderedCollection new.	maxCount := 0.	maxVal := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > maxCount | (aKey > maxVal & (aValue size >= maxCount))) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue ] ].	highestValueStreak := valueStreak.	^highestValueStreak! !----SNAPSHOT----2021-01-30T21:41:45.086546-05:00 Pharo 8.0 - 64bit (stable).image priorSource: 219283!!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 21:43' prior: 33788148!getHighestValueStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |	valueStreak := OrderedCollection new.	newList :=  OrderedCollection new.	dataInHand := Dictionary new. 	1 to: 13 do: [ :i | dataInHand at: i put: newList].	2 to: streaks size do: [ :i | 		previousCard := streaks at: (i-1).		previous := previousCard copyFrom: 1 to: (previousCard size-1).		card := streaks at: i.		current := card copyFrom: 1 to: (card size-1).		(previous asNumber == current asNumber)			ifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]			ifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].	(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].	valueStreak := OrderedCollection new.	maxCount := 0.	maxVal := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > maxCount | (aKey > maxVal & (aValue size >= maxCount))) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue ] ].		Transcript show: valueStreak; cr.  	highestValueStreak := valueStreak.	^highestValueStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 21:44' prior: 33789674!getHighestValueStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |	valueStreak := OrderedCollection new.	newList :=  OrderedCollection new.	dataInHand := Dictionary new. 	1 to: 13 do: [ :i | dataInHand at: i put: newList].	2 to: streaks size do: [ :i | 		previousCard := streaks at: (i-1).		previous := previousCard copyFrom: 1 to: (previousCard size-1).		card := streaks at: i.		current := card copyFrom: 1 to: (card size-1).		(previous asNumber == current asNumber)			ifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]			ifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].	(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].	valueStreak := OrderedCollection new.	maxCount := 0.	maxVal := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > maxCount | (aKey > maxVal & (aValue size >= maxCount))) ifTrue: [maxCount := aValue size. maxVal := aKey. Transcript show: aValue; cr. valueStreak := aValue ] ].		Transcript show: valueStreak; cr.  	highestValueStreak := valueStreak.	^highestValueStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 21:45' prior: 33791098!getHighestValueStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |	valueStreak := OrderedCollection new.	newList :=  OrderedCollection new.	dataInHand := Dictionary new. 	1 to: 13 do: [ :i | dataInHand at: i put: newList].	2 to: streaks size do: [ :i | 		previousCard := streaks at: (i-1).		previous := previousCard copyFrom: 1 to: (previousCard size-1).		card := streaks at: i.		current := card copyFrom: 1 to: (card size-1).		(previous asNumber == current asNumber)			ifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]			ifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].	(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].	valueStreak := OrderedCollection new.	maxCount := 0.	maxVal := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > maxCount | (aKey > maxVal & (aValue size >= maxCount))) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue. Transcript show: aValue; cr. ] ].		Transcript show: valueStreak; cr.  	highestValueStreak := valueStreak.	^highestValueStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 21:45' prior: 33792551!getHighestValueStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |	valueStreak := OrderedCollection new.	newList :=  OrderedCollection new.	dataInHand := Dictionary new. 	1 to: 13 do: [ :i | dataInHand at: i put: newList].	2 to: streaks size do: [ :i | 		previousCard := streaks at: (i-1).		previous := previousCard copyFrom: 1 to: (previousCard size-1).		card := streaks at: i.		current := card copyFrom: 1 to: (card size-1).		(previous asNumber == current asNumber)			ifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]			ifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].	(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].	valueStreak := OrderedCollection new.	maxCount := 0.	maxVal := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > maxCount | (aKey > maxVal & (aValue size >= maxCount))) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue. Transcript show: valueStreak; cr. ] ].		Transcript show: valueStreak; cr.  	highestValueStreak := valueStreak.	^highestValueStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 21:46' prior: 33794005!getHighestValueStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |	valueStreak := OrderedCollection new.	newList :=  OrderedCollection new.	dataInHand := Dictionary new. 	1 to: 13 do: [ :i | dataInHand at: i put: newList].	2 to: streaks size do: [ :i | 		previousCard := streaks at: (i-1).		previous := previousCard copyFrom: 1 to: (previousCard size-1).		card := streaks at: i.		current := card copyFrom: 1 to: (card size-1).		(previous asNumber == current asNumber)			ifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]			ifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].	(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].	valueStreak := OrderedCollection new.	maxCount := 0.	maxVal := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > maxCount | (aKey > maxVal & (aValue size >= maxCount))) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue. Transcript show: valueStreak; cr. ] ].		Transcript show: valueStreak; cr.  	highestValueStreak := valueStreak.	Transcript show: valueStreak; cr.	^highestValueStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 21:46' prior: 33795464!getHighestValueStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |	valueStreak := OrderedCollection new.	newList :=  OrderedCollection new.	dataInHand := Dictionary new. 	1 to: 13 do: [ :i | dataInHand at: i put: newList].	2 to: streaks size do: [ :i | 		previousCard := streaks at: (i-1).		previous := previousCard copyFrom: 1 to: (previousCard size-1).		card := streaks at: i.		current := card copyFrom: 1 to: (card size-1).		(previous asNumber == current asNumber)			ifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]			ifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].	(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].	valueStreak := OrderedCollection new.	maxCount := 0.	maxVal := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > maxCount | (aKey > maxVal & (aValue size >= maxCount))) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue. Transcript show: valueStreak; cr. ] ].		Transcript show: valueStreak; cr.  	highestValueStreak := valueStreak.	Transcript show: highestValueStreak; cr.	^highestValueStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 21:48' prior: 33796958!getHighestValueStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |	valueStreak := OrderedCollection new.	newList :=  OrderedCollection new.	dataInHand := Dictionary new. 	1 to: 13 do: [ :i | dataInHand at: i put: newList].	2 to: streaks size do: [ :i | 		previousCard := streaks at: (i-1).		previous := previousCard copyFrom: 1 to: (previousCard size-1).		card := streaks at: i.		current := card copyFrom: 1 to: (card size-1).		(previous asNumber == current asNumber)			ifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]			ifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].	(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].	valueStreak := OrderedCollection new.	maxCount := 0.	maxVal := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > maxCount | (aKey asString > maxVal asString & (aValue size >= maxCount))) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue. Transcript show: valueStreak; cr. ] ].		highestValueStreak := valueStreak.	^highestValueStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 21:49' prior: 33798459!getHighestValueStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |	valueStreak := OrderedCollection new.	newList :=  OrderedCollection new.	dataInHand := Dictionary new. 	1 to: 13 do: [ :i | dataInHand at: i put: newList].	2 to: streaks size do: [ :i | 		previousCard := streaks at: (i-1).		previous := previousCard copyFrom: 1 to: (previousCard size-1).		card := streaks at: i.		current := card copyFrom: 1 to: (card size-1).		(previous asNumber == current asNumber)			ifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]			ifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].	(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].	valueStreak := OrderedCollection new.	maxCount := 0.	maxVal := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > maxCount | (aKey asString > maxVal asString & (aValue size >= maxCount))) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue] ].		Transcript show: valueStreak; cr. 	highestValueStreak := valueStreak.	^highestValueStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 21:49' prior: 33767526!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |suitStreak := OrderedCollection new.newList :=  OrderedCollection new.dataInHand := Dictionary new.dataInHand at: 'C' put: ''. dataInHand at: 'D' put: ''. dataInHand at: 'H' put: ''. dataInHand at: 'S' put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	dataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , ' ' )]. 	suitStreak := OrderedCollection new.	max := 0.		dataInHand keysAndValuesDo: [:aKey :aValue | 		word := ''.		temp := OrderedCollection new.		aValue do: [:a | (a asString ~= ' ') ifTrue: [word := word , a asString] ifFalse: [ temp add: word. word := '' ] ].		(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 21:50' prior: 33787114!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak |streaks := OrderedCollection new.notFound := true.2 to: nice size do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).		(previous ~= current) ifTrue: [  	(previous asNumber == (current asNumber -1) & notFound)		ifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]		ifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]] ]].highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 21:51' prior: 33799899!getHighestValueStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |	valueStreak := OrderedCollection new.	newList :=  OrderedCollection new.	dataInHand := Dictionary new. 	1 to: 13 do: [ :i | dataInHand at: i put: newList].	2 to: streaks size do: [ :i | 		previousCard := streaks at: (i-1).		previous := previousCard copyFrom: 1 to: (previousCard size-1).		card := streaks at: i.		current := card copyFrom: 1 to: (card size-1).		(previous asNumber == current asNumber)			ifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]			ifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].	(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].	valueStreak := OrderedCollection new.	maxCount := 0.	maxVal := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > maxCount | (aKey asNumber > maxVal asNumber & (aValue size >= maxCount))) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue] ].		Transcript show: valueStreak; cr. 	highestValueStreak := valueStreak.	^highestValueStreak! !----SNAPSHOT----2021-01-30T21:51:40.406546-05:00 Pharo 8.0 - 64bit (stable).image priorSource: 235049!!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 22:02' prior: 33783703!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| sorted data remaining temp straight flushOrSuitStreak straightFlush valueStreak valueStreak2 maxNumOfAKind suitOfAKind suitCards |	self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		sorted := self sort: hand.	Transcript show: 'sorted'; cr.	Transcript show: sorted; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight := self getHighestStreak: sorted.	Transcript show: 'straight'; cr.	Transcript show: straight; cr.		valueStreak := self getHighestValueStreak: sorted.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak; cr.		Transcript show: '-----'; cr.	flushOrSuitStreak := self getHighestSuitStreak: sorted.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak; cr.		straightFlush := OrderedCollection new.	(flushOrSuitStreak size > 4) ifTrue: [  		straightFlush := self getHighestStreak: flushOrSuitStreak.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush; cr.].		(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].	(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].			remaining := sorted reject: [:a | valueStreak includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining; cr.	temp := self getHighestValueStreak: remaining.	valueStreak2 := OrderedCollection new.	(temp size >= 2) ifTrue: [ (temp size -1) to: (temp size) do: [ :i | valueStreak2 add: (temp at: i ) ] ].		(valueStreak size == 3 & (valueStreak2 size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreak2 )].	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].	(valueStreak size == 2 & (valueStreak2 size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreak2 )].				^sorted			"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 22:06' prior: 33805190!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| sorted data remaining temp straight flushOrSuitStreak straightFlush valueStreak valueStreak2 maxNumOfAKind suitOfAKind suitCards |	self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		sorted := self sort: hand.	Transcript show: 'sorted'; cr.	Transcript show: sorted; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight := self getHighestStreak: sorted.	Transcript show: 'straight'; cr.	Transcript show: straight; cr.		valueStreak := self getHighestValueStreak: sorted.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak; cr.		Transcript show: '-----'; cr.	flushOrSuitStreak := self getHighestSuitStreak: sorted.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak; cr.		straightFlush := OrderedCollection new.	(flushOrSuitStreak size > 4) ifTrue: [  		straightFlush := self getHighestStreak: flushOrSuitStreak.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush; cr.].		(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].	(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].			remaining := sorted reject: [:a | valueStreak includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining; cr.	temp := self getHighestValueStreak: remaining.	valueStreak2 := OrderedCollection new.	(temp size >= 2) ifTrue: [ (temp size -1) to: (temp size) do: [ :i | valueStreak2 add: (temp at: i ) ] ].		(valueStreak size == 3 & (valueStreak2 size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreak2 )].	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].	(valueStreak size == 2 & (valueStreak2 size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreak2 )].	(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].			^sorted			"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 22:07' prior: 33807698!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| sorted data remaining temp straight flushOrSuitStreak straightFlush valueStreak valueStreak2 maxNumOfAKind suitOfAKind suitCards |	self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		sorted := self sort: hand.	Transcript show: 'sorted'; cr.	Transcript show: sorted; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight := self getHighestStreak: sorted.	Transcript show: 'straight'; cr.	Transcript show: straight; cr.		valueStreak := self getHighestValueStreak: sorted.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak; cr.		Transcript show: '-----'; cr.	flushOrSuitStreak := self getHighestSuitStreak: sorted.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak; cr.		straightFlush := OrderedCollection new.	(flushOrSuitStreak size > 4) ifTrue: [  		straightFlush := self getHighestStreak: flushOrSuitStreak.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush; cr.].		(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].	(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].			remaining := sorted reject: [:a | valueStreak includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining; cr.	temp := self getHighestValueStreak: remaining.	valueStreak2 := OrderedCollection new.	(temp size >= 2) ifTrue: [ (temp size -1) to: (temp size) do: [ :i | valueStreak2 add: (temp at: i ) ] ].		(valueStreak size == 3 & (valueStreak2 size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreak2 )].	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].	(valueStreak size == 2 & (valueStreak2 size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreak2 )].	(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].	^sorted			"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !----SNAPSHOT----2021-01-30T22:21:07.942539-05:00 Pharo 8.0 - 64bit (stable).image priorSource: 250565!!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 22:22' prior: 33783703!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| sorted data remaining temp straight flushOrSuitStreak straightFlush valueStreak valueStreak2 maxNumOfAKind suitOfAKind suitCards |	self convert: shuf.		sorted := self sort: hand.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight := self getHighestStreak: sorted.		valueStreak := self getHighestValueStreak: sorted.		flushOrSuitStreak := self getHighestSuitStreak: sorted.		straightFlush := OrderedCollection new.	(flushOrSuitStreak size > 4) ifTrue: [  		straightFlush := self getHighestStreak: flushOrSuitStreak].		(straightFlush size == 5) ifTrue: [^straightFlush].	(flushOrSuitStreak size == 4) ifTrue: [^flushOrSuitStreak].			remaining := sorted reject: [:a | valueStreak includes: a ].		temp := self getHighestValueStreak: remaining.	valueStreak2 := OrderedCollection new.	(temp size >= 2) ifTrue: [ (temp size -1) to: (temp size) do: [ :i | valueStreak2 add: (temp at: i ) ] ].		(valueStreak size == 3 & (valueStreak2 size == 2) ) ifTrue: [^( valueStreak , valueStreak2 )].	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		(valueStreak size == 3) ifTrue: [^valueStreak].		^sorted			"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"! !----SNAPSHOT----2021-01-30T22:22:22.506539-05:00 Pharo 8.0 - 64bit (stable).image priorSource: 258329!----SNAPSHOT----2021-01-30T22:22:50.534539-05:00 Pharo 8.0 - 64bit (stable).image priorSource: 260173!----SNAPSHOT----2021-01-30T22:24:02.720539-05:00 Pharo 8.0 - 64bit (stable).image priorSource: 260277!----SNAPSHOT----2021-01-30T22:24:19.566539-05:00 Pharo 8.0 - 64bit (stable).image priorSource: 260381!!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 22:25' prior: 33803646!getHighestValueStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |	valueStreak := OrderedCollection new.	newList :=  OrderedCollection new.	dataInHand := Dictionary new. 	1 to: 13 do: [ :i | dataInHand at: i put: newList].	2 to: streaks size do: [ :i | 		previousCard := streaks at: (i-1).		previous := previousCard copyFrom: 1 to: (previousCard size-1).		card := streaks at: i.		current := card copyFrom: 1 to: (card size-1).		(previous asNumber == current asNumber)			ifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]			ifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].	(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].	valueStreak := OrderedCollection new.	maxCount := 0.	maxVal := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > maxCount | (aKey asNumber > maxVal asNumber & (aValue size >= maxCount))) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue] ].		highestValueStreak := valueStreak.	^highestValueStreak! !!Poker methodsFor: 'actions' stamp: 'MagdalenaDhima 1/30/2021 22:27' prior: 33587518!convert: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| temp values suits output val |	hand := Array new: 9.	values := #('1' '2' '3' '4' '5' '6' '7' '8' '9' '10' '11' '12' '13').	suits := #('C' 'D' 'H' 'S').	1 to: 9 do: [ :i | 		val := shuf at: i.		temp := val % 13.		output := (temp == 0) 			ifFalse: [values at: temp]			ifTrue: [values at: 13]		. 		temp := val-1 // 13 floor. 		output := output , (suits at: temp). 		hand at: i put: output.	].! !----SNAPSHOT----2021-01-30T22:27:36.301539-05:00 Pharo 8.0 - 64bit (stable).image priorSource: 260485!!Poker methodsFor: 'actions' stamp: 'MagdalenaDhima 1/30/2021 22:28' prior: 33816512!convert: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| temp values suits output val |	hand := Array new: 9.	values := #('1' '2' '3' '4' '5' '6' '7' '8' '9' '10' '11' '12' '13').	suits := #('C' 'D' 'H' 'S').	1 to: 9 do: [ :i | 		val := shuf at: i.		temp := val % 13.		output := (temp == 0) 			ifFalse: [values at: temp]			ifTrue: [values at: 13]		. 		temp := val-1 // 13 +1 floor. 		output := output , (suits at: temp). 		hand at: i put: output.	].! !----SNAPSHOT----2021-01-30T22:28:27.742539-05:00 Pharo 8.0 - 64bit (stable).image priorSource: 262609!----SNAPSHOT----2021-01-30T22:31:41.121539-05:00 Pharo 8.0 - 64bit (stable).image priorSource: 263332!!Poker methodsFor: 'sorting' stamp: 'MagdalenaDhima 1/30/2021 22:55' prior: 33590330!sort: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| threeDigits twoDigits sorted aces |threeDigits := SortedCollection new. twoDigits := SortedCollection new.1 to: 9 do: [ :i | ((shuf at: i) size == 3) ifTrue: [threeDigits add: (shuf at: i)] ifFalse: [twoDigits add: (shuf at: i)]. ].sorted :=  (twoDigits asArray) , (threeDigits asArray).aces := sorted select: [:a | (a at: a size) asNumber == 1 ].sorted := sorted reject: [:a | (a at: a size) asNumber == 1 ].sorted := sorted , aces.^sorted! !!Poker methodsFor: 'sorting' stamp: 'MagdalenaDhima 1/30/2021 22:56' prior: 33818059!sort: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| threeDigits twoDigits sorted aces |threeDigits := SortedCollection new. twoDigits := SortedCollection new.1 to: 9 do: [ :i | ((shuf at: i) size == 3) ifTrue: [threeDigits add: (shuf at: i)] ifFalse: [twoDigits add: (shuf at: i)]. ].sorted := (twoDigits asArray) , (threeDigits asArray).aces := sorted select: [:a | (a at: a size) asNumber == 1 ].sorted := sorted reject: [:a | (a at: a size) asNumber == 1 ].sorted := sorted , aces.^sorted! !!Poker methodsFor: 'sorting' stamp: 'MagdalenaDhima 1/30/2021 22:58' prior: 33818720!sort: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| threeDigits twoDigits sorted aces |threeDigits := SortedCollection new. twoDigits := SortedCollection new.1 to: 9 do: [ :i | ((shuf at: i) size == 3) ifTrue: [threeDigits add: (shuf at: i)] ifFalse: [twoDigits add: (shuf at: i)]. ].sorted := (twoDigits asArray) , (threeDigits asArray).aces := sorted select: [:a | (a at: (a copyFrom: 1 to: (a size-1))) asNumber == 1 ].sorted := sorted reject: [:a | (a at: (a copyFrom: 1 to: (a size-1))) asNumber == 1 ].sorted := sorted , aces.^sorted! !!Poker methodsFor: 'sorting' stamp: 'MagdalenaDhima 1/30/2021 22:59' prior: 33819380!sort: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| threeDigits twoDigits sorted aces |threeDigits := SortedCollection new. twoDigits := SortedCollection new.1 to: 9 do: [ :i | ((shuf at: i) size == 3) ifTrue: [threeDigits add: (shuf at: i)] ifFalse: [twoDigits add: (shuf at: i)]. ].sorted := (twoDigits asArray) , (threeDigits asArray).aces := sorted select: [:a | (a at: (a copyFrom: 1 to: (a size-1))) asNumber == 1 ].sorted := sorted reject: [:a | (a at: (a copyFrom: 1 to: (a size-1))) asNumber == 1 ].sorted := sorted , aces.Transcript show: aces; cr.^sorted! !!Poker methodsFor: 'sorting' stamp: 'MagdalenaDhima 1/30/2021 23:02' prior: 33820088!sort: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| threeDigits twoDigits sorted aces |threeDigits := SortedCollection new. twoDigits := SortedCollection new.1 to: 9 do: [ :i | ((shuf at: i) size == 3) ifTrue: [threeDigits add: (shuf at: i)] ifFalse: [twoDigits add: (shuf at: i)]. ].sorted := (twoDigits asArray) , (threeDigits asArray).aces := sorted select: [:a |  (a copyFrom: 1 to: (a size-1)) asNumber == 1 ].sorted := sorted reject: [:a |  (a copyFrom: 1 to: (a size-1)) asNumber == 1 ].sorted := sorted , aces.Transcript show: aces; cr.^sorted! !!Poker methodsFor: 'sorting' stamp: 'MagdalenaDhima 1/30/2021 23:03' prior: 33820822!sort: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| threeDigits twoDigits sorted aces |threeDigits := SortedCollection new. twoDigits := SortedCollection new.1 to: 9 do: [ :i | ((shuf at: i) size == 3) ifTrue: [threeDigits add: (shuf at: i)] ifFalse: [twoDigits add: (shuf at: i)]. ].sorted := (twoDigits asArray) , (threeDigits asArray).aces := sorted select: [:a |  (a copyFrom: 1 to: (a size-1)) asNumber == 1 ].sorted := sorted reject: [:a |  (a copyFrom: 1 to: (a size-1)) asNumber == 1 ].sorted := sorted , aces.Transcript show: sorted; cr.^sorted! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 23:13' prior: 33802644!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak |streaks := OrderedCollection new.notFound := true.2 to: nice size do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).	(previous ~= current) ifTrue: [  	(previous asNumber == (current asNumber -1) & notFound)		ifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]		ifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]] ]].highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/30/2021 23:17' prior: 33815110!getHighestValueStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |	valueStreak := OrderedCollection new.	newList :=  OrderedCollection new.	dataInHand := Dictionary new. 	1 to: 13 do: [ :i | dataInHand at: i put: newList].		2 to: streaks size do: [ :i | 		previousCard := streaks at: (i-1).		previous := previousCard copyFrom: 1 to: (previousCard size-1).		card := streaks at: i.		current := card copyFrom: 1 to: (card size-1).		(previous asNumber == current asNumber)			ifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]			ifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].	(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].	valueStreak := OrderedCollection new.	maxCount := 0.	maxVal := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > maxCount | (aKey asNumber > maxVal asNumber & (aValue size >= maxCount))) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue] ].		highestValueStreak := valueStreak.	^highestValueStreak! !----SNAPSHOT----2021-01-30T23:22:02.871546-05:00 Pharo 8.0 - 64bit (stable).image priorSource: 263436!!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 10:47' prior: 33822266!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak |streaks := OrderedCollection new.notFound := true.2 to: nice size do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).	(previous ~= current) ifTrue: [  	( (current asNumber == 1 & ( previous == 13 ) ) | (previous asNumber == (current asNumber -1) & notFound) )		ifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]		ifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]] ]].highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 10:48' prior: 33824776!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak |streaks := OrderedCollection new.notFound := true.2 to: nice size do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).	(previous ~= current) ifTrue: [  	( ( (current asNumber == 1 & ( previous == 13 ) ) | (previous asNumber == (current asNumber -1) ) ) & notFound )		ifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]		ifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]] ]].highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 10:50' prior: 33825828!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak |streaks := OrderedCollection new.notFound := true.2 to: nice size do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).	(previous ~= current) ifTrue: [  	( ( (current asNumber == 1 & ( previous == 13 ) ) | (previous asNumber == (current asNumber -1) ) ) & notFound )		ifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]		ifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]] ]].Transcript show: streaks; cr.highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 11:06' prior: 33826885!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak |streaks := OrderedCollection new.notFound := true.2 to: nice size do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).	(previous ~= current) ifTrue: [  	( ( (current asNumber == 1 & ( previous == 13 ) ) | (previous asNumber == (current asNumber -1) ) ) & notFound )		ifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]		ifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]] ]].Transcript show: streaks; cr.highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [1 to: 5 do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 11:07' prior: 33812954!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| sorted data remaining temp straight flushOrSuitStreak straightFlush valueStreak valueStreak2 maxNumOfAKind suitOfAKind suitCards |	self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		sorted := self sort: hand.	Transcript show: 'sorted'; cr.	Transcript show: sorted; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight := self getHighestStreak: sorted.	Transcript show: 'straight'; cr.	Transcript show: straight; cr.		valueStreak := self getHighestValueStreak: sorted.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak; cr.		Transcript show: '-----'; cr.	flushOrSuitStreak := self getHighestSuitStreak: sorted.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak; cr.		straightFlush := OrderedCollection new.	(flushOrSuitStreak size > 4) ifTrue: [  		straightFlush := self getHighestStreak: flushOrSuitStreak.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush; cr.].		(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].	(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].			remaining := sorted reject: [:a | valueStreak includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining; cr.	temp := self getHighestValueStreak: remaining.	valueStreak2 := OrderedCollection new.	(temp size >= 2) ifTrue: [ (temp size -1) to: (temp size) do: [ :i | valueStreak2 add: (temp at: i ) ] ].		(valueStreak size == 3 & (valueStreak2 size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreak2 )].	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].	(valueStreak size == 2 & (valueStreak2 size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreak2 )].	(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].	^sorted			"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 11:36' prior: 33827973!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak |streaks := OrderedCollection new.notFound := true.2 to: nice size do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).	(previous ~= current) ifTrue: [  	( ( (current asNumber == 1 & ( previous == 13 ) ) | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )		ifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]		ifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]] ]].Transcript show: streaks; cr.highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [1 to: 5 do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 11:37' prior: 33831606!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak |streaks := OrderedCollection new.notFound := true.2 to: nice size do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).	(previous ~= current) ifTrue: [  	( ( (current asNumber == 1 & ( previous == 13 ) ) | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )		ifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]		ifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]] ]].Transcript show: streaks; cr.highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 11:37' prior: 33832694!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak |streaks := OrderedCollection new.notFound := true.2 to: nice size do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).	(previous ~= current) ifTrue: [  	( ( (current asNumber == 1 & ( previous == 13 ) ) | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )		ifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]		ifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]] ]].Transcript show: 'here';cr.Transcript show: streaks; cr.highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 11:41' prior: 33801339!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |suitStreak := OrderedCollection new.newList :=  OrderedCollection new.Transcript show: streaks; cr.dataInHand := Dictionary new.dataInHand at: 'C' put: ''. dataInHand at: 'D' put: ''. dataInHand at: 'H' put: ''. dataInHand at: 'S' put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	dataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , ' ' )]. 	suitStreak := OrderedCollection new.	max := 0.		dataInHand keysAndValuesDo: [:aKey :aValue | 		word := ''.		temp := OrderedCollection new.		aValue do: [:a | (a asString ~= ' ') ifTrue: [word := word , a asString] ifFalse: [ temp add: word. word := '' ] ].		(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 11:41' prior: 33834956!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |suitStreak := OrderedCollection new.newList :=  OrderedCollection new.Transcript show: 'looks'; cr.Transcript show: streaks; cr.dataInHand := Dictionary new.dataInHand at: 'C' put: ''. dataInHand at: 'D' put: ''. dataInHand at: 'H' put: ''. dataInHand at: 'S' put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	dataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , ' ' )]. 	suitStreak := OrderedCollection new.	max := 0.		dataInHand keysAndValuesDo: [:aKey :aValue | 		word := ''.		temp := OrderedCollection new.		aValue do: [:a | (a asString ~= ' ') ifTrue: [word := word , a asString] ifFalse: [ temp add: word. word := '' ] ].		(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 11:42' prior: 33836292!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |suitStreak := OrderedCollection new.newList :=  OrderedCollection new.dataInHand := Dictionary new.dataInHand at: 'C' put: ''. dataInHand at: 'D' put: ''. dataInHand at: 'H' put: ''. dataInHand at: 'S' put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	dataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , ' ' )]. 	suitStreak := OrderedCollection new.	max := 0.		dataInHand keysAndValuesDo: [:aKey :aValue | 		word := ''.		temp := OrderedCollection new.		aValue do: [:a | (a asString ~= ' ') ifTrue: [word := word , a asString] ifFalse: [ temp add: word. word := '' ] ].		(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 11:43' prior: 33823266!getHighestValueStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |	valueStreak := OrderedCollection new.	newList :=  OrderedCollection new.	Transcript show: streaks; cr.	dataInHand := Dictionary new. 	1 to: 13 do: [ :i | dataInHand at: i put: newList].		2 to: streaks size do: [ :i | 		previousCard := streaks at: (i-1).		previous := previousCard copyFrom: 1 to: (previousCard size-1).		card := streaks at: i.		current := card copyFrom: 1 to: (card size-1).		(previous asNumber == current asNumber)			ifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]			ifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].	(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].	valueStreak := OrderedCollection new.	maxCount := 0.	maxVal := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > maxCount | (aKey asNumber > maxVal asNumber & (aValue size >= maxCount))) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue] ].		highestValueStreak := valueStreak.	^highestValueStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 11:44' prior: 33838963!getHighestValueStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |	valueStreak := OrderedCollection new.	newList :=  OrderedCollection new.	Transcript show: 'input'; cr.	Transcript show: streaks; cr.	dataInHand := Dictionary new. 	1 to: 13 do: [ :i | dataInHand at: i put: newList].		2 to: streaks size do: [ :i | 		previousCard := streaks at: (i-1).		previous := previousCard copyFrom: 1 to: (previousCard size-1).		card := streaks at: i.		current := card copyFrom: 1 to: (card size-1).		(previous asNumber == current asNumber)			ifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]			ifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].	(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].	valueStreak := OrderedCollection new.	maxCount := 0.	maxVal := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		(aValue size > maxCount | (aKey asNumber > maxVal asNumber & (aValue size >= maxCount))) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue] ].		highestValueStreak := valueStreak.	^highestValueStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 11:47' prior: 33837658!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |suitStreak := OrderedCollection new.newList :=  OrderedCollection new.dataInHand := Dictionary new.dataInHand at: 'C' put: ''. dataInHand at: 'D' put: ''. dataInHand at: 'H' put: ''. dataInHand at: 'S' put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	dataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , ' ' )]. 	suitStreak := OrderedCollection new.	max := 0.		dataInHand keysAndValuesDo: [:aKey :aValue | 		word := ''.		temp := OrderedCollection new.		aValue do: [:a | (a asString ~= ' ') ifTrue: [word := word , a asString] ifFalse: [ temp add: word. word := '' ] ].		(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].	highestSuitStreak := OrderedCollection new.	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak].		Transcript show:  'pattern'; cr.	Transcript show:  highestSuitStreak; cr.	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 11:48' prior: 33841870!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |suitStreak := OrderedCollection new.newList :=  OrderedCollection new.dataInHand := Dictionary new.dataInHand at: 'C' put: ''. dataInHand at: 'D' put: ''. dataInHand at: 'H' put: ''. dataInHand at: 'S' put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	dataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , ' ' )]. 	suitStreak := OrderedCollection new.	max := 0.		dataInHand keysAndValuesDo: [:aKey :aValue | 		word := ''.		temp := OrderedCollection new.		aValue do: [:a | (a asString ~= ' ') ifTrue: [word := word , a asString] ifFalse: [ temp add: word. word := '' ] ].		(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].	highestSuitStreak := temp.	"	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak]."	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 11:49' prior: 33843253!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |suitStreak := OrderedCollection new.newList :=  OrderedCollection new.dataInHand := Dictionary new.dataInHand at: 'C' put: ''. dataInHand at: 'D' put: ''. dataInHand at: 'H' put: ''. dataInHand at: 'S' put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	dataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , ' ' )]. 	suitStreak := OrderedCollection new.	max := 0.		dataInHand keysAndValuesDo: [:aKey :aValue | 		word := ''.		temp := OrderedCollection new.		aValue do: [:a | (a asString ~= ' ') ifTrue: [word := word , a asString] ifFalse: [ temp add: word. word := '' ] ].		(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].	suitStreak := temp.	"	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak]."	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 11:49' prior: 33844545!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |suitStreak := OrderedCollection new.newList :=  OrderedCollection new.dataInHand := Dictionary new.dataInHand at: 'C' put: ''. dataInHand at: 'D' put: ''. dataInHand at: 'H' put: ''. dataInHand at: 'S' put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	dataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , ' ' )]. 	suitStreak := OrderedCollection new.	max := 0.		dataInHand keysAndValuesDo: [:aKey :aValue | 		word := ''.		temp := OrderedCollection new.		aValue do: [:a | (a asString ~= ' ') ifTrue: [word := word , a asString] ifFalse: [ temp add: word. word := '' ] ].		(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].	highestSuitStreak := suitStreak.	"	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak]."	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 12:03' prior: 33840401!getHighestValueStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |	valueStreak := OrderedCollection new.	newList :=  OrderedCollection new.	Transcript show: 'input'; cr.	Transcript show: streaks; cr.	dataInHand := Dictionary new. 	1 to: 13 do: [ :i | dataInHand at: i put: newList].		2 to: streaks size do: [ :i | 		previousCard := streaks at: (i-1).		previous := previousCard copyFrom: 1 to: (previousCard size-1).		card := streaks at: i.		current := card copyFrom: 1 to: (card size-1).		(previous asNumber == current asNumber)			ifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]			ifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].	(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].	valueStreak := OrderedCollection new.	maxCount := 0.	maxVal := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		( ( ( aKey asNumber ~= 1 & (aKey asNumber > maxVal asNumber) ) | (aKey asNumber == 1) ) & (aValue size >= maxCount) ) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue] ].		highestValueStreak := valueStreak.	^highestValueStreak! !Object subclass: #Poker	instanceVariableNames: 'hand hand2'	classVariableNames: ''	package: 'CPS506'!!Poker methodsFor: 'sorting' stamp: 'MagdalenaDhima 1/31/2021 12:13' prior: 33821542!sort: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| threeDigits twoDigits sorted aces |	threeDigits := SortedCollection new. twoDigits := SortedCollection new.1 to: 9 do: [ :i | ((shuf at: i) size == 3) ifTrue: [threeDigits add: (shuf at: i)] ifFalse: [twoDigits add: (shuf at: i)]. ].sorted := (twoDigits asArray) , (threeDigits asArray).aces := sorted select: [:a |  (a copyFrom: 1 to: (a size-1)) asNumber == 1 ].sorted := sorted reject: [:a |  (a copyFrom: 1 to: (a size-1)) asNumber == 1 ].sorted := sorted , aces.Transcript show: sorted; cr.^sorted! !!Poker methodsFor: 'as yet unclassified' stamp: 'MagdalenaDhima 1/31/2021 12:20'!divideHands: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| temporary variable names |	hand := SortedCollection new. 	hand2 := SortedCollection new. 	1 to: 4 do: [ :i | (i \\ 2 == 1) ifTrue: [ hand add: (shuf at: i) ] ifFalse: [ hand2 add: (shuf at: i) ] ].	5 to: 9 do: [ :i | hand add: (shuf at: i). hand2 add: (shuf at: i) ].! !!Poker methodsFor: 'as yet unclassified' stamp: 'MagdalenaDhima 1/31/2021 12:20' prior: 33849451!divideHands: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					hand := SortedCollection new. 	hand2 := SortedCollection new. 	1 to: 4 do: [ :i | (i \\ 2 == 1) ifTrue: [ hand add: (shuf at: i) ] ifFalse: [ hand2 add: (shuf at: i) ] ].	5 to: 9 do: [ :i | hand add: (shuf at: i). hand2 add: (shuf at: i) ].! !----SNAPSHOT----2021-01-31T12:20:36.544003-05:00 Pharo 8.0 - 64bit (stable).image priorSource: 270151!----SNAPSHOT----2021-01-31T12:20:54.650003-05:00 game1.image priorSource: 295892!----SNAPSHOT----2021-01-31T12:20:59.671003-05:00 game1.image priorSource: 295996!!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 12:26' prior: 33847128!getHighestValueStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |	valueStreak := OrderedCollection new.	newList :=  OrderedCollection new.	dataInHand := Dictionary new. 	1 to: 13 do: [ :i | dataInHand at: i put: newList].		2 to: streaks size do: [ :i | 		previousCard := streaks at: (i-1).		previous := previousCard copyFrom: 1 to: (previousCard size-1).		card := streaks at: i.		current := card copyFrom: 1 to: (card size-1).		(previous asNumber == current asNumber)			ifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]			ifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].	(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].	valueStreak := OrderedCollection new.	maxCount := 0.	maxVal := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		( ( ( aKey asNumber ~= 1 & (aKey asNumber > maxVal asNumber) ) | (aKey asNumber == 1) ) & (aValue size >= maxCount) ) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue] ].		highestValueStreak := valueStreak.	^highestValueStreak! !Object subclass: #Poker	instanceVariableNames: 'hand1 hand2'	classVariableNames: ''	package: 'CPS506'!!Poker methodsFor: 'actions' stamp: 'MagdalenaDhima 1/31/2021 12:29' prior: 33849952!divideHands: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					hand1 := SortedCollection new. 	hand2 := SortedCollection new. 	1 to: 4 do: [ :i | (i \\ 2 == 1) ifTrue: [ hand1 add: (shuf at: i) ] ifFalse: [ hand2 add: (shuf at: i) ] ].	5 to: 9 do: [ :i | hand1 add: (shuf at: i). hand2 add: (shuf at: i) ].! !Poker removeSelector: #getData!Poker removeSelector: #returnSuitCards:!!Poker methodsFor: 'actions' stamp: 'MagdalenaDhima 1/31/2021 12:33' prior: 33817232!convert: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| hand temp values suits output val |	hand := Array new: 9.	values := #('1' '2' '3' '4' '5' '6' '7' '8' '9' '10' '11' '12' '13').	suits := #('C' 'D' 'H' 'S').	1 to: 9 do: [ :i | 		val := shuf at: i.		temp := val % 13.		output := (temp == 0) 			ifFalse: [values at: temp]			ifTrue: [values at: 13]		. 		temp := val-1 // 13 +1 floor. 		output := output , (suits at: temp). 		hand at: i put: output.	].^hand! !!Poker methodsFor: 'as yet unclassified' stamp: 'MagdalenaDhima 1/31/2021 13:15'!sizeCheck: givenSize firstList: l1  secondList: l2	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| result |	(l1 size == givenSize & (l2 size == givenSize)) ifTrue: [ 		( (l1 includes: 1 | (l1 max asNumber > l2 max asNumber)) & (l2 includes: 1) not ) 				ifTrue: [ result := l1 ]		 		ifFalse: [ result := l2 ]  ]		ifFalse: [(l1 size == givenSize) ifTrue: [result := l1]. (l2 size == givenSize) ifTrue: [ result := l1 ] ].		^result! !!Poker methodsFor: 'as yet unclassified' stamp: 'MagdalenaDhima 1/31/2021 13:24' prior: 33853387!sizeCheck: givenSize firstList: l1  secondList: l2	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| result |	result := OrderedCollection new.	(l1 size == givenSize & (l2 size == givenSize)) ifTrue: [ 		( (l1 includes: 1 | (l1 max asNumber > l2 max asNumber)) & (l2 includes: 1) not ) 				ifTrue: [ result := l1 ]		 		ifFalse: [ result := l2 ]  ]		ifFalse: [(l1 size == givenSize) ifTrue: [result := l1]. (l2 size == givenSize) ifTrue: [ result := l1 ] ].		^result! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 13:31' prior: 33829032!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.		sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted1.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].		flushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new.	valueStreak1b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp1 at: i ) ] ].		"----------------------"		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].		(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].	(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].	(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'sorting' stamp: 'MagdalenaDhima 1/31/2021 13:32' prior: 33848730!sort: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| threeDigits twoDigits sorted aces |	threeDigits := SortedCollection new. twoDigits := SortedCollection new.1 to: (shuf size) do: [ :i | ((shuf at: i) size == 3) ifTrue: [threeDigits add: (shuf at: i)] ifFalse: [twoDigits add: (shuf at: i)]. ].sorted := (twoDigits asArray) , (threeDigits asArray).aces := sorted select: [:a |  (a copyFrom: 1 to: (a size-1)) asNumber == 1 ].sorted := sorted reject: [:a |  (a copyFrom: 1 to: (a size-1)) asNumber == 1 ].sorted := sorted , aces.Transcript show: sorted; cr.^sorted! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 13:40' prior: 33854609!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted1.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].		flushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new.	valueStreak1b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].		(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].	(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].	(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 13:42' prior: 33859604!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted1.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].		flushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new.	valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].		(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].	(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].	(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 13:43' prior: 33863866!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted1.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].		flushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new.	valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		Transcript show: valueStreak2b; cr.		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].		(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].	(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].	(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 13:44' prior: 33868128!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted1.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].		flushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new.	valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].		Transcript show: valueStreak2b; cr.	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].	(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].	(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 13:46' prior: 33872429!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted1.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].		flushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new.	valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.		Transcript show: valueStreak2b; cr.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].		(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].	(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].	(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 13:46' prior: 33876727!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted1.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].		flushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new.	valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.		Transcript show: valueStreak; cr.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].		(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].	(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].	(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 13:46' prior: 33881027!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted1.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].		flushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new.	valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.	Transcript show: valueStreakb; cr.		(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].		(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].	(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].	(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 13:49' prior: 33885325!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted1.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].		flushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new.	valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	Transcript show: valueStreakb; cr.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].		(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].	(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].	(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 13:52' prior: 33889623!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted1.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].		flushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new.	valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	Transcript show: temp2 ; cr.	Transcript show: valueStreakb; cr.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].		(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].	(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].	(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 13:56' prior: 33893921!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted1.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].		flushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new.	valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	Transcript show: temp2 ; cr.	Transcript show: valueStreakb; cr.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].		(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].	(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].	(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 13:56' prior: 33898249!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted1.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].		flushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new.	valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	Transcript show: temp2 ; cr.	Transcript show: valueStreak2b; cr.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].		(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].	(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].	(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'as yet unclassified' stamp: 'MagdalenaDhima 1/31/2021 14:00' prior: 33853986!sizeCheck: givenSize firstList: l1  secondList: l2	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| result |	result := OrderedCollection new.	(l1 size == givenSize & (l2 size == givenSize)) ifTrue: [ 		( (l1 includes: 1 | (l1 asArray max asNumber > l2 asArray max asNumber)) & (l2 includes: 1) not ) 				ifTrue: [ result := l1 ]		 		ifFalse: [ result := l2 ]  ]		ifFalse: [(l1 size == givenSize) ifTrue: [result := l1]. (l2 size == givenSize) ifTrue: [ result := l1 ] ].		^result! !!Poker methodsFor: 'as yet unclassified' stamp: 'MagdalenaDhima 1/31/2021 14:07' prior: 33907044!sizeCheck: givenSize firstList: l1  secondList: l2	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| result l1_max l2_max |		l1_max := 0. l2_max := 0.	(l1 isEmpty not) ifTrue: [ l1_max := l1 inject: 0 into: [:a :c | (a asNumber > c asNumber )] ].	(l2 isEmpty not) ifTrue: [ l2_max := l2 inject: 0 into: [:a :c | (a asNumber > c asNumber )] ].		result := OrderedCollection new.	(l1 size == givenSize & (l2 size == givenSize)) ifTrue: [ 		( (l1 includes: 1 | (l1_max > l2_max)) & (l2 includes: 1) not ) 				ifTrue: [ result := l1 ]		 		ifFalse: [ result := l2 ]  ]		ifFalse: [(l1 size == givenSize) ifTrue: [result := l1]. (l2 size == givenSize) ifTrue: [ result := l1 ] ].		^result! !!Poker methodsFor: 'as yet unclassified' stamp: 'MagdalenaDhima 1/31/2021 14:08' prior: 33907693!sizeCheck: givenSize firstList: l1  secondList: l2	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| result l1_max l2_max |		l1_max := 0. l2_max := 0.	(l1 isEmpty not) ifTrue: [ l1_max := l1 inject: 0 into: [:a :c | Transcript show: a class. (a > c )] ].	(l2 isEmpty not) ifTrue: [ l2_max := l2 inject: 0 into: [:a :c | (a > c )] ].		result := OrderedCollection new.	(l1 size == givenSize & (l2 size == givenSize)) ifTrue: [ 		( (l1 includes: 1 | (l1_max > l2_max)) & (l2 includes: 1) not ) 				ifTrue: [ result := l1 ]		 		ifFalse: [ result := l2 ]  ]		ifFalse: [(l1 size == givenSize) ifTrue: [result := l1]. (l2 size == givenSize) ifTrue: [ result := l1 ] ].		^result! !!Poker methodsFor: 'as yet unclassified' stamp: 'MagdalenaDhima 1/31/2021 14:08' prior: 33908547!sizeCheck: givenSize firstList: l1  secondList: l2	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| result l1_max l2_max |		l1_max := 0. l2_max := 0.	(l1 isEmpty not) ifTrue: [ l1_max := l1 inject: 0 into: [:a :c | (a > c )] ].	(l2 isEmpty not) ifTrue: [ l2_max := l2 inject: 0 into: [:a :c | (a > c )] ].		result := OrderedCollection new.	(l1 size == givenSize & (l2 size == givenSize)) ifTrue: [ 		( (l1 includes: 1 | (l1_max > l2_max)) & (l2 includes: 1) not ) 				ifTrue: [ result := l1 ]		 		ifFalse: [ result := l2 ]  ]		ifFalse: [(l1 size == givenSize) ifTrue: [result := l1]. (l2 size == givenSize) ifTrue: [ result := l1 ] ].		^result! !!Poker methodsFor: 'as yet unclassified' stamp: 'MagdalenaDhima 1/31/2021 14:10' prior: 33909391!sizeCheck: givenSize firstList: l1  secondList: l2	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| result l1_max l2_max |		l1_max := 0. l2_max := 0.	(l1 isEmpty not) ifTrue: [ l1_max := l1 inject: 0 into: [:a :c | (a asNumber > c asNumber) ifTrue: [a]   ifFalse: [c]]].	(l2 isEmpty not) ifTrue: [ l2_max := l2 inject: 0 into: [:a :c | (a asNumber > c asNumber) ifTrue: [a]   ifFalse: [c]]].	result := OrderedCollection new.	(l1 size == givenSize & (l2 size == givenSize)) ifTrue: [ 		( (l1 includes: 1 | (l1_max > l2_max)) & (l2 includes: 1) not ) 				ifTrue: [ result := l1 ]		 		ifFalse: [ result := l2 ]  ]		ifFalse: [(l1 size == givenSize) ifTrue: [result := l1]. (l2 size == givenSize) ifTrue: [ result := l1 ] ].		^result! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 14:11' prior: 33910209!sizeCheck: givenSize firstList: l1 secondList: l2	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"	| result l1_max l2_max |	l1_max := 0.	l2_max := 0.	l1 isNotEmpty		ifTrue: [ l1_max := l1				inject: 0				into: [ :a :c | 					a asNumber > c asNumber						ifTrue: [ a ]						ifFalse: [ c ] ] ].	l2 isEmpty not		ifTrue: [ l2_max := l2				inject: 0				into: [ :a :c | 					a asNumber > c asNumber						ifTrue: [ a ]						ifFalse: [ c ] ] ].	result := OrderedCollection new.	l1 size == givenSize & (l2 size == givenSize)		ifTrue: [ (l1 includes: 1 | (l1_max > l2_max)) & (l2 includes: 1) not				ifTrue: [ result := l1 ]				ifFalse: [ result := l2 ] ]		ifFalse: [ l1 size == givenSize				ifTrue: [ result := l1 ].			l2 size == givenSize				ifTrue: [ result := l1 ] ].	^ result! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 14:12' prior: 33911103!sizeCheck: givenSize firstList: l1 secondList: l2	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"	| result l1_max l2_max |	l1_max := 0.	l2_max := 0.	l1 isNotEmpty		ifTrue: [ l1_max := l1				inject: 0				into: [ :a :c | 					a asNumber > c asNumber						ifTrue: [ a ]						ifFalse: [ c ] ] ].	l2 isEmpty		ifFalse: [ l2_max := l2				inject: 0				into: [ :a :c | 					a asNumber > c asNumber						ifTrue: [ a ]						ifFalse: [ c ] ] ].	result := OrderedCollection new.	l1 size == givenSize & (l2 size == givenSize)		ifTrue: [ (l1 includes: 1 | (l1_max > l2_max)) & (l2 includes: 1) not				ifTrue: [ result := l1 ]				ifFalse: [ result := l2 ] ]		ifFalse: [ l1 size == givenSize				ifTrue: [ result := l1 ].			l2 size == givenSize				ifTrue: [ result := l1 ] ].	^ result! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 14:12' prior: 33912046!sizeCheck: givenSize firstList: l1 secondList: l2	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"	| result l1_max l2_max |	l1_max := 0.	l2_max := 0.	l1 isNotEmpty		ifTrue: [ l1_max := l1				inject: 0				into: [ :a :c | 					a asNumber > c asNumber						ifTrue: [ a ]						ifFalse: [ c ] ] ].	l2 isEmpty		ifFalse: [ l2_max := l2				inject: 0				into: [ :a :c | 					a asNumber > c asNumber						ifTrue: [ a ]						ifFalse: [ c ] ] ].	result := OrderedCollection new.	l1 size == givenSize & (l2 size == givenSize)		ifTrue: [ result := (l1 includes: 1 | (l1_max > l2_max))				& (l2 includes: 1) not				ifTrue: [ l1 ]				ifFalse: [ l2 ] ]		ifFalse: [ l1 size == givenSize				ifTrue: [ result := l1 ].			l2 size == givenSize				ifTrue: [ result := l1 ] ].	^ result! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 14:12' prior: 33912986!sizeCheck: givenSize firstList: l1 secondList: l2	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"	| result l1_max l2_max |	l1_max := 0.	l2_max := 0.	l1 isNotEmpty		ifTrue: [ l1_max := l1				inject: 0				into: [ :a :c | 					a asNumber > c asNumber						ifTrue: [ a ]						ifFalse: [ c ] ] ].	l2 isEmpty		ifFalse: [ l2_max := l2				inject: 0				into: [ :a :c | 					a asNumber > c asNumber						ifTrue: [ a ]						ifFalse: [ c ] ] ].					result := OrderedCollection new.	l1 size == givenSize & (l2 size == givenSize)		ifTrue: [ (l1 includes: 1 | (l1_max > l2_max)) & ( (l2 includes: 1) not )				ifTrue: [ result := l1 ]				ifFalse: [ result := l2 ] ]		ifFalse: [ l1 size == givenSize				ifTrue: [ result := l1 ].			l2 size == givenSize				ifTrue: [ result := l1 ] ].	^ result! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 14:13' prior: 33913920!sizeCheck: givenSize firstList: l1 secondList: l2	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"	| result l1_max l2_max |	l1_max := 0.	l2_max := 0.	l1 isNotEmpty		ifTrue: [ l1_max := l1				inject: 0				into: [ :a :c | 					a asNumber > c asNumber						ifTrue: [ a ]						ifFalse: [ c ] ] ].	l2 isEmpty		ifFalse: [ l2_max := l2				inject: 0				into: [ :a :c | 					a asNumber > c asNumber						ifTrue: [ a ]						ifFalse: [ c ] ] ].	result := OrderedCollection new.	l1 size == givenSize & (l2 size == givenSize)		ifTrue: [ result := (l1 includes: 1 | (l1_max > l2_max))				& (l2 includes: 1) not				ifTrue: [ l1 ]				ifFalse: [ l2 ] ]		ifFalse: [ l1 size == givenSize				ifTrue: [ result := l1 ].			l2 size == givenSize				ifTrue: [ result := l1 ] ].	^ result! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 14:14' prior: 33914869!sizeCheck: givenSize firstList: l1 secondList: l2	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"	| result l1_max l2_max |	l1_max := 0.	l2_max := 0.	l1 isNotEmpty		ifTrue: [ l1_max := l1				inject: 0				into: [ :a :c | 					a asNumber > c asNumber						ifTrue: [ a ]						ifFalse: [ c ] ] ].	l2 isEmpty		ifFalse: [ l2_max := l2				inject: 0				into: [ :a :c | 					a asNumber > c asNumber						ifTrue: [ a ]						ifFalse: [ c ] ] ].	result := OrderedCollection new.	l1 size == givenSize & (l2 size == givenSize)		ifTrue: [ result := (l1 includes: 1 | (l1_max > l2_max))				& (l2 includes: 1) not				ifTrue: [ l1 ]				ifFalse: [ l2 ] ]		ifFalse: [ l1 size == givenSize				ifTrue: [ result := l1 ].			l2 size == givenSize				ifTrue: [ result := l2 ] ].	^ result! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 14:16' prior: 33915803!sizeCheck: givenSize firstList: l1 secondList: l2	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"	| result l1_max l2_max |	l1_max := 0.	l2_max := 0.	l1 isNotEmpty		ifTrue: [ l1_max := l1				inject: 0				into: [ :a :c | 					a asNumber > c asNumber						ifTrue: [ a ]						ifFalse: [ c ] ] ].	l2 isEmpty		ifFalse: [ l2_max := l2				inject: 0				into: [ :a :c | 					a asNumber > c asNumber						ifTrue: [ a ]						ifFalse: [ c ] ] ].					Transcript show: l1_max; show: l2_max; cr.	result := OrderedCollection new.	l1 size == givenSize & (l2 size == givenSize)		ifTrue: [ result := (l1 includes: 1 | (l1_max > l2_max))				& (l2 includes: 1) not				ifTrue: [ l1 ]				ifFalse: [ l2 ] ]		ifFalse: [ l1 size == givenSize				ifTrue: [ result := l1 ].			l2 size == givenSize				ifTrue: [ result := l2 ] ].	^ result! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 14:20' prior: 33916737!sizeCheck: givenSize firstList: l1 secondList: l2	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"	| result l1_max l2_max |	l1_max := 0.	l2_max := 0.	l1 isNotEmpty		ifTrue: [ l1_max := l1				inject: 0				into: [ :a :c | 					(a copyFrom: 1 to: (a size-1) ) asNumber > (c copyFrom: 1 to: (c size-1) ) asNumber						ifTrue: [ (a copyFrom: 1 to: (a size-1) asNumber) ]						ifFalse: [ (c copyFrom: 1 to: (c size-1) ) asNumber ] ] ].	l2 isEmpty		ifFalse: [ l2_max := l2				inject: 0				into: [ :a :c | 					(a copyFrom: 1 to: (a size-1) ) asNumber > (c copyFrom: 1 to: (c size-1) ) asNumber						ifTrue: [ (a copyFrom: 1 to: (a size-1) asNumber) ]						ifFalse: [ (c copyFrom: 1 to: (c size-1) ) asNumber ] ] ].					Transcript show: l1_max; show: l2_max; cr.	result := OrderedCollection new.	l1 size == givenSize & (l2 size == givenSize)		ifTrue: [ result := (l1 includes: 1 | (l1_max > l2_max))				& (l2 includes: 1) not				ifTrue: [ l1 ]				ifFalse: [ l2 ] ]		ifFalse: [ l1 size == givenSize				ifTrue: [ result := l1 ].			l2 size == givenSize				ifTrue: [ result := l2 ] ].	^ result! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 14:22' prior: 33917720!sizeCheck: givenSize firstList: l1 secondList: l2	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"	| result l1_max l2_max |	l1_max := 0.	l2_max := 0.	l1 isNotEmpty		ifTrue: [ l1_max := l1				inject: 0				into: [ :a :c | 					Transcript show: a; cr.					(a copyFrom: 1 to: (a size-1) ) asNumber > (c copyFrom: 1 to: (c size-1) ) asNumber						ifTrue: [ (a copyFrom: 1 to: (a size-1) asNumber) ]						ifFalse: [ (c copyFrom: 1 to: (c size-1) ) asNumber ] ] ].	l2 isEmpty		ifFalse: [ l2_max := l2				inject: 0				into: [ :a :c | 					(a copyFrom: 1 to: (a size-1) ) asNumber > (c copyFrom: 1 to: (c size-1) ) asNumber						ifTrue: [ (a copyFrom: 1 to: (a size-1) asNumber) ]						ifFalse: [ (c copyFrom: 1 to: (c size-1) ) asNumber ] ] ].					Transcript show: l1_max; show: l2_max; cr.	result := OrderedCollection new.	l1 size == givenSize & (l2 size == givenSize)		ifTrue: [ result := (l1 includes: 1 | (l1_max > l2_max))				& (l2 includes: 1) not				ifTrue: [ l1 ]				ifFalse: [ l2 ] ]		ifFalse: [ l1 size == givenSize				ifTrue: [ result := l1 ].			l2 size == givenSize				ifTrue: [ result := l2 ] ].	^ result! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 14:22' prior: 33918977!sizeCheck: givenSize firstList: l1 secondList: l2	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"	| result l1_max l2_max |	l1_max := 0.	l2_max := 0.	l1 isNotEmpty		ifTrue: [ l1_max := l1				inject: 0				into: [ :a :c | 					Transcript show: c; cr.					(a copyFrom: 1 to: (a size-1) ) asNumber > (c copyFrom: 1 to: (c size-1) ) asNumber						ifTrue: [ (a copyFrom: 1 to: (a size-1) asNumber) ]						ifFalse: [ (c copyFrom: 1 to: (c size-1) ) asNumber ] ] ].	l2 isEmpty		ifFalse: [ l2_max := l2				inject: 0				into: [ :a :c | 					(a copyFrom: 1 to: (a size-1) ) asNumber > (c copyFrom: 1 to: (c size-1) ) asNumber						ifTrue: [ (a copyFrom: 1 to: (a size-1) asNumber) ]						ifFalse: [ (c copyFrom: 1 to: (c size-1) ) asNumber ] ] ].					Transcript show: l1_max; show: l2_max; cr.	result := OrderedCollection new.	l1 size == givenSize & (l2 size == givenSize)		ifTrue: [ result := (l1 includes: 1 | (l1_max > l2_max))				& (l2 includes: 1) not				ifTrue: [ l1 ]				ifFalse: [ l2 ] ]		ifFalse: [ l1 size == givenSize				ifTrue: [ result := l1 ].			l2 size == givenSize				ifTrue: [ result := l2 ] ].	^ result! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 14:23' prior: 33920263!sizeCheck: givenSize firstList: l1 secondList: l2	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"	| result l1_max l2_max |	l1_max := 0.	l2_max := 0.	l1 isNotEmpty		ifTrue: [ l1_max := l1				inject: 0				into: [ :a :c | 					Transcript show: 'h', c; cr.					(a copyFrom: 1 to: (a size-1) ) asNumber > (c copyFrom: 1 to: (c size-1) ) asNumber						ifTrue: [ (a copyFrom: 1 to: (a size-1) asNumber) ]						ifFalse: [ (c copyFrom: 1 to: (c size-1) ) asNumber ] ] ].	l2 isEmpty		ifFalse: [ l2_max := l2				inject: 0				into: [ :a :c | 					(a copyFrom: 1 to: (a size-1) ) asNumber > (c copyFrom: 1 to: (c size-1) ) asNumber						ifTrue: [ (a copyFrom: 1 to: (a size-1) asNumber) ]						ifFalse: [ (c copyFrom: 1 to: (c size-1) ) asNumber ] ] ].					Transcript show: l1_max; show: l2_max; cr.	result := OrderedCollection new.	l1 size == givenSize & (l2 size == givenSize)		ifTrue: [ result := (l1 includes: 1 | (l1_max > l2_max))				& (l2 includes: 1) not				ifTrue: [ l1 ]				ifFalse: [ l2 ] ]		ifFalse: [ l1 size == givenSize				ifTrue: [ result := l1 ].			l2 size == givenSize				ifTrue: [ result := l2 ] ].	^ result! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 14:23' prior: 33921549!sizeCheck: givenSize firstList: l1 secondList: l2	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"	| result l1_max l2_max |	l1_max := 0.	l2_max := 0.	l1 isNotEmpty		ifTrue: [ l1_max := l1				inject: 0				into: [ :a :c | 					Transcript show: 'h', a; cr.					(a copyFrom: 1 to: (a size-1) ) asNumber > (c copyFrom: 1 to: (c size-1) ) asNumber						ifTrue: [ (a copyFrom: 1 to: (a size-1) asNumber) ]						ifFalse: [ (c copyFrom: 1 to: (c size-1) ) asNumber ] ] ].	l2 isEmpty		ifFalse: [ l2_max := l2				inject: 0				into: [ :a :c | 					(a copyFrom: 1 to: (a size-1) ) asNumber > (c copyFrom: 1 to: (c size-1) ) asNumber						ifTrue: [ (a copyFrom: 1 to: (a size-1) asNumber) ]						ifFalse: [ (c copyFrom: 1 to: (c size-1) ) asNumber ] ] ].					Transcript show: l1_max; show: l2_max; cr.	result := OrderedCollection new.	l1 size == givenSize & (l2 size == givenSize)		ifTrue: [ result := (l1 includes: 1 | (l1_max > l2_max))				& (l2 includes: 1) not				ifTrue: [ l1 ]				ifFalse: [ l2 ] ]		ifFalse: [ l1 size == givenSize				ifTrue: [ result := l1 ].			l2 size == givenSize				ifTrue: [ result := l2 ] ].	^ result! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 14:26' prior: 33922840!sizeCheck: givenSize firstList: l1 secondList: l2	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"	| result l1_max l2_max |	l1_max := 0.	l2_max := 0.	l1 isNotEmpty		ifTrue: [ l1_max := l1				inject: 0				into: [ :a :c | 					a > (c copyFrom: 1 to: (c size-1) ) asNumber						ifTrue: [ a ]						ifFalse: [ (c copyFrom: 1 to: (c size-1) ) asNumber ] ] ].	l2 isEmpty		ifFalse: [ l2_max := l2				inject: 0				into: [ :a :c | 					 a > (c copyFrom: 1 to: (c size-1) ) asNumber						ifTrue: [ a ]						ifFalse: [ (c copyFrom: 1 to: (c size-1) ) asNumber ] ] ].					Transcript show: l1_max; show: l2_max; cr.	result := OrderedCollection new.	l1 size == givenSize & (l2 size == givenSize)		ifTrue: [ result := (l1 includes: 1 | (l1_max > l2_max))				& (l2 includes: 1) not				ifTrue: [ l1 ]				ifFalse: [ l2 ] ]		ifFalse: [ l1 size == givenSize				ifTrue: [ result := l1 ].			l2 size == givenSize				ifTrue: [ result := l2 ] ].	^ result! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 14:27' prior: 33924131!sizeCheck: givenSize firstList: l1 secondList: l2	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"	| result l1_max l2_max |	l1_max := 0.	l2_max := 0.	l1 isNotEmpty		ifTrue: [ l1_max := l1				inject: 0				into: [ :a :c | 					a > (c copyFrom: 1 to: (c size-1) ) asNumber						ifTrue: [ a ]						ifFalse: [ (c copyFrom: 1 to: (c size-1) ) asNumber ] ] ].	l2 isEmpty		ifFalse: [ l2_max := l2				inject: 0				into: [ :a :c | 					 a > (c copyFrom: 1 to: (c size-1) ) asNumber						ifTrue: [ a ]						ifFalse: [ (c copyFrom: 1 to: (c size-1) ) asNumber ] ] ].					Transcript show: l1_max class; show: l2_max; cr.	result := OrderedCollection new.	l1 size == givenSize & (l2 size == givenSize)		ifTrue: [ result := (l1 includes: 1 | (l1_max > l2_max))				& (l2 includes: 1) not				ifTrue: [ l1 ]				ifFalse: [ l2 ] ]		ifFalse: [ l1 size == givenSize				ifTrue: [ result := l1 ].			l2 size == givenSize				ifTrue: [ result := l2 ] ].	^ result! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 14:27' prior: 33925235!sizeCheck: givenSize firstList: l1 secondList: l2	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"	| result l1_max l2_max |	l1_max := 0.	l2_max := 0.	l1 isNotEmpty		ifTrue: [ l1_max := l1				inject: 0				into:					[ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].	l2 isEmpty		ifFalse: [ l2_max := l2				inject: 0				into: [ :a :c | 					a > (c copyFrom: 1 to: c size - 1) asNumber						ifTrue: [ a ]						ifFalse: [ (c copyFrom: 1 to: c size - 1) asNumber ] ] ].	Transcript		show: l1_max class;		show: l2_max;		cr.	result := OrderedCollection new.	l1 size == givenSize & (l2 size == givenSize)		ifTrue: [ result := (l1 includes: 1 | (l1_max > l2_max))				& (l2 includes: 1) not				ifTrue: [ l1 ]				ifFalse: [ l2 ] ]		ifFalse: [ l1 size == givenSize				ifTrue: [ result := l1 ].			l2 size == givenSize				ifTrue: [ result := l2 ] ].	^ result! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 14:29' prior: 33926345!sizeCheck: givenSize firstList: l1 secondList: l2	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"	| result l1_max l2_max |	l1_max := 0.	l2_max := 0.	l1 isNotEmpty		ifTrue: [ l1_max := l1				inject: 0				into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].	l2 isEmpty		ifFalse: [ l2_max := l2				inject: 0				into:					[ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].	Transcript		show: l1_max class;		show: l2_max;		cr.	result := OrderedCollection new.	l1 size == givenSize & (l2 size == givenSize)		ifTrue: [ result := (l1 includes: 1 | (l1_max > l2_max))				& (l2 includes: 1) not				ifTrue: [ l1 ]				ifFalse: [ l2 ] ]		ifFalse: [ l1 size == givenSize				ifTrue: [ result := l1 ].			l2 size == givenSize				ifTrue: [ result := l2 ] ].	^ result! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 14:36' prior: 33927374!sizeCheck: givenSize firstList: l1 secondList: l2	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"	| result l1_max l2_max ace1 ace2 |	l1_max := 0.	l2_max := 0.	l1 isNotEmpty		ifTrue: [ l1_max := l1				inject: 0				into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].	l2 isEmpty		ifFalse: [ l2_max := l2				inject: 0				into:					[ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].	Transcript		show: l1_max class;		show: l2_max;		cr.	ace1 := l1 detect: [:a | (a copyFrom: 1 to: a size - 1) asNumber == 1 ] ifNone: [0].	ace2 := l2 detect: [:a | (a copyFrom: 1 to: a size - 1) asNumber == 1 ] ifNone: [0].			Transcript		show: ace1 class;		show: ace2;		cr.			result := OrderedCollection new.	l1 size == givenSize & (l2 size == givenSize)		ifTrue: [ result := (l1 includes: 1 | (l1_max > l2_max))				& (l2 includes: 1) not				ifTrue: [ l1 ]				ifFalse: [ l2 ] ]		ifFalse: [ l1 size == givenSize				ifTrue: [ result := l1 ].			l2 size == givenSize				ifTrue: [ result := l2 ] ].	^ result! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 14:40' prior: 33928321!sizeCheck: givenSize firstList: l1 secondList: l2	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"	| result l1_max l2_max aceInl1 aceInl2 |	l1_max := 0.	l2_max := 0.	l1 isNotEmpty		ifTrue: [ l1_max := l1				inject: 0				into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].	l2 isEmpty		ifFalse: [ l2_max := l2				inject: 0				into:					[ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].	Transcript		show: l1_max class;		show: l2_max;		cr.	aceInl1 := l1 detect: [:a | (a copyFrom: 1 to: a size - 1) asNumber == 1 ] ifNone: [0].	aceInl2 := l2 detect: [:a | (a copyFrom: 1 to: a size - 1) asNumber == 1 ] ifNone: [0].			result := OrderedCollection new.	l1 size == givenSize & (l2 size == givenSize)		ifTrue: [ result := ( aceInl1 == 1 | (l1_max > l2_max))				& (aceInl2 == 0)				ifTrue: [ l1 ]				ifFalse: [ l2 ] ]		ifFalse: [ l1 size == givenSize				ifTrue: [ result := l1 ].			l2 size == givenSize				ifTrue: [ result := l2 ] ].	^ result! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 14:40' prior: 33929508!sizeCheck: givenSize firstList: l1 secondList: l2	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"	| result l1_max l2_max aceInl1 aceInl2 |	l1_max := 0.	l2_max := 0.	l1 isNotEmpty		ifTrue: [ l1_max := l1				inject: 0				into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].	l2 isEmpty		ifFalse: [ l2_max := l2				inject: 0				into:					[ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].	aceInl1 := l1 detect: [:a | (a copyFrom: 1 to: a size - 1) asNumber == 1 ] ifNone: [0].	aceInl2 := l2 detect: [:a | (a copyFrom: 1 to: a size - 1) asNumber == 1 ] ifNone: [0].			result := OrderedCollection new.	l1 size == givenSize & (l2 size == givenSize)		ifTrue: [ result := ( aceInl1 == 1 | (l1_max > l2_max))				& (aceInl2 == 0)				ifTrue: [ l1 ]				ifFalse: [ l2 ] ]		ifFalse: [ l1 size == givenSize				ifTrue: [ result := l1 ].			l2 size == givenSize				ifTrue: [ result := l2 ] ].	Transcript show: result class; show: result;		cr.	^ result! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 14:42' prior: 33930645!sizeCheck: givenSize firstList: l1 secondList: l2	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"	| result l1_max l2_max aceInl1 aceInl2 |	l1_max := 0.	l2_max := 0.	l1 isNotEmpty		ifTrue: [ l1_max := l1				inject: 0				into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].	l2 isEmpty		ifFalse: [ l2_max := l2				inject: 0				into:					[ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].	aceInl1 := l1 detect: [:a | (a copyFrom: 1 to: a size - 1) asNumber == 1 ] ifNone: [0].	aceInl2 := l2 detect: [:a | (a copyFrom: 1 to: a size - 1) asNumber == 1 ] ifNone: [0].			result := OrderedCollection new.	l1 size == givenSize & (l2 size == givenSize)		ifTrue: [ result := ( aceInl1 == 1 | (l1_max > l2_max))				& (aceInl2 == 0)				ifTrue: [ l1 ]				ifFalse: [ l2 ] ]		ifFalse: [ l1 size == givenSize				ifTrue: [ result := l1 ].			l2 size == givenSize				ifTrue: [ result := l2 ] ].	Transcript show: 'result'; show: result;		cr.	^ result! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 14:44' prior: 33902641!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted1.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].		flushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new.	valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	Transcript show: 'valueStreak'; show: valueStreak; cr.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.	Transcript show: 'valueStreakb'; show: valueStreakb; cr.		(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].		(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].	(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].	(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 14:48' prior: 33932909!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted1.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].		flushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new.	valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.	(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.	(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].	(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 14:49' prior: 33937349!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted1.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].		flushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new.	valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.	(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.	(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].		(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 14:54' prior: 33942032!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted1.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].		flushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new.	valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.	(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	Transcript show: flushOrSuitStreak.	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.	(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].		(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !----SNAPSHOT----2021-01-31T14:59:44.901003-05:00 game1.image priorSource: 296079!!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 15:03' prior: 33946717!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted1.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].		flushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new.	valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.	(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].		(flushOrSuitStreak size >= 5) ifTrue: [  	(flushOrSuitStreak size -4) to: (flushOrSuitStreak size) do: [ :i | flush add: (flushOrSuitStreak at: i) ]. 	flushOrSuitStreak := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.	(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].		(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 15:04' prior: 33951522!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted1.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].		flushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new.	valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.	(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].		(flushOrSuitStreak size >= 5) ifTrue: [  	(flushOrSuitStreak size -4) to: (flushOrSuitStreak size) do: [ :i | flush add: (flushOrSuitStreak at: i) ]. 	flushOrSuitStreak := flush ].	Transcript show: flushOrSuitStreak; cr.	Transcript show: ''; cr.	flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.	(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].		(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 15:05' prior: 33956399!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted1.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].		flushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new.	valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.	(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].		Transcript show: flushOrSuitStreak; cr.	(flushOrSuitStreak size >= 5) ifTrue: [  	(flushOrSuitStreak size -4) to: (flushOrSuitStreak size) do: [ :i | flush add: (flushOrSuitStreak at: i) ]. 	flushOrSuitStreak := flush ].	Transcript show: flushOrSuitStreak; cr.	Transcript show: ''; cr.	flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.	(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].		(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 15:08' prior: 33961341!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted1.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].		flushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new.	valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.	(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].			Transcript show: flushOrSuitStreak1; cr.	flush := OrderedCollection.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i) ]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].	Transcript show: flushOrSuitStreak1; cr.	Transcript show: ''; cr.		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.	(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].		(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 15:11' prior: 33966324!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted1.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].		flushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new.	valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.	(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].			Transcript show: flushOrSuitStreak1; cr.	flush := OrderedCollection.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | Transcript show: (flushOrSuitStreak1 at: i); cr. flush add: (flushOrSuitStreak1 at: i) ]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].	Transcript show: flushOrSuitStreak1; cr.	Transcript show: ''; cr.		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.	(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].		(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 15:13' prior: 33971568!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted1.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].		flushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new.	valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.	(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].			Transcript show: flushOrSuitStreak1; cr.	flush := OrderedCollection.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | Transcript show: (flushOrSuitStreak1 at: i); cr. flush add: (flushOrSuitStreak1 at: i). Transcript show: flush; cr.]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].	Transcript show: flushOrSuitStreak1; cr.	Transcript show: ''; cr.		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.	(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].		(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 15:14' prior: 33976861!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted1.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].		flushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new.	valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.	(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].			Transcript show: flushOrSuitStreak1; cr.	flush := OrderedCollection.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | Transcript show: flush; cr. flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].	Transcript show: flushOrSuitStreak1; cr.	Transcript show: ''; cr.		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.	(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].		(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 15:14' prior: 33982182!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted1.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].		flushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new.	valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.	(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].			Transcript show: flushOrSuitStreak1; cr.	flush := OrderedCollection.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | Transcript show: flush; cr. flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].	Transcript show: flushOrSuitStreak1; cr.	Transcript show: ''; cr.		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.	(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].		(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 15:14' prior: 33987453!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted1.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].		flushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new.	valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.	(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].			Transcript show: flushOrSuitStreak1; cr.	flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | Transcript show: flush; cr. flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].	Transcript show: flushOrSuitStreak1; cr.	Transcript show: ''; cr.		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.	(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].		(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 15:15' prior: 33992728!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted1.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].		flushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new.	valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.	(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].			Transcript show: flushOrSuitStreak1; cr.	flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | Transcript show: flush; cr. flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].	Transcript show: flushOrSuitStreak2; cr.	Transcript show: ''; cr.		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.	(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].		(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 15:15' prior: 33998007!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted1.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].		flushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new.	valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.	(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].			Transcript show: flushOrSuitStreak1; cr.	flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.	(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].		(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 15:23' prior: 33845830!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |suitStreak := OrderedCollection new.newList :=  OrderedCollection new.dataInHand := Dictionary new.dataInHand at: 'C' put: ''. dataInHand at: 'D' put: ''. dataInHand at: 'H' put: ''. dataInHand at: 'S' put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	dataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , ' ' )]. 	suitStreak := OrderedCollection new.	max := 0.		Transcript show: dataInHand; cr.	dataInHand keysAndValuesDo: [:aKey :aValue | 		word := ''.		temp := OrderedCollection new.		aValue do: [:a | (a asString ~= ' ') ifTrue: [word := word , a asString] ifFalse: [ temp add: word. word := '' ] ].		(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].	highestSuitStreak := suitStreak.	"	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak]."	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 15:24' prior: 34003286!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].		flushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new.	valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.	(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].			Transcript show: flushOrSuitStreak1; cr.	flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.	(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].		(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 15:27' prior: 33833811!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak |streaks := OrderedCollection new.notFound := true.2 to: nice size do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).	(previous ~= current) ifTrue: [  	( ( (current asNumber == 1 & ( previous asNumber == 13 ) ) | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )		ifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]		ifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]] ]].Transcript show: 'here';cr.Transcript show: streaks; cr.highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 15:31' prior: 33931779!sizeCheck: givenSize firstList: l1 secondList: l2	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"	| result l1_max l2_max aceInl1 aceInl2 |	l1_max := 0.	l2_max := 0.	l1 isNotEmpty		ifTrue: [ l1_max := l1				inject: 0				into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].	l2 isEmpty		ifFalse: [ l2_max := l2				inject: 0				into:					[ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].	aceInl1 := l1 detect: [:a | (a copyFrom: 1 to: a size - 1) asNumber == 1 ] ifNone: [0].	aceInl2 := l2 detect: [:a | (a copyFrom: 1 to: a size - 1) asNumber == 1 ] ifNone: [0].			result := OrderedCollection new.	l1 size == givenSize & (l2 size == givenSize)		ifTrue: [ result := ( aceInl1 ~= 0 | (l1_max > l2_max))				& (aceInl2 == 0)				ifTrue: [ l1 ]				ifFalse: [ l2 ] ]		ifFalse: [ l1 size == givenSize				ifTrue: [ result := l1 ].			l2 size == givenSize				ifTrue: [ result := l2 ] ].	Transcript show: 'result'; show: result;		cr.	^ result! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 15:36' prior: 34009800!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].		flushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new.	valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.	(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].			Transcript show: flushOrSuitStreak1; cr.	flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.	(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].		(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 15:56' prior: 34017266!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].		flushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new.	valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.	(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].			Transcript show: flushOrSuitStreak1; cr.	flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		flushOrSuitStreak := self sizeCheck: 3 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 3) ifTrue: [Transcript show: 7; cr. ^flushOrSuitStreak].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.	(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].		(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 16:00' prior: 34022607!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].		flushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 2; cr. ^flushOrSuitStreak].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new.	valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.	(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].			Transcript show: flushOrSuitStreak1; cr.	flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		flushOrSuitStreak := self sizeCheck: 3 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 3) ifTrue: [Transcript show: 6; cr. ^flushOrSuitStreak].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.	(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].		(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 16:02' prior: 34028137!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [Transcript show: 2; cr. ^valueStreak].		flushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new.	valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.	(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].			Transcript show: flushOrSuitStreak1; cr.	flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [Transcript show: 6; cr. ^valueStreak].		flushOrSuitStreak := self sizeCheck: 3 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 3) ifTrue: [Transcript show: 7; cr. ^flushOrSuitStreak].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.	(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].		(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 16:21' prior: 34033667!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new.	valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.	(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].			Transcript show: flushOrSuitStreak1; cr.	flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		valueStreak := self sizeCheck: 5 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 5) ifTrue: [Transcript show: 6; cr. ^valueStreak].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.	(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].		(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !----SNAPSHOT----2021-01-31T16:35:23.515003-05:00 game1.image priorSource: 396918!!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 16:40' prior: 34039197!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new.	valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreak1 := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreak2 := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].			Transcript show: flushOrSuitStreak1; cr.	flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		valueStreak := self sizeCheck: 5 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 5) ifTrue: [Transcript show: 6; cr. ^valueStreak].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.	(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].		(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 16:44' prior: 34044591!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new.	valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreak1 := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreak2 := valueStreak2 , valueStreak2b.	].	Transcript show: valueStreak1; show: valueStreak2; cr.	valueStreak := self sizeCheck: 5 firstList: valueStreak1 secondList: valueStreak2.		(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].			Transcript show: flushOrSuitStreak1; cr.	flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		valueStreak := self sizeCheck: 5 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 5) ifTrue: [Transcript show: 6; cr. ^valueStreak].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.	(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].		(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 16:45' prior: 34050025!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new.	valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreak1 := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreak2 := valueStreak2 , valueStreak2b.	].	Transcript show: valueStreak2b; show: valueStreak2; cr.	Transcript show: valueStreak1; show: valueStreak2; cr.	valueStreak := self sizeCheck: 5 firstList: valueStreak1 secondList: valueStreak2.		(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].			Transcript show: flushOrSuitStreak1; cr.	flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		valueStreak := self sizeCheck: 5 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 5) ifTrue: [Transcript show: 6; cr. ^valueStreak].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.	(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].		(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 16:45' prior: 34055518!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new.	valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreak1 := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreak2 := valueStreak2 , valueStreak2b.	].	Transcript show: valueStreak2b; show: temp2; cr.	Transcript show: valueStreak1; show: valueStreak2; cr.	valueStreak := self sizeCheck: 5 firstList: valueStreak1 secondList: valueStreak2.		(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].			Transcript show: flushOrSuitStreak1; cr.	flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		valueStreak := self sizeCheck: 5 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 5) ifTrue: [Transcript show: 6; cr. ^valueStreak].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.	(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].		(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 16:47' prior: 33850683!getHighestValueStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |	valueStreak := OrderedCollection new.	newList :=  OrderedCollection new.	dataInHand := Dictionary new. 	1 to: 13 do: [ :i | dataInHand at: i put: newList].		2 to: streaks size do: [ :i | 		previousCard := streaks at: (i-1).		previous := previousCard copyFrom: 1 to: (previousCard size-1).		card := streaks at: i.		current := card copyFrom: 1 to: (card size-1).		(previous asNumber == current asNumber)			ifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]			ifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].	(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].	Transcript show: dataInHand; cr.	valueStreak := OrderedCollection new.	maxCount := 0.	maxVal := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		( ( ( aKey asNumber ~= 1 & (aKey asNumber > maxVal asNumber) ) | (aKey asNumber == 1) ) & (aValue size >= maxCount) ) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue] ].		highestValueStreak := valueStreak.	^highestValueStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 16:48' prior: 34066609!getHighestValueStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |	valueStreak := OrderedCollection new.	newList :=  OrderedCollection new.	dataInHand := Dictionary new. 	1 to: 13 do: [ :i | dataInHand at: i put: newList].		2 to: streaks size do: [ :i | 		previousCard := streaks at: (i-1).		previous := previousCard copyFrom: 1 to: (previousCard size-1).		card := streaks at: i.		current := card copyFrom: 1 to: (card size-1).		(previous asNumber == current asNumber)			ifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]			ifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].	(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].	valueStreak := OrderedCollection new.	maxCount := 0.	maxVal := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		( ( ( aKey asNumber ~= 1 & (aKey asNumber > maxVal asNumber) ) | (aKey asNumber == 1) ) & (aValue size >= maxCount) ) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue] ].		Transcript show: valueStreak; cr.		highestValueStreak := valueStreak.	^highestValueStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 16:55' prior: 34068080!getHighestValueStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |	valueStreak := OrderedCollection new.	newList :=  OrderedCollection new.	dataInHand := Dictionary new. 	1 to: 13 do: [ :i | dataInHand at: i put: newList].		2 to: streaks size do: [ :i | 		previousCard := streaks at: (i-1).		previous := previousCard copyFrom: 1 to: (previousCard size-1).		card := streaks at: i.		current := card copyFrom: 1 to: (card size-1).		(previous asNumber == current asNumber)			ifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]			ifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].	(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].	valueStreak := OrderedCollection new.	maxCount := 0.	maxVal := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		( ( ( aKey asNumber ~= 1 & (aKey asNumber > maxVal asNumber) ) | (aKey asNumber == 1) ) & (aValue size == maxCount) ) | aValue size > maxCount 		ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue] ].			highestValueStreak := valueStreak.	^highestValueStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 16:55' prior: 34069553!getHighestValueStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |	valueStreak := OrderedCollection new.	newList :=  OrderedCollection new.	dataInHand := Dictionary new. 	1 to: 13 do: [ :i | dataInHand at: i put: newList].		2 to: streaks size do: [ :i | 		previousCard := streaks at: (i-1).		previous := previousCard copyFrom: 1 to: (previousCard size-1).		card := streaks at: i.		current := card copyFrom: 1 to: (card size-1).		(previous asNumber == current asNumber)			ifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]			ifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].	(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].	valueStreak := OrderedCollection new.	maxCount := 0.	maxVal := 0.	dataInHand keysAndValuesDo: [:aKey :aValue | 		( ( ( aKey asNumber ~= 1 & (aKey asNumber > maxVal asNumber) ) | (aKey asNumber == 1) ) & (aValue size == maxCount) ) | (aValue size > maxCount) 		ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue] ].			highestValueStreak := valueStreak.	^highestValueStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 16:57' prior: 34061067!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new.	valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreak1 := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreak2 := valueStreak2 , valueStreak2b.	].	Transcript show: valueStreak2b; show: temp2; cr.	Transcript show: valueStreak1; show: valueStreak2; cr.	valueStreak := self sizeCheck: 5 firstList: valueStreak1 secondList: valueStreak2.		(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].			Transcript show: flushOrSuitStreak1; cr.	flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		valueStreak := self sizeCheck: 5 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 5) ifTrue: [Transcript show: 6; cr. ^valueStreak].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.	(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].		(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 17:01' prior: 34072487!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new.	valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreak1 := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreak2 := valueStreak2 , valueStreak2b.	].	Transcript show: valueStreak2b; show: temp2; cr.	Transcript show: valueStreak1; show: valueStreak2; cr.	valueStreak := self sizeCheck: 5 firstList: valueStreak1 secondList: valueStreak2.		(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].			Transcript show: flushOrSuitStreak1; cr.	flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		Transcript show: 'look'; cr; show: valueStreak2; cr.	valueStreak := self sizeCheck: 5 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 5) ifTrue: [Transcript show: 6; cr. ^valueStreak].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.	(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].		(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 17:04' prior: 34078010!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new.	valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.		(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].			Transcript show: flushOrSuitStreak1; cr.	flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		Transcript show: 'look'; cr; show: valueStreak2; cr.	valueStreak := self sizeCheck: 5 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 5) ifTrue: [Transcript show: 6; cr. ^valueStreak].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.	(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].		(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 17:05' prior: 34083587!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.		(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].			Transcript show: flushOrSuitStreak1; cr.	flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		Transcript show: 'look'; cr; show: valueStreak2; cr.	valueStreak := self sizeCheck: 5 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 5) ifTrue: [Transcript show: 6; cr. ^valueStreak].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.	(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].		(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 17:10' prior: 34089084!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.		(straight size == 5 ) ifTrue: [Transcript show: 4; cr. ^straight].			Transcript show: flushOrSuitStreak1; cr.	flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		Transcript show: 'look'; cr; show: valueStreak2; cr.	valueStreak := self sizeCheck: 5 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 5) ifTrue: [Transcript show: 6; cr. ^valueStreak].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.	(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].		(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 17:16' prior: 34094660!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].			Transcript show: flushOrSuitStreak1; cr.	flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [Transcript show: 4; cr. ^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.	(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].		(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 17:17' prior: 34100230!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].			Transcript show: flushOrSuitStreak1; cr.	flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		Transcript show: 'look'; cr; show: straight2; cr.	straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	valueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.	(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].		(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 1/31/2021 17:24' prior: 34105746!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].			Transcript show: flushOrSuitStreak1; cr.	flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].		valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b.	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 4) ifTrue: [Transcript show: 8; cr. ^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !----SNAPSHOT----2021-01-31T17:25:07.564003-05:00 game1.image priorSource: 489987!Poker removeSelector: #getStreak:!----SNAPSHOT----2021-01-31T18:49:03.872003-05:00 game1.image priorSource: 562354!!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 20:57' prior: 34111313!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].			Transcript show: flushOrSuitStreak1; cr.	flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].		valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b.	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 4) ifTrue: [Transcript show: 8; cr. ^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.		ace1 := sorted1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) == 1] ifNone: [0].	ace2 := sorted2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ sorted1 := sorted1 inject: 0 into: [:a :c | ( (a copyFrom: 1 to: (a size-1) ) > ( c copyFrom: 1 to: (a size-1) ) ) 		ifTrue: [a] ifFalse: [c]]. 	  sorted2 := sorted2 inject: 0 into: [:a :c | ( (a copyFrom: 1 to: (a size-1) ) > ( c copyFrom: 1 to: (a size-1) ) ) 		ifTrue: [a] ifFalse: [c]]. 	  sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2. ] 	ifFalse: [ sorted := self sizeCheck: 1 firstList: ace1 secondList: ace2. ].		^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 20:58' prior: 34117077!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].			Transcript show: flushOrSuitStreak1; cr.	flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].		valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b.	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 4) ifTrue: [Transcript show: 8; cr. ^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.		ace1 := sorted1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) == 1] ifNone: [0].	ace2 := sorted2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ sorted1 := sorted1 inject: 0 into: [:a :c | ( (a copyFrom: 1 to: (a size-1) ) asNumber > ( c copyFrom: 1 to: (a size-1) ) asNumber ) 		ifTrue: [a] ifFalse: [c]]. 	  sorted2 := sorted2 inject: 0 into: [:a :c | ( (a copyFrom: 1 to: (a size-1) ) asNumber > ( c copyFrom: 1 to: (a size-1) ) asNumber ) 		ifTrue: [a] ifFalse: [c]]. 	  sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2. ] 	ifFalse: [ sorted := self sizeCheck: 1 firstList: ace1 secondList: ace2. ].		^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 20:58' prior: 34123304!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].			Transcript show: flushOrSuitStreak1; cr.	flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].		valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b.	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 4) ifTrue: [Transcript show: 8; cr. ^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.		ace1 := sorted1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := sorted2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ sorted1 := sorted1 inject: 0 into: [:a :c | ( (a copyFrom: 1 to: (a size-1) ) asNumber > ( c copyFrom: 1 to: (a size-1) ) asNumber ) 		ifTrue: [a] ifFalse: [c]]. 	  sorted2 := sorted2 inject: 0 into: [:a :c | ( (a copyFrom: 1 to: (a size-1) ) asNumber > ( c copyFrom: 1 to: (a size-1) ) asNumber ) 		ifTrue: [a] ifFalse: [c]]. 	  sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2. ] 	ifFalse: [ sorted := self sizeCheck: 1 firstList: ace1 secondList: ace2. ].		^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 21:00' prior: 34129567!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].			Transcript show: flushOrSuitStreak1; cr.	flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].		valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b.	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 4) ifTrue: [Transcript show: 8; cr. ^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	Transcript show:  sorted; cr.	ace1 := sorted1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := sorted2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ sorted1 := sorted1 inject: 0 into: [:a :c | ( (a copyFrom: 1 to: (a size-1) ) asNumber > ( c copyFrom: 1 to: (a size-1) ) asNumber ) 		ifTrue: [a] ifFalse: [c]]. 	  sorted2 := sorted2 inject: 0 into: [:a :c | ( (a copyFrom: 1 to: (a size-1) ) asNumber > ( c copyFrom: 1 to: (a size-1) ) asNumber ) 		ifTrue: [a] ifFalse: [c]]. 	  sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2. ] 	ifFalse: [ sorted := self sizeCheck: 1 firstList: ace1 secondList: ace2. ].		^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 21:01' prior: 34135848!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].			Transcript show: flushOrSuitStreak1; cr.	flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].		valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b.	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 4) ifTrue: [Transcript show: 8; cr. ^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	Transcript show:  sorted; cr.	Transcript show:  'h'; cr.	ace1 := sorted1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := sorted2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ sorted1 := sorted1 inject: 0 into: [:a :c | ( (a copyFrom: 1 to: (a size-1) ) asNumber > ( c copyFrom: 1 to: (a size-1) ) asNumber ) 		ifTrue: [a] ifFalse: [c]]. 	  sorted2 := sorted2 inject: 0 into: [:a :c | ( (a copyFrom: 1 to: (a size-1) ) asNumber > ( c copyFrom: 1 to: (a size-1) ) asNumber ) 		ifTrue: [a] ifFalse: [c]]. 	  sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2. ] 	ifFalse: [ sorted := self sizeCheck: 1 firstList: ace1 secondList: ace2. ].		^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 21:03' prior: 34142158!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].			Transcript show: flushOrSuitStreak1; cr.	flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].		valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b.	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 4) ifTrue: [Transcript show: 8; cr. ^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	Transcript show:  sorted; cr.	Transcript show:  'h'; cr.	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ sorted1 := hand1 inject: 0 into: [:a :c | ( (a copyFrom: 1 to: (a size-1) ) asNumber > ( c copyFrom: 1 to: (a size-1) ) asNumber ) 		ifTrue: [a] ifFalse: [c]]. 	  sorted2 := hand2 inject: 0 into: [:a :c | ( (a copyFrom: 1 to: (a size-1) ) asNumber > ( c copyFrom: 1 to: (a size-1) ) asNumber ) 		ifTrue: [a] ifFalse: [c]]. 	  sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2. ] 	ifFalse: [ sorted := self sizeCheck: 1 firstList: ace1 secondList: ace2. ].		^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 21:04' prior: 34148496!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].			Transcript show: flushOrSuitStreak1; cr.	flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].		valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b.	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 4) ifTrue: [Transcript show: 8; cr. ^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	Transcript show:  sorted; cr.	Transcript show:  'h'; cr.	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ sorted1 := hand1 inject: 0 into: [:a :c | ( (a copyFrom: 1 to: (a size-1) ) asNumber > ( c copyFrom: 1 to: (a size-1) ) asNumber ) 		ifTrue: [a asNumber] ifFalse: [c asNumber]]. 	  sorted2 := hand2 inject: 0 into: [:a :c | ( (a copyFrom: 1 to: (a size-1) ) asNumber > ( c copyFrom: 1 to: (a size-1) ) asNumber ) 		ifTrue: [a asNumber] ifFalse: [c asNumber]]. 	  sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2. ] 	ifFalse: [ sorted := self sizeCheck: 1 firstList: ace1 secondList: ace2. ].		^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 21:06' prior: 34154826!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].			Transcript show: flushOrSuitStreak1; cr.	flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].		valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b.	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 4) ifTrue: [Transcript show: 8; cr. ^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	Transcript show:  sorted; cr.	Transcript show:  'h'; cr.	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ sorted1 := hand1 inject: 0 into: [:a :c |  ( a > ( c copyFrom: 1 to: (a size-1) ) asNumber ) 		ifTrue: [a ] ifFalse: [c asNumber]]. 	  sorted2 := hand2 inject: 0 into: [:a :c |  ( a > ( c copyFrom: 1 to: (a size-1) ) asNumber ) 		ifTrue: [a ] ifFalse: [c asNumber]]. 	  sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2. ] 	ifFalse: [ sorted := self sizeCheck: 1 firstList: ace1 secondList: ace2. ].		^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 21:09' prior: 34161192!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].			Transcript show: flushOrSuitStreak1; cr.	flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].		valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b.	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 4) ifTrue: [Transcript show: 8; cr. ^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	Transcript show:  sorted; cr.	Transcript show:  'h'; cr.	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ sorted1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] . 	  sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2. ] 	ifFalse: [ sorted := self sizeCheck: 1 firstList: ace1 secondList: ace2. ].		^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 21:15' prior: 34167466!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].			Transcript show: flushOrSuitStreak1; cr.	flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].		valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b.	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 4) ifTrue: [Transcript show: 8; cr. ^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	Transcript show:  sorted; cr.	Transcript show:  'h'; cr.	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ sorted1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] . 	  sorted := sorted1 > sorted2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: (hand1 at: ace1)] ifFalse: [sorted add: (hand1 at: ace2)] ].		^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 21:21' prior: 34173661!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].			Transcript show: flushOrSuitStreak1; cr.	flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].		valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b.	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 4) ifTrue: [Transcript show: 8; cr. ^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	Transcript show:  sorted; cr.	Transcript show:  'h'; cr.	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ Transcript show:  ace1; show:  ace2;cr.	  sorted1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] . 	  sorted := sorted1 > sorted2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: (hand1 at: ace1)] ifFalse: [sorted add: (hand1 at: ace2)] ].		^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 21:21' prior: 34179886!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].			Transcript show: flushOrSuitStreak1; cr.	flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].		valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b.	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 4) ifTrue: [Transcript show: 8; cr. ^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	Transcript show:  sorted; cr.	Transcript show:  'h'; cr.	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  sorted1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] . 	  sorted := sorted1 > sorted2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ] 	ifFalse: [ Transcript show:  ace1; show:  ace2;cr. (ace1 ~= 0) ifTrue: [sorted add: (hand1 at: ace1)] ifFalse: [sorted add: (hand1 at: ace2)] ].		^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 21:23' prior: 34186154!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].			Transcript show: flushOrSuitStreak1; cr.	flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].		valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b.	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 4) ifTrue: [Transcript show: 8; cr. ^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	Transcript show:  sorted; cr.	Transcript show:  'h'; cr.	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  sorted1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] . 	  sorted := sorted1 > sorted2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ] 	ifFalse: [ sorted := OrderedCollection new. (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].		^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 21:27' prior: 34192423!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].			Transcript show: flushOrSuitStreak1; cr.	flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].		valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b.	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 4) ifTrue: [Transcript show: 8; cr. ^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	Transcript show:  sorted; cr.	Transcript show:  'h'; cr.	sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  sorted1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] . 	  Transcript show: sorted1; show: sorted2; cr.	  sorted := sorted1 > sorted2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].		^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 21:34' prior: 34198661!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].			Transcript show: flushOrSuitStreak1; cr.	flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].		valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b.	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 4) ifTrue: [Transcript show: 8; cr. ^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	Transcript show:  sorted; cr.	Transcript show:  'h'; cr.	sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  Transcript show: ace1; show: ace2; cr.	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].		^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 21:34' prior: 34204949!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.	Transcript show: 'hand'; cr.	Transcript show: hand; cr.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].			Transcript show: flushOrSuitStreak1; cr.	flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].		valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b.	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 4) ifTrue: [Transcript show: 8; cr. ^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.	Transcript show:  sorted; cr.	Transcript show:  'h'; cr.	sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 21:36' prior: 34211419!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: 'sorted'; cr.	Transcript show: sorted1; cr.	Transcript show: sorted2; cr.	Transcript show: '-----'; cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.	Transcript show: 'straight'; cr.	Transcript show: straight1; cr.	Transcript show: straight2; cr.	Transcript show: '-----'; cr.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.	Transcript show: 'valueStreak'; cr.	Transcript show: valueStreak1; cr.	Transcript show: valueStreak2; cr.	Transcript show: '-----'; cr.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.	Transcript show: 'flushOrSuitStreak'; cr.	Transcript show: flushOrSuitStreak1; cr.	Transcript show: flushOrSuitStreak2; cr.	Transcript show: '-----'; cr.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush1; cr.].		straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.		Transcript show: 'straightFlush'; cr.		Transcript show: straightFlush2; cr.].		Transcript show: '-----'; cr.		straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		Transcript show: 'remaining'; cr.	Transcript show: remaining1; cr.	Transcript show: remaining2; cr.	temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].			Transcript show: flushOrSuitStreak1; cr.	flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].		valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b.	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 4) ifTrue: [Transcript show: 8; cr. ^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].		Transcript show:  sorted; cr.	Transcript show:  'h'; cr.	sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted		"	maxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )   ifTrue: [a]   ifFalse: [c]].	Transcript show: maxNumOfAKind; cr.	suitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.	Transcript show: suitOfAKind; cr.		suitCards := self returnSuitCards: suitOfAKind.	Transcript show: suitOfAKind; cr.	"	! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 21:41' prior: 34014982!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak |streaks := OrderedCollection new.notFound := true.2 to: nice size do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).	(previous ~= current) ifTrue: [  	( ( (current asNumber == 1 & ( previous asNumber == 13 ) ) | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )		ifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]		ifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]] ]].highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 21:42' prior: 34008468!getHighestSuitStreak: streaks	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |suitStreak := OrderedCollection new.newList :=  OrderedCollection new.dataInHand := Dictionary new.dataInHand at: 'C' put: ''. dataInHand at: 'D' put: ''. dataInHand at: 'H' put: ''. dataInHand at: 'S' put: ''.1 to: streaks size do: [ :i | 	card := streaks at: i.	current := card at: card size.	dataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , ' ' )]. 	suitStreak := OrderedCollection new.	max := 0.		dataInHand keysAndValuesDo: [:aKey :aValue | 		word := ''.		temp := OrderedCollection new.		aValue do: [:a | (a asString ~= ' ') ifTrue: [word := word , a asString] ifFalse: [ temp add: word. word := '' ] ].		(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].	highestSuitStreak := suitStreak.	"	(suitStreak size >= 5) 	ifTrue: [		(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]	ifFalse: [highestSuitStreak := suitStreak]."	^highestSuitStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 21:42' prior: 34016136!sizeCheck: givenSize firstList: l1 secondList: l2	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"	| result l1_max l2_max aceInl1 aceInl2 |	l1_max := 0.	l2_max := 0.	l1 isNotEmpty		ifTrue: [ l1_max := l1				inject: 0				into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].	l2 isEmpty		ifFalse: [ l2_max := l2				inject: 0				into:					[ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].	aceInl1 := l1 detect: [:a | (a copyFrom: 1 to: a size - 1) asNumber == 1 ] ifNone: [0].	aceInl2 := l2 detect: [:a | (a copyFrom: 1 to: a size - 1) asNumber == 1 ] ifNone: [0].			result := OrderedCollection new.	l1 size == givenSize & (l2 size == givenSize)		ifTrue: [ result := ( aceInl1 ~= 0 | (l1_max > l2_max))				& (aceInl2 == 0)				ifTrue: [ l1 ]				ifFalse: [ l2 ] ]		ifFalse: [ l1 size == givenSize				ifTrue: [ result := l1 ].			l2 size == givenSize				ifTrue: [ result := l2 ] ].				^ result! !!Poker methodsFor: 'sorting' stamp: 'MagdalenaDhima 2/11/2021 21:42' prior: 33858867!sort: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| threeDigits twoDigits sorted aces |	threeDigits := SortedCollection new. twoDigits := SortedCollection new.1 to: (shuf size) do: [ :i | ((shuf at: i) size == 3) ifTrue: [threeDigits add: (shuf at: i)] ifFalse: [twoDigits add: (shuf at: i)]. ].sorted := (twoDigits asArray) , (threeDigits asArray).aces := sorted select: [:a |  (a copyFrom: 1 to: (a size-1)) asNumber == 1 ].sorted := sorted reject: [:a |  (a copyFrom: 1 to: (a size-1)) asNumber == 1 ].sorted := sorted , aces.^sorted! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 21:45' prior: 34217845!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [^valueStreak].			flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b.	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !----SNAPSHOT----2021-02-11T21:45:40.374875-05:00 game1.image priorSource: 562473!----SNAPSHOT----2021-02-11T22:06:39.162875-05:00 game1.image priorSource: 678605!!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 22:12' prior: 34228330!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		Transcript show: valueStreak1b; show: valueStreak2b; cr. 		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [^valueStreak].			flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b.	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 22:14' prior: 34233292!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].   Transcript show: valueStreakA; show: valueStreakB; cr. 	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [^valueStreak].			flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b.	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 22:15' prior: 34238149!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b.	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 4) ifTrue: [^(valueStreak)].		Transcript show: valueStreakA; show: valueStreakB; cr. 	valueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 22:15' prior: 34243006!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b.		Transcript show: valueStreakA; show: valueStreakB; cr. 		valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 4) ifTrue: [^(valueStreak)].			valueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 22:16' prior: 34247858!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b.		valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 4) ifTrue: [^(valueStreak)].			valueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 22:16' prior: 34252716!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b.	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 4) ifTrue: [^(valueStreak)].			valueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 22:16' prior: 34257515!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b.	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.	Transcript show: valueStreak; show: valueStreakB; cr. 	(valueStreak size == 4) ifTrue: [^(valueStreak)].			valueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 22:19' prior: 34226538!sizeCheck: givenSize firstList: l1 secondList: l2	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"	| result l1_max l2_max aceInl1 aceInl2 |	l1_max := 0.	l2_max := 0.	l1 isNotEmpty		ifTrue: [ l1_max := l1				inject: 0				into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].	l2 isEmpty		ifFalse: [ l2_max := l2				inject: 0				into:					[ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].	aceInl1 := l1 detect: [:a | (a copyFrom: 1 to: a size - 1) asNumber == 1 ] ifNone: [0].	aceInl2 := l2 detect: [:a | (a copyFrom: 1 to: a size - 1) asNumber == 1 ] ifNone: [0].		Transcript show: l1_max; show: l2_max ; cr.			result := OrderedCollection new.	l1 size == givenSize & (l2 size == givenSize)		ifTrue: [ result := ( aceInl1 ~= 0 | (l1_max > l2_max))				& (aceInl2 == 0)				ifTrue: [ l1 ]				ifFalse: [ l2 ] ]		ifFalse: [ l1 size == givenSize				ifTrue: [ result := l1 ].			l2 size == givenSize				ifTrue: [ result := l2 ] ].				^ result! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 22:37' prior: 34262312!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		(valueStreak1 at: 1) = (valueStreak2 at: 1) 	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 4 firstList: valueStreak1b secondList: valueStreak2b) ].				Transcript show: valueStreak; show: valueStreakB; cr. 	(valueStreak size == 4) ifTrue: [^(valueStreak)].			valueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 22:37' prior: 34268298!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		(valueStreak1 at: 1) = (valueStreak2 at: 1) 	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 4 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].			valueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 22:38' prior: 34273335!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		(valueStreak1 at: 1) == (valueStreak2 at: 1) 	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 4 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].			valueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 22:38' prior: 34278312!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		(valueStreak1 at: 1) ~= (valueStreak2 at: 1) 	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 4 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].			valueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 22:39' prior: 34283290!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		(valueStreak1 at: 1) ~= (valueStreak2 at: 1) 	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].			valueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 22:43' prior: 34288268!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.	Transcript show: hand; cr.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		(valueStreak1 at: 1) ~= (valueStreak2 at: 1) 	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].			valueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 22:46' prior: 34293246!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.	Transcript show: hand; cr.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		(valueStreak1 at: 1) ~= (valueStreak2 at: 1) 	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].			valueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 22:47' prior: 34298252!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.	Transcript show: hand; cr.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		(valueStreak1 at: 1) ~= (valueStreak2 at: 1) 	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := (self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2), (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].			valueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 22:48' prior: 34303258!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.	Transcript show: hand; cr.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		(valueStreak1 at: 1) ~= (valueStreak2 at: 1) 	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := (self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2), (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		Transcript show: valueStreak; cr.		(valueStreak size == 4) ifTrue: [^(valueStreak)].			valueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 22:49' prior: 34308319!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.	Transcript show: hand; cr.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		(valueStreak1 at: 1) ~= (valueStreak2 at: 1) 	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := (self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2), (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		Transcript show: valueStreak; cr.		(valueStreak size == 4) ifTrue: [^(valueStreak)].			valueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.	Transcript show: valueStreak; cr.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 22:51' prior: 34313417!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.	Transcript show: hand; cr.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		(valueStreak1 at: 1) ~= (valueStreak2 at: 1) 	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := (self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2), (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		Transcript show: valueStreak; cr.		(valueStreak size == 4) ifTrue: [^(valueStreak)].			Transcript show: valueStreak; cr.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 22:51' prior: 34318550!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.	Transcript show: hand; cr.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		(valueStreak1 at: 1) ~= (valueStreak2 at: 1) 	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := (self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2), (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].			(valueStreak size == 4) ifTrue: [^(valueStreak)].			(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 22:54' prior: 34323600!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.	Transcript show: hand; cr.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		(valueStreak1 at: 1) ~= (valueStreak2 at: 1) 	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := (self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2), (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].			(valueStreak size == 4) ifTrue: [^(valueStreak)].		Transcript show: 'here ', valueStreak.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 22:56' prior: 34328579!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.	Transcript show: hand; cr.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		(valueStreak1 at: 1) ~= (valueStreak2 at: 1) 	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].			(valueStreak size == 4) ifTrue: [^(valueStreak)].		Transcript show: 'here ', valueStreak.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 22:58' prior: 34333596!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.	Transcript show: hand; cr.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		(valueStreak1 at: 1) ~= (valueStreak2 at: 1) 	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	Transcript show: 'here ', valueStreak.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 23:00' prior: 34338558!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.	Transcript show: hand; cr.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		(valueStreak1 at: 1) ~= (valueStreak2 at: 1) 	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		Transcript show: 'here ', valueStreak.	(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	Transcript show: 'here ', valueStreak.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 23:02' prior: 34343602!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.	Transcript show: hand; cr.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		(valueStreak1 at: 1) ~= (valueStreak2 at: 1) 	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		Transcript show: 'here '; show: valueStreak.	(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	Transcript show: 'here '; show: valueStreak.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 23:05' prior: 34348686!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.	Transcript show: hand; cr.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		valueStreak1 notEmpty & ( (valueStreak1 at: 1) ~= (valueStreak2 at: 1) )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		Transcript show: 'here '; show: valueStreak.	(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	Transcript show: 'here '; show: valueStreak.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 23:05' prior: 34353782!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.	Transcript show: hand; cr.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		(valueStreak1 notEmpty & valueStreak2 notEmpty ) & ( (valueStreak1 at: 1) ~= (valueStreak2 at: 1) )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		Transcript show: 'here '; show: valueStreak.	(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	Transcript show: 'here '; show: valueStreak.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 23:06' prior: 34358905!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.	Transcript show: hand; cr.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		(valueStreak1 isEmpty not & valueStreak2 isEmpty not ) & ( (valueStreak1 at: 1) ~= (valueStreak2 at: 1) )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		Transcript show: 'here '; show: valueStreak.	(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	Transcript show: 'here '; show: valueStreak.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 23:07' prior: 34364055!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.	Transcript show: hand; cr.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		( (valueStreak1 isEmpty not) & (valueStreak2 isEmpty not) ) & ( (valueStreak1 at: 1) ~= (valueStreak2 at: 1) )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		Transcript show: 'here '; show: valueStreak.	(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	Transcript show: 'here '; show: valueStreak.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 23:08' prior: 34369211!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.	Transcript show: hand; cr.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		Transcript show: 'here '; show: valueStreak class; cr.	( (valueStreak1 isEmpty not) & (valueStreak2 isEmpty not) ) & ( (valueStreak1 at: 1) ~= (valueStreak2 at: 1) )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		Transcript show: 'here '; show: valueStreak.	(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	Transcript show: 'here '; show: valueStreak.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 23:08' prior: 34374372!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.	Transcript show: hand; cr.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		Transcript show: 'here '; show: valueStreak length; cr.	( (valueStreak1 isEmpty not) & (valueStreak2 isEmpty not) ) & ( (valueStreak1 at: 1) ~= (valueStreak2 at: 1) )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		Transcript show: 'here '; show: valueStreak.	(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	Transcript show: 'here '; show: valueStreak.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 23:09' prior: 34379589!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.	Transcript show: hand; cr.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		Transcript show: 'here '; show: valueStreak size; cr.	( (valueStreak1 isEmpty not) & (valueStreak2 isEmpty not) ) & ( (valueStreak1 at: 1) ~= (valueStreak2 at: 1) )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		Transcript show: 'here '; show: valueStreak.	(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	Transcript show: 'here '; show: valueStreak.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 23:09' prior: 34384807!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.	Transcript show: hand; cr.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		Transcript show: 'here '; show: valueStreak size; cr.	( (valueStreak1 size ~= 0) & (valueStreak2 size ~= 0) ) & ( (valueStreak1 at: 1) ~= (valueStreak2 at: 1) )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		Transcript show: 'here '; show: valueStreak.	(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	Transcript show: 'here '; show: valueStreak.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 23:11' prior: 34390023!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.	Transcript show: hand; cr.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		Transcript show: 'here '; show: (valueStreak1 size ~= 0) ; cr.	( (valueStreak1 size ~= 0) & (valueStreak2 size ~= 0) ) & ( (valueStreak1 at: 1) ~= (valueStreak2 at: 1) )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		Transcript show: 'here '; show: valueStreak.	(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	Transcript show: 'here '; show: valueStreak.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 23:11' prior: 34395235!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.	Transcript show: hand; cr.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		Transcript show: 'here '; show: (valueStreak1 size ~= 0) ; cr.	( (valueStreak1 size == 0) & (valueStreak2 size == 0) ) & ( (valueStreak1 at: 1) ~= (valueStreak2 at: 1) )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		Transcript show: 'here '; show: valueStreak.	(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	Transcript show: 'here '; show: valueStreak.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 23:11' prior: 34400456!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.	Transcript show: hand; cr.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		Transcript show: 'here '; show: (valueStreak2 size ~= 0) ; cr.	( (valueStreak1 size == 0) & (valueStreak2 size == 0) ) & ( (valueStreak1 at: 1) ~= (valueStreak2 at: 1) )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		Transcript show: 'here '; show: valueStreak.	(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	Transcript show: 'here '; show: valueStreak.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 23:12' prior: 34405677!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.	Transcript show: hand; cr.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		Transcript show: 'here '; show: (valueStreak2 size ~= 0) ; cr.	( (valueStreak1 size ~= 0) & (valueStreak2 size ~= 0) ) & ( (valueStreak1 at: 1) ~= (valueStreak2 at: 1) )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		Transcript show: 'here '; show: valueStreak.	(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	Transcript show: 'here '; show: valueStreak.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 23:13' prior: 34410898!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.	Transcript show: hand; cr.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		Transcript show: 'here '; show: (valueStreak2 size ~= 0) ; cr.	( (valueStreak1 size ~= 0) & (valueStreak2 size ~= 0) ) 	ifTrue: [( (valueStreak1 at: 1) ~= (valueStreak2 at: 1) )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].].		Transcript show: 'here '; show: valueStreak.	(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	Transcript show: 'here '; show: valueStreak.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 23:21' prior: 34416119!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.	Transcript show: hand; cr.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 size > 0) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 size > 0) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		Transcript show: 'here '; show: valueStreak.	(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	Transcript show: 'here '; show: valueStreak.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 23:22' prior: 34421351!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.	Transcript show: hand; cr.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 isEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 isEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		Transcript show: 'here '; show: valueStreak.	(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	Transcript show: 'here '; show: valueStreak.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 23:22' prior: 34426571!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.	Transcript show: hand; cr.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		Transcript show: 'here '; show: valueStreak.	(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	Transcript show: 'here '; show: valueStreak.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 23:30' prior: 34431789!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 23:30' prior: 34267165!sizeCheck: givenSize firstList: l1 secondList: l2	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"	| result l1_max l2_max aceInl1 aceInl2 |	l1_max := 0.	l2_max := 0.	l1 isNotEmpty		ifTrue: [ l1_max := l1				inject: 0				into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].	l2 isEmpty		ifFalse: [ l2_max := l2				inject: 0				into:					[ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].	aceInl1 := l1 detect: [:a | (a copyFrom: 1 to: a size - 1) asNumber == 1 ] ifNone: [0].	aceInl2 := l2 detect: [:a | (a copyFrom: 1 to: a size - 1) asNumber == 1 ] ifNone: [0].				result := OrderedCollection new.	l1 size == givenSize & (l2 size == givenSize)		ifTrue: [ result := ( aceInl1 ~= 0 | (l1_max > l2_max))				& (aceInl2 == 0)				ifTrue: [ l1 ]				ifFalse: [ l2 ] ]		ifFalse: [ l1 size == givenSize				ifTrue: [ result := l1 ].			l2 size == givenSize				ifTrue: [ result := l2 ] ].				^ result! !----SNAPSHOT----2021-02-11T23:34:19.117875-05:00 game1.image priorSource: 678688!!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 23:40' prior: 34437009!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB ]	ifFalse: [ valueStreak := (self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2) , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].			valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	].	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 23:53' prior: 34443280!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 ) & ( (self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2) size == 3)	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		"	valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 23:55' prior: 34448920!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 ) & ( (self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2) size == 3)	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		"	valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	Transcript show: valueStreak; cr.	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 23:55' prior: 34454590!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 ) & ( (self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2) size == 3)	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		"	valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	Transcript show: (temp1==temp2); cr.	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 23:56' prior: 34460294!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.	Transcript show: hand; cr.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 ) & ( (self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2) size == 3)	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		"	valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	Transcript show: (temp1==temp2); cr.	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 23:57' prior: 34466001!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.	Transcript show: hand; cr.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 ) & ( (self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2) size == 3)	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		"	valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	Transcript show: valueStreak1; cr.	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/11/2021 23:57' prior: 34471736!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.	Transcript show: hand; cr.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 ) & ( (self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2) size == 3)	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		"	valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	Transcript show: valueStreak2; cr.	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 00:01' prior: 34477469!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.	Transcript show: hand; cr.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 ) & ( (self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2) size == 3)	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := ( temp1 > temp2 ) ifTrue: [ valueStreakA  ] ifFalse: [ valueStreakB ] ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		"	valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	Transcript show: valueStreak2; cr.	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 00:02' prior: 34483202!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.	Transcript show: hand; cr.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 ) & ( (self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2) size == 3)	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := ( temp1 > temp2 ) ifTrue: [ valueStreakA  ] ifFalse: [ valueStreakB ] ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		"	valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	Transcript show: valueStreak1; show: valueStreak; cr.	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 00:05' prior: 34488938!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.	Transcript show: hand; cr.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ (valueStreak1 at: 1) copyFrom: 1 to: ((valueStreak1 at: 1) size-1) ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ (valueStreak2 at: 1) copyFrom: 1 to: ((valueStreak2 at: 1) size-1)  ].	( temp1 ~= temp2 ) & ( (self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2) size == 3)	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := ( temp1 > temp2 ) ifTrue: [ valueStreakA  ] ifFalse: [ valueStreakB ] ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		"	valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	Transcript show: valueStreak1; show: valueStreak; cr.	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 00:05' prior: 34494693!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.	Transcript show: hand; cr.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ ( (valueStreak1 at: 1) copyFrom: 1 to: ((valueStreak1 at: 1) size-1) ) asNumber ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ ( (valueStreak2 at: 1) copyFrom: 1 to: ((valueStreak2 at: 1) size-1) ) asNumber ].	( temp1 ~= temp2 ) & ( (self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2) size == 3)	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := ( temp1 > temp2 ) ifTrue: [ valueStreakA  ] ifFalse: [ valueStreakB ] ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		"	valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	Transcript show: valueStreak1; show: valueStreak; cr.	valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 00:06' prior: 34500545!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.	Transcript show: hand; cr.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ ( (valueStreak1 at: 1) copyFrom: 1 to: ((valueStreak1 at: 1) size-1) ) asNumber ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ ( (valueStreak2 at: 1) copyFrom: 1 to: ((valueStreak2 at: 1) size-1) ) asNumber ].	( temp1 ~= temp2 ) & ( (self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2) size == 3)	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := ( temp1 > temp2 ) ifTrue: [ valueStreakA  ] ifFalse: [ valueStreakB ] ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		"	valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	Transcript show: valueStreak1; show: valueStreak; cr.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 00:09' prior: 34506422!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.	Transcript show: hand; cr.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		temp1 = 0.	temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ ( (valueStreak1 at: 1) copyFrom: 1 to: ((valueStreak1 at: 1) size-1) ) asNumber ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ ( (valueStreak2 at: 1) copyFrom: 1 to: ((valueStreak2 at: 1) size-1) ) asNumber ].	( temp1 ~= temp2 ) & ( (self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2) size == 3)	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := ( temp1 > temp2 ) ifTrue: [ valueStreakA  ] ifFalse: [ valueStreakB ] ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		"	valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	Transcript show: valueStreak1; show: valueStreak; cr.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 00:10' prior: 34512215!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.	Transcript show: hand; cr.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		temp1 = 0.	temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ ( (valueStreak1 at: 1) copyFrom: 1 to: ((valueStreak1 at: 1) size-1) ) asNumber ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ ( (valueStreak2 at: 1) copyFrom: 1 to: ((valueStreak2 at: 1) size-1) ) asNumber ].	( temp1 ~= temp2 ) & ( (self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2) size == 3)	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := ( temp1 > temp2 ) ifTrue: [ valueStreakA  ] ifFalse: [ valueStreakB ] ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		"	valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	Transcript show: valueStreak1; show: valueStreak; cr.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1 = 0.	temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 00:20' prior: 34518013!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.	Transcript show: hand; cr.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		temp1 = 0.	temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ ( (valueStreak1 at: 1) copyFrom: 1 to: ((valueStreak1 at: 1) size-1) ) asNumber ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ ( (valueStreak2 at: 1) copyFrom: 1 to: ((valueStreak2 at: 1) size-1) ) asNumber ].	( temp1 ~= temp2 ) & ( (self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2) size == 3)	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := ( temp1 > temp2 ) ifTrue: [ valueStreakA  ] ifFalse: [ valueStreakB ] ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		"	valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	Transcript show: valueStreak2; show: valueStreak; cr.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1 = 0.	temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 00:25' prior: 34523816!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.	Transcript show: hand; cr.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		temp1 = 0.	temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ ( (valueStreak1 at: 1) copyFrom: 1 to: ((valueStreak1 at: 1) size-1) ) asNumber ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ ( (valueStreak2 at: 1) copyFrom: 1 to: ((valueStreak2 at: 1) size-1) ) asNumber ].	( temp1 ~= temp2 ) 	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := ( temp1 > temp2 ) ifTrue: [ valueStreakA  ] ifFalse: [ valueStreakB ] ]	ifFalse: [ (valueStreak1 size == 3) 		ifTrue: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ]		ifFalse: [ valueStreak := valueStreak2 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ]  ].		"	valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	Transcript show: valueStreak2; show: valueStreak; cr.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1 = 0.	temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 00:25' prior: 34529619!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.	Transcript show: hand; cr.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		temp1 = 0.	temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ ( (valueStreak1 at: 1) copyFrom: 1 to: ((valueStreak1 at: 1) size-1) ) asNumber ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ ( (valueStreak2 at: 1) copyFrom: 1 to: ((valueStreak2 at: 1) size-1) ) asNumber ].	( temp1 ~= temp2 ) 	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := ( temp1 > temp2 ) ifTrue: [ valueStreakA  ] ifFalse: [ valueStreakB ] ]	ifFalse: [ (valueStreak1 size == 3) 		ifTrue: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ]		ifFalse: [ valueStreak := valueStreak2 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ]  ].		"	valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	Transcript show: valueStreak1; show: valueStreak; cr.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1 = 0.	temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 00:26' prior: 34535496!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.	Transcript show: hand; cr.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].				straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		temp1 = 0.	temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ ( (valueStreak1 at: 1) copyFrom: 1 to: ((valueStreak1 at: 1) size-1) ) asNumber ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ ( (valueStreak2 at: 1) copyFrom: 1 to: ((valueStreak2 at: 1) size-1) ) asNumber ].	( temp1 ~= temp2 ) 	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := ( temp1 > temp2 ) ifTrue: [ valueStreakA  ] ifFalse: [ valueStreakB ] ]	ifFalse: [ (valueStreak1 size == 3) 		ifTrue: [ valueStreak := valueStreak1 , valueStreak1b ]		ifFalse: [ valueStreak := valueStreak2 , valueStreak2b ]  ].		"	valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	Transcript show: valueStreak1; show: valueStreak; cr.	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1 = 0.	temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted. ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 09:41' prior: 34437009!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].		Transcript show: hand.	straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	"	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	Transcript show: valueStreak1; show: valueStreak2 ;cr.	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		temp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.		temp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		Transcript show: valueStreak1; show: valueStreak2 ;cr.		(valueStreak1 at: 1) = (valueStreak2 at: 1)  ifTrue: [ 						((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) 			ifTrue: [			((valueStreak1b at: 1) = (temp2 at: 1)) & (valueStreak1 size == 3) ifTrue: [ 				valueStreak := valueStreak1 , valueStreak1b]. 			((valueStreak2b at: 1) = (temp2 at: 1)) & (valueStreak2 size == 3)  ifTrue: [ 			   valueStreak := valueStreak2 , valueStreak2b]. 			] ifFalse: [ 				((valueStreak1 at: 1) = (temp1 at: 1)) & (valueStreak1 size == 3) ifTrue: [  					valueStreakA := valueStreak1 , valueStreak1b].				((valueStreak2 at: 1) = (temp1 at: 1)) & (valueStreak2 size == 3) ifTrue: [  					valueStreakB := valueStreak2 , valueStreak2b].			 ].	].	"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ] ].	^sorted.  ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 09:43' prior: 34547136!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].		Transcript show: hand.	straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	"	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	Transcript show: valueStreak1; show: valueStreak2 ;cr.	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		temp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.		temp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		Transcript show: valueStreak1; show: valueStreak2 ;cr.		(valueStreak1 at: 1) = (valueStreak2 at: 1)  ifTrue: [ 			Transcript show: valueStreak1; show: valueStreak2 ;cr.			((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) 			ifTrue: [			((valueStreak1b at: 1) = (temp2 at: 1)) & (valueStreak1 size == 3) ifTrue: [ 				valueStreak := valueStreak1 , valueStreak1b]. 			((valueStreak2b at: 1) = (temp2 at: 1)) & (valueStreak2 size == 3)  ifTrue: [ 			   valueStreak := valueStreak2 , valueStreak2b]. 			] ifFalse: [ 				((valueStreak1 at: 1) = (temp1 at: 1)) & (valueStreak1 size == 3) ifTrue: [  					valueStreakA := valueStreak1 , valueStreak1b].				((valueStreak2 at: 1) = (temp1 at: 1)) & (valueStreak2 size == 3) ifTrue: [  					valueStreakB := valueStreak2 , valueStreak2b].			 ].	].	"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ] ].	^sorted.  ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 09:44' prior: 34553383!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].		Transcript show: hand.	straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	"	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	Transcript show: valueStreak1; show: valueStreak2 ;cr.	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		temp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.		temp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		Transcript show: valueStreak1; show: valueStreak2 ;cr.		(valueStreak1 at: 1) = (valueStreak2 at: 1)  ifTrue: [ 			((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) 			ifTrue: [			((valueStreak1b at: 1) = (temp2 at: 1)) & (valueStreak1 size == 3) ifTrue: [ 				valueStreak := valueStreak1 , valueStreak1b]. 			((valueStreak2b at: 1) = (temp2 at: 1)) & (valueStreak2 size == 3)  ifTrue: [ 			   valueStreak := valueStreak2 , valueStreak2b]. 			] ifFalse: [ 				((valueStreak1 at: 1) = (temp1 at: 1)) & (valueStreak1 size == 3) ifTrue: [  					valueStreak := valueStreak1 , valueStreak1b].				((valueStreak2 at: 1) = (temp1 at: 1)) & (valueStreak2 size == 3) ifTrue: [  					valueStreak := valueStreak2 , valueStreak2b].			 ].	].	"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ] ].	^sorted.  ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 09:45' prior: 34559684!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].		Transcript show: hand.	straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	"	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	Transcript show: valueStreak1; show: valueStreak2 ;cr.	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		temp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.		temp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		Transcript show: valueStreak1; show: valueStreak2 ;cr.		(valueStreak1 at: 1) = (valueStreak2 at: 1)  ifTrue: [ 			((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) 			ifTrue: [			((valueStreak1b at: 1) = (temp2 at: 1)) & (valueStreak1 size == 3) ifTrue: [ 				valueStreak := valueStreak1 , valueStreak1b]. 			((valueStreak2b at: 1) = (temp2 at: 1)) & (valueStreak2 size == 3)  ifTrue: [ 			   valueStreak := valueStreak2 , valueStreak2b]. 			] ifFalse: [ 				((valueStreak1 at: 1) = (temp1 at: 1)) & (valueStreak1 size == 3) ifTrue: [  					valueStreak := valueStreak1 , valueStreak1b].				((valueStreak2 at: 1) = (temp1 at: 1)) & (valueStreak2 size == 3) ifTrue: [  					valueStreak := valueStreak2 , valueStreak2b].				Transcript show: valueStreak1; show: valueStreak2 ; show: valueStreak; cr.			 ].	].	"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ] ].	^sorted.  ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 09:46' prior: 34565925!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].		Transcript show: hand.	straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	"	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	Transcript show: valueStreak1; show: valueStreak2 ;cr.	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		temp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.		temp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		Transcript show: valueStreak1; show: valueStreak2 ;cr.		(valueStreak1 at: 1) = (valueStreak2 at: 1)  ifTrue: [ 			((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) 			ifTrue: [			((valueStreak1b at: 1) = (temp2 at: 1)) & (valueStreak1 size == 3) ifTrue: [ 				valueStreak := valueStreak1 , valueStreak1b]. 			((valueStreak2b at: 1) = (temp2 at: 1)) & (valueStreak2 size == 3)  ifTrue: [ 			   valueStreak := valueStreak2 , valueStreak2b]. 			] ifFalse: [ 				Transcript show: 'f'; cr.				((valueStreak1 at: 1) = (temp1 at: 1)) & (valueStreak1 size == 3) ifTrue: [  					valueStreak := valueStreak1 , valueStreak1b].				((valueStreak2 at: 1) = (temp1 at: 1)) & (valueStreak2 size == 3) ifTrue: [  					valueStreak := valueStreak2 , valueStreak2b].				Transcript show: valueStreak1; show: valueStreak2 ; show: valueStreak; cr.			 ].	].	"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ] ].	^sorted.  ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 09:46' prior: 34572245!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].		Transcript show: hand.	straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	"	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	Transcript show: valueStreak1; show: valueStreak2 ;cr.	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		temp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.		temp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		Transcript show: valueStreak1; show: valueStreak2 ;cr.		(valueStreak1 at: 1) = (valueStreak2 at: 1)  ifTrue: [ 			((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) 			ifTrue: [				Transcript show: 'f'; cr.			((valueStreak1b at: 1) = (temp2 at: 1)) & (valueStreak1 size == 3) ifTrue: [ 				valueStreak := valueStreak1 , valueStreak1b]. 			((valueStreak2b at: 1) = (temp2 at: 1)) & (valueStreak2 size == 3)  ifTrue: [ 			   valueStreak := valueStreak2 , valueStreak2b]. 			] ifFalse: [ 				Transcript show: 'f'; cr.				((valueStreak1 at: 1) = (temp1 at: 1)) & (valueStreak1 size == 3) ifTrue: [  					valueStreak := valueStreak1 , valueStreak1b].				((valueStreak2 at: 1) = (temp1 at: 1)) & (valueStreak2 size == 3) ifTrue: [  					valueStreak := valueStreak2 , valueStreak2b].				Transcript show: valueStreak1; show: valueStreak2 ; show: valueStreak; cr.			 ].	].	"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ] ].	^sorted.  ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 09:52' prior: 34578595!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].		Transcript show: hand.	straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	"	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	Transcript show: valueStreak1; show: valueStreak2 ;cr.	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		temp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.		temp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		Transcript show: valueStreak1; show: valueStreak2 ;cr.		(valueStreak1 at: 1) = (valueStreak2 at: 1)  		ifTrue: [ 			((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) 			ifTrue: [				Transcript show: 'g'; cr.			((valueStreak1b at: 1) = (temp2 at: 1)) & (valueStreak1 size == 3) ifTrue: [ 				valueStreak := valueStreak1 , valueStreak1b]. 			((valueStreak2b at: 1) = (temp2 at: 1)) & (valueStreak2 size == 3)  ifTrue: [ 			   valueStreak := valueStreak2 , valueStreak2b]. 			]] 		ifFalse: [ 				Transcript show: 'f'; cr.				((valueStreak1 at: 1) = (temp1 at: 1)) & (valueStreak1 size == 3) ifTrue: [  					valueStreak := valueStreak1 , valueStreak1b].				((valueStreak2 at: 1) = (temp1 at: 1)) & (valueStreak2 size == 3) ifTrue: [  					valueStreak := valueStreak2 , valueStreak2b].				Transcript show: valueStreak1; show: valueStreak2 ; show: valueStreak; cr.		]	].	Transcript show: 'A'; cr.	"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted.   ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 09:53' prior: 34584975!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].		Transcript show: hand.	straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	"	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	Transcript show: valueStreak1; show: valueStreak2 ;cr.	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		temp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.		temp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		Transcript show: valueStreak1b; show: valueStreak2b ;cr.		(valueStreak1 at: 1) = (valueStreak2 at: 1)  		ifTrue: [ 			((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) 			ifTrue: [				Transcript show: 'g'; cr.			((valueStreak1b at: 1) = (temp2 at: 1)) & (valueStreak1 size == 3) ifTrue: [ 				valueStreak := valueStreak1 , valueStreak1b]. 			((valueStreak2b at: 1) = (temp2 at: 1)) & (valueStreak2 size == 3)  ifTrue: [ 			   valueStreak := valueStreak2 , valueStreak2b]. 			]] 		ifFalse: [ 				Transcript show: 'f'; cr.				((valueStreak1 at: 1) = (temp1 at: 1)) & (valueStreak1 size == 3) ifTrue: [  					valueStreak := valueStreak1 , valueStreak1b].				((valueStreak2 at: 1) = (temp1 at: 1)) & (valueStreak2 size == 3) ifTrue: [  					valueStreak := valueStreak2 , valueStreak2b].				Transcript show: valueStreak1; show: valueStreak2 ; show: valueStreak; cr.		]	].	Transcript show: 'A'; cr.	"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted.   ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 10:08' prior: 34591385!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].		Transcript show: hand.	straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	"	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	Transcript show: valueStreak1; show: valueStreak2 ;cr.	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		temp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.		temp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		Transcript show: valueStreak1b; show: valueStreak2b ;cr.		(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1)  )		ifTrue: [ 			((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) 			ifTrue: [				Transcript show: 'g'; cr.			((valueStreak1b at: 1) = (temp2 at: 1)) & (valueStreak1 size == 3) ifTrue: [ 				valueStreak := valueStreak1 , valueStreak1b]. 			((valueStreak2b at: 1) = (temp2 at: 1)) & (valueStreak2 size == 3)  ifTrue: [ 			   valueStreak := valueStreak2 , valueStreak2b]. 			]] 		ifFalse: [ 				Transcript show: 'f'; cr.				(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak1 , valueStreak1b].				(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak2 , valueStreak2b].				Transcript show: valueStreak1; show: valueStreak2 ; show: valueStreak; cr.		]	].	Transcript show: 'A'; cr.	"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted.   ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 10:10' prior: 34597797!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].		Transcript show: hand.	straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	"	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	Transcript show: valueStreak1; show: valueStreak2 ;cr.	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		temp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.		temp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		Transcript show: valueStreak1b; show: valueStreak2b ;cr.		(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )		ifTrue: [ 			((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) 			ifTrue: [				Transcript show: 'g'; cr.			(valueStreak1 size == 3) & ((valueStreak1b at: 1) = (temp2 at: 1))  ifTrue: [ 				valueStreak := valueStreak1 , valueStreak1b]. 			(valueStreak2 size == 3) & ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ 			   valueStreak := valueStreak2 , valueStreak2b]. 			]] 		ifFalse: [ 				Transcript show: 'f'; cr.				(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak1 , valueStreak1b].				(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak2 , valueStreak2b].				Transcript show: valueStreak1; show: valueStreak2 ; show: valueStreak; cr.		]	].	Transcript show: 'A'; cr.	"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted.   ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 10:11' prior: 34604263!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].		Transcript show: hand.	straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	"	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	Transcript show: valueStreak1; show: valueStreak2 ;cr.	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		temp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.		temp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		Transcript show: valueStreak1b; show: valueStreak2b ;cr.		(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )		ifTrue: [ 			((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) 			ifTrue: [				Transcript show: 'g'; cr.			(valueStreak1 size == 3) & ((valueStreak1b at: 1) = (temp2 at: 1))  ifTrue: [ 				valueStreak := valueStreak1 , valueStreak1b]. 			(valueStreak2 size == 3) & ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ 			   valueStreak := valueStreak2 , valueStreak2b]. 				Transcript show: 'g'; cr.			]] 		ifFalse: [ 				Transcript show: 'f'; cr.				(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak1 , valueStreak1b].				(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak2 , valueStreak2b].				Transcript show: valueStreak1; show: valueStreak2 ; show: valueStreak; cr.		]	].	Transcript show: 'A'; cr.	"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted.   ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 10:13' prior: 34610729!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].		Transcript show: hand.	straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	"	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	Transcript show: valueStreak1; show: valueStreak2 ;cr.	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		temp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.		temp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		Transcript show: valueStreak1b; show: valueStreak2b ;cr.		(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )		ifTrue: [ 			((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) 			ifTrue: [				Transcript show: 'g'; cr.			(valueStreak1 size == 3) & (valueStreak1b size == 2) & ((valueStreak1b at: 1) = (temp2 at: 1))  ifTrue: [ 				valueStreak := valueStreak1 , valueStreak1b]. 			(valueStreak2 size == 3) & (valueStreak2b size == 2) & ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ 			   valueStreak := valueStreak2 , valueStreak2b]. 				Transcript show: 'g'; cr.			]] 		ifFalse: [ 				Transcript show: 'f'; cr.				(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak1 , valueStreak1b].				(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak2 , valueStreak2b].				Transcript show: valueStreak1; show: valueStreak2 ; show: valueStreak; cr.		]	].	Transcript show: 'A'; cr.	"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted.   ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 10:14' prior: 34617225!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].		Transcript show: hand.	straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	"	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	Transcript show: valueStreak1; show: valueStreak2 ;cr.	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		temp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.		temp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		Transcript show: valueStreak1b; show: valueStreak2b ; show: temp1; show: temp2 ;cr.		(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )		ifTrue: [ 			((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) 			ifTrue: [				Transcript show: 'g'; cr.			(valueStreak1 size == 3) & (valueStreak1b size == 2) & ((valueStreak1b at: 1) = (temp2 at: 1))  ifTrue: [ 				valueStreak := valueStreak1 , valueStreak1b]. 			(valueStreak2 size == 3) & (valueStreak2b size == 2) & ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ 			   valueStreak := valueStreak2 , valueStreak2b]. 				Transcript show: 'g'; cr.			]] 		ifFalse: [ 				Transcript show: 'f'; cr.				(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak1 , valueStreak1b].				(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak2 , valueStreak2b].				Transcript show: valueStreak1; show: valueStreak2 ; show: valueStreak; cr.		]	].	Transcript show: 'A'; cr.	"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted.   ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 10:14' prior: 34623777!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].		Transcript show: hand.	straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	"	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	Transcript show: valueStreak1; show: valueStreak2 ;cr.	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		temp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.		temp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		Transcript show: valueStreak1b; show: valueStreak2b ; show: temp1; show: temp2; cr.		(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )		ifTrue: [ 			((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) 			ifTrue: [				Transcript show: 'g'; cr.			(valueStreak1 size == 3) & (valueStreak1b size == 2) & ((valueStreak1b at: 1) = (temp2 at: 1))  ifTrue: [ 				valueStreak := valueStreak1 , valueStreak1b]. 			(valueStreak2 size == 3) & (valueStreak2b size == 2) & ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ 			   valueStreak := valueStreak2 , valueStreak2b]. 				Transcript show: 'g'; cr.			]] 		ifFalse: [ 				Transcript show: 'f'; cr.				(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak1 , valueStreak1b].				(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak2 , valueStreak2b].				Transcript show: valueStreak1; show: valueStreak2 ; show: valueStreak; cr.		]	].	Transcript show: 'A'; cr.	"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted.   ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 10:16' prior: 34630356!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].		Transcript show: hand.	straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	"	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	Transcript show: valueStreak1; show: valueStreak2 ;cr.	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		temp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.		temp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		Transcript show: valueStreak1b; show: (valueStreak1b size == 2) ; show: temp1; show: temp2; cr.		(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )		ifTrue: [ 			((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) 			ifTrue: [				Transcript show: 'g'; cr.			(valueStreak1 size == 3) & (valueStreak1b size == 2) & ((valueStreak1b at: 1) = (temp2 at: 1))  ifTrue: [ 				valueStreak := valueStreak1 , valueStreak1b]. 			(valueStreak2 size == 3) & (valueStreak2b size == 2) & ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ 			   valueStreak := valueStreak2 , valueStreak2b]. 				Transcript show: 'g'; cr.			]] 		ifFalse: [ 				Transcript show: 'f'; cr.				(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak1 , valueStreak1b].				(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak2 , valueStreak2b].				Transcript show: valueStreak1; show: valueStreak2 ; show: valueStreak; cr.		]	].	Transcript show: 'A'; cr.	"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted.   ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 10:18' prior: 34636935!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].		Transcript show: hand.	straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	"	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	Transcript show: valueStreak1; show: valueStreak2 ;cr.	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		temp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.		temp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		Transcript show: valueStreak1b; show: (valueStreak1b size == 2) ; show: temp1; show: temp2; cr.		(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )		ifTrue: [ 			((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) 			ifTrue: [				Transcript show: 'g'; cr.			(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1))  ifTrue: [ 				valueStreak := valueStreak1 , valueStreak1b]]. 			(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ 			   valueStreak := valueStreak2 , valueStreak2b]]. 				Transcript show: 'g'; cr.			]] 		ifFalse: [ 				Transcript show: 'f'; cr.				(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak1 , valueStreak1b].				(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak2 , valueStreak2b].				Transcript show: valueStreak1; show: valueStreak2 ; show: valueStreak; cr.		]	].	Transcript show: 'A'; cr.	"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted.   ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 10:40' prior: 34224144!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak twoFound |streaks := OrderedCollection new.notFound := true.twoFound := 0.2 to: nice size do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).	(previous asNumber == 2) ifTrue: [ twoFound := 1 ].	(previous ~= current) ifTrue: [  	( ( ( (current asNumber == 1 & ( previous asNumber == 13 ) ) | (current asNumber == 1 & ( twoFound == 1 ) ) ) | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )		ifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]		ifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]] ]].highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 10:43' prior: 34650135!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak twoFound |streaks := OrderedCollection new.notFound := true.twoFound := 0.2 to: nice size do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).	(previous asNumber == 2) ifTrue: [ twoFound := 1 ].	(previous ~= current) ifTrue: [  	( ( ( (current asNumber == 1 & ( previous asNumber == 13 ) ) | (current asNumber == 1 & ( twoFound == 1 ) ) ) | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )		ifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]		ifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]] ]].highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].Transcript show: highestStreak.^highestStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 10:44' prior: 34651359!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak twoFound |streaks := OrderedCollection new.notFound := true.twoFound := 0.2 to: nice size do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).	(previous asNumber == 2) ifTrue: [ twoFound := 1 ].	(previous ~= current) ifTrue: [  	( ( ( (current asNumber == 1 & ( previous asNumber == 13 ) ) | (current asNumber == 1 & ( twoFound == 1 ) ) ) | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )		ifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]		ifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]] ]].highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].Transcript cr; show: highestStreak; cr.^highestStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 10:44' prior: 34652614!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak twoFound |streaks := OrderedCollection new.notFound := true.twoFound := 0.2 to: nice size do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).	(previous asNumber == 2) ifTrue: [ twoFound := 1 ].	(previous ~= current) ifTrue: [  	( ( ( (current asNumber == 1 & ( previous asNumber == 13 ) ) | (current asNumber == 1 & ( twoFound == 1 ) ) ) | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )		ifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]		ifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]] ]].Transcript cr; show: streaks; cr.highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 10:46' prior: 34653877!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak twoFound |streaks := OrderedCollection new.notFound := true.twoFound := 0.2 to: nice size do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).	(previous asNumber == 2) ifTrue: [ twoFound := 1 ].	(previous ~= current) ifTrue: [  	( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )		ifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]		ifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]] ]].Transcript cr; show: streaks ; cr.highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 10:47' prior: 34655134!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak twoFound |streaks := OrderedCollection new.notFound := true.twoFound := 0.2 to: nice size do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).	(previous asNumber == 2) ifTrue: [ twoFound := 1 ].	(previous ~= current) ifTrue: [  	( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )		ifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]		ifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]] ]].Transcript show: 'h'; cr; show: streaks ; cr.highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 10:48' prior: 34643526!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	Transcript show: sorted1;cr;show: sorted2;cr.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].		Transcript show: hand.	straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	"	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	Transcript show: valueStreak1; show: valueStreak2 ;cr.	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		temp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.		temp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		Transcript show: valueStreak1b; show: (valueStreak1b size == 2) ; show: temp1; show: temp2; cr.		(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )		ifTrue: [ 			((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) 			ifTrue: [				Transcript show: 'g'; cr.			(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1))  ifTrue: [ 				valueStreak := valueStreak1 , valueStreak1b]]. 			(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ 			   valueStreak := valueStreak2 , valueStreak2b]]. 				Transcript show: 'g'; cr.			]] 		ifFalse: [ 				Transcript show: 'f'; cr.				(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak1 , valueStreak1b].				(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak2 , valueStreak2b].				Transcript show: valueStreak1; show: valueStreak2 ; show: valueStreak; cr.		]	].	Transcript show: 'A'; cr.	"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted.   ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 11:00' prior: 34656342!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak aceFound |streaks := OrderedCollection new.notFound := true.aceFound := 0.2 to: nice size do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).	(current asNumber == 1) ifTrue: [ aceFound := i ].	(previous ~= current) ifTrue: [  	( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )		ifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]		ifFalse: [			Transcript show: streaks.			((streaks size == 4) & (previous asNumber == 5)) ifTrue: [ (aceFound ~= 0) ifTrue: [streaks add: (nice at: aceFound)] ] 				ifFalse: [ (streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false] ]. ]]].Transcript show: 'h'; cr; show: streaks ; cr.highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 11:01' prior: 34664216!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak aceFound |streaks := OrderedCollection new.notFound := true.aceFound := 0.2 to: nice size do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).	(current asNumber == 1) ifTrue: [ aceFound := i ].	(previous ~= current) ifTrue: [  	( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )		ifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]		ifFalse: [			Transcript show: streaks.			((streaks size == 4) & (previous asNumber == 5)) ifTrue: [ (aceFound ~= 0) ifTrue: [streaks add: (nice at: aceFound). Transcript show: streaks.] ] 				ifFalse: [ (streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false] ]. ]]].Transcript show: 'h'; cr; show: streaks ; cr.highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 11:01' prior: 34665607!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak aceFound |streaks := OrderedCollection new.notFound := true.aceFound := 0.2 to: nice size do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).	(current asNumber == 1) ifTrue: [ aceFound := i ].	(previous ~= current) ifTrue: [  	( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )		ifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]		ifFalse: [			Transcript show: streaks.			((streaks size == 4) & (previous asNumber == 5)) ifTrue: [ (aceFound ~= 0) ifTrue: [streaks add: (nice at: aceFound). Transcript show: 'here'; cr; show: streaks.] ] 				ifFalse: [ (streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false] ]. ]]].Transcript show: 'h'; cr; show: streaks ; cr.highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 11:02' prior: 34667025!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak aceFound |streaks := OrderedCollection new.notFound := true.aceFound := 0.2 to: nice size do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).	(current asNumber == 1) ifTrue: [ aceFound := i ].	(previous ~= current) ifTrue: [  	( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )		ifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]		ifFalse: [			Transcript show: streaks.			((streaks size == 4) & (current asNumber == 5)) ifTrue: [ (aceFound ~= 0) ifTrue: [streaks add: (nice at: aceFound). Transcript show: 'here'; cr; show: streaks.] ] 				ifFalse: [ (streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false] ]. ]]].Transcript show: 'h'; cr; show: streaks ; cr.highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 11:03' prior: 34668461!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak aceFound |streaks := OrderedCollection new.notFound := true.aceFound := 0.2 to: nice size do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).	(current asNumber == 1) ifTrue: [ aceFound := i ].	(previous ~= current) ifTrue: [  	( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )		ifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]		ifFalse: [			Transcript show: current.			((streaks size == 4) & (current asNumber == 5)) ifTrue: [ (aceFound ~= 0) ifTrue: [streaks add: (nice at: aceFound). Transcript cr ;show: 'here'; cr; show: streaks.] ] 				ifFalse: [ (streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false] ]. ]]].Transcript show: 'h'; cr; show: streaks ; cr.highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 11:04' prior: 34669896!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak aceFound |streaks := OrderedCollection new.notFound := true.aceFound := 0.2 to: nice size do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).	(current asNumber == 1) ifTrue: [ aceFound := i ].	(previous ~= current) ifTrue: [  	( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )		ifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]		ifFalse: [			Transcript show: previous.			((streaks size == 4) & (previous asNumber == 5)) ifTrue: [ (aceFound ~= 0) ifTrue: [streaks add: (nice at: aceFound). Transcript cr ;show: 'here'; cr; show: streaks.] ] 				ifFalse: [ (streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false] ]. ]]].Transcript show: 'h'; cr; show: streaks ; cr.highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 11:04' prior: 34671335!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak aceFound |streaks := OrderedCollection new.notFound := true.aceFound := 0.2 to: nice size do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).	(current asNumber == 1) ifTrue: [ aceFound := i ].	(previous ~= current) ifTrue: [  	( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )		ifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]		ifFalse: [			Transcript show: streaks.			((streaks size == 4) & (previous asNumber == 5)) ifTrue: [ (aceFound ~= 0) ifTrue: [streaks add: (nice at: aceFound). Transcript cr ;show: 'here'; cr; show: streaks.] ] 				ifFalse: [ (streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false] ]. ]]].Transcript show: 'h'; cr; show: streaks ; cr.highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 11:07' prior: 34672776!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak aceFound |streaks := OrderedCollection new.notFound := true.aceFound := nice detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].2 to: nice size do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).	(current asNumber == 1) ifTrue: [ aceFound := i ].	(previous ~= current) ifTrue: [  	( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )		ifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]		ifFalse: [			Transcript show: streaks.			((streaks size == 4) & (previous asNumber == 5)) ifTrue: [ (aceFound ~= 0) ifTrue: [streaks add: (nice at: aceFound). Transcript cr ;show: 'here'; cr; show: streaks.] ] 				ifFalse: [ (streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false] ]. ]]].Transcript show: 'h'; cr; show: streaks ; cr.highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 11:07' prior: 34674216!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak aceFound |streaks := OrderedCollection new.notFound := true.aceFound := nice detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].2 to: nice size do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).	(previous ~= current) ifTrue: [  	( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )		ifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]		ifFalse: [			Transcript show: streaks.			((streaks size == 4) & (previous asNumber == 5)) ifTrue: [ (aceFound ~= 0) ifTrue: [streaks add: (nice at: aceFound). Transcript cr ;show: 'here'; cr; show: streaks.] ] 				ifFalse: [ (streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false] ]. ]]].Transcript show: 'h'; cr; show: streaks ; cr.highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 11:10' prior: 34675733!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak aceFound |streaks := OrderedCollection new.notFound := true.aceFound := nice detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].2 to: nice size do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).	(previous ~= current) ifTrue: [  	( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )		ifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]		ifFalse: [			Transcript show: streaks.			((streaks size == 4) & (previous asNumber == 5)) ifTrue: [ (aceFound ~= 0) ifTrue: [streaks add: aceFound. Transcript cr ;show: 'here'; cr; show: streaks.] ] 				ifFalse: [ (streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false] ]. ]]].Transcript show: 'h'; cr; show: streaks ; cr.highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 12:03' prior: 34677198!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak |streaks := OrderedCollection new.notFound := true.2 to: nice size do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).	(previous ~= current) ifTrue: [  	( ( (current asNumber == 1 & ( previous asNumber == 13 ) ) | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )		ifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]		ifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]] ]].Transcript show: 'here';cr.Transcript show: streaks; cr.highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 12:03' prior: 34678652!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak |streaks := OrderedCollection new.notFound := true.2 to: nice size do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).	(previous ~= current) ifTrue: [  	( ( (current asNumber == 1 & ( previous asNumber == 13 ) ) | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )		ifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]		ifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]] ]].highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 12:04' prior: 34657561!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].		Transcript show: hand.	straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	"	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		temp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.		temp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )		ifTrue: [ 			((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) 			ifTrue: [			(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1))  ifTrue: [ 				valueStreak := valueStreak1 , valueStreak1b]]. 			(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ 			   valueStreak := valueStreak2 , valueStreak2b]]. 							]] 		ifFalse: [ 								(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak1 , valueStreak1b].				(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak2 , valueStreak2b].						]	].		"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted.   ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 12:04' prior: 34680901!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].			straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	"	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		temp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.		temp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )		ifTrue: [ 			((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) 			ifTrue: [			(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1))  ifTrue: [ 				valueStreak := valueStreak1 , valueStreak1b]]. 			(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ 			   valueStreak := valueStreak2 , valueStreak2b]]. 							]] 		ifFalse: [ 								(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak1 , valueStreak1b].				(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak2 , valueStreak2b].						]	].		"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted.   ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 12:08' prior: 34687179!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].			straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	"	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		temp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.		temp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		Transcript show: temp2.		(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )		ifTrue: [ 			((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) 			ifTrue: [			(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1))  ifTrue: [ 				valueStreak := valueStreak1 , valueStreak1b]]. 			(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ 			   valueStreak := valueStreak2 , valueStreak2b]]. 							]] 		ifFalse: [ 								(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak1 , valueStreak1b].				(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak2 , valueStreak2b].						]	].		"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted.   ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 12:08' prior: 34693435!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].			straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	"	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		temp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.		temp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )		ifTrue: [ 			((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) 			ifTrue: [			Transcript show: temp2.			(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1))  ifTrue: [ 				valueStreak := valueStreak1 , valueStreak1b]]. 			(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ 			   valueStreak := valueStreak2 , valueStreak2b]]. 							]] 		ifFalse: [ 								(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak1 , valueStreak1b].				(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak2 , valueStreak2b].						]	].		"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted.   ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 12:09' prior: 34699716!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].			straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	"	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		temp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.		temp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )		ifTrue: [ 			((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) 			ifTrue: [					(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ Transcript show: temp2. ((valueStreak1b at: 1) = (temp2 at: 1))  ifTrue: [ 				valueStreak := valueStreak1 , valueStreak1b]]. 			(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ 			   valueStreak := valueStreak2 , valueStreak2b]]. 							]] 		ifFalse: [ 								(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak1 , valueStreak1b].				(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak2 , valueStreak2b].						]	].		"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted.   ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 12:09' prior: 34705997!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].			straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	"	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		temp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.		temp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )		ifTrue: [ 			((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) 			ifTrue: [					(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ Transcript show: valueStreak1b. ((valueStreak1b at: 1) = (temp2 at: 1))  ifTrue: [ 				valueStreak := valueStreak1 , valueStreak1b]]. 			(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ 			   valueStreak := valueStreak2 , valueStreak2b]]. 							]] 		ifFalse: [ 								(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak1 , valueStreak1b].				(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak2 , valueStreak2b].						]	].		"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted.   ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 12:11' prior: 34712278!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].			straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	"	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		temp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.		temp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )		ifTrue: [ 			((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) 			ifTrue: [					(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ Transcript show: valueStreak1. ((valueStreak1b at: 1) = (temp2 at: 1))  ifTrue: [ 				valueStreak := valueStreak1 , valueStreak1b]]. 			(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ 			   valueStreak := valueStreak2 , valueStreak2b]]. 							]] 		ifFalse: [ 								(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak1 , valueStreak1b].				(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak2 , valueStreak2b].						]	].		"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted.   ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 12:13' prior: 34718567!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].			straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	"	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		temp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.		temp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )		ifTrue: [ 			((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) 			ifTrue: [					(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ Transcript show: valueStreak1b. ((valueStreak1b at: 1) = (temp2 at: 1))  ifTrue: [ 				valueStreak := valueStreak1 , valueStreak1b]]. 			(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ 			   valueStreak := valueStreak2 , valueStreak2b]]. 							]] 		ifFalse: [ 								(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak1 , valueStreak1b].				(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak2 , valueStreak2b].						]	].		"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted.   ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 12:23' prior: 34724855!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].			straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	"	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		temp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.		temp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )		ifTrue: [ 			((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) 			ifTrue: [					(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ 				valueStreak := valueStreak1 , valueStreak1b]]. 			(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ 			   valueStreak := valueStreak2 , valueStreak2b]]. 							]] 		ifFalse: [ 								(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak1 , valueStreak1b].				(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak2 , valueStreak2b].						]	].		"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].		flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted.   ! !----SNAPSHOT----2021-02-12T12:26:10.242131-05:00 game1.image priorSource: 888676!----SNAPSHOT----2021-02-12T13:19:47.452131-05:00 game1.image priorSource: 1182906!!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 13:21' prior: 34679806!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak aceFound |streaks := OrderedCollection new.notFound := true.aceFound := nice detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].2 to: nice size do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).	(previous ~= current) ifTrue: [  	( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )		ifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]		ifFalse: [			Transcript show: streaks.			((streaks size == 4) & (previous asNumber == 5)) ifTrue: [ (aceFound ~= 0) ifTrue: [streaks add: aceFound. Transcript cr ;show: 'here'; cr; show: streaks.] ] 				ifFalse: [ (streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false] ]. ]]].Transcript show: 'h'; cr; show: streaks ; cr.highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 13:41' prior: 34731144!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 test1 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].			straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	"	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		temp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.		temp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )		ifTrue: [ 			((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) 			ifTrue: [					(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ 				valueStreak := valueStreak1 , valueStreak1b]]. 			(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ 			   valueStreak := valueStreak2 , valueStreak2b]]. 							]] 		ifFalse: [ 								(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak1 , valueStreak1b].				(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak2 , valueStreak2b].						]	].		"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].			flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		test1 = 0.	temp1 := straight1 select: [:a | test1:=test1+1. ( a copyFrom: 1 to: (a size-1) ) asNumber == test1].	test1 = 0.	temp2 := straight2 select: [:a | test1:=test1+1. ( a copyFrom: 1 to: (a size-1) ) asNumber == test1].	straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight isEmpty) ifTrue: [ temp1 size == 5 ifTrue: [ straight := temp1 ]. temp2 size == 5 ifTrue: [ straight := temp2 ]  ].		(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted.   ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 13:43' prior: 34739048!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 test1 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].		Transcript cr; cr; show: straightFlush1 ; cr; cr; show: straightFlush2; cr.	straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	"	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		temp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.		temp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )		ifTrue: [ 			((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) 			ifTrue: [					(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ 				valueStreak := valueStreak1 , valueStreak1b]]. 			(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ 			   valueStreak := valueStreak2 , valueStreak2b]]. 							]] 		ifFalse: [ 								(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak1 , valueStreak1b].				(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak2 , valueStreak2b].						]	].		"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].			flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		test1 = 0.	temp1 := straight1 select: [:a | test1:=test1+1. ( a copyFrom: 1 to: (a size-1) ) asNumber == test1].	test1 = 0.	temp2 := straight2 select: [:a | test1:=test1+1. ( a copyFrom: 1 to: (a size-1) ) asNumber == test1].	straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight isEmpty) ifTrue: [ temp1 size == 5 ifTrue: [ straight := temp1 ]. temp2 size == 5 ifTrue: [ straight := temp2 ]  ].		(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted.   ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 13:44' prior: 34745698!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 test1 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].		Transcript cr; cr; show: straightFlush1 ; cr; cr; show: straightFlush2; cr.	straightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.	Transcript cr; cr; show: straightFlush.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	"	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		temp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.		temp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )		ifTrue: [ 			((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) 			ifTrue: [					(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ 				valueStreak := valueStreak1 , valueStreak1b]]. 			(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ 			   valueStreak := valueStreak2 , valueStreak2b]]. 							]] 		ifFalse: [ 								(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak1 , valueStreak1b].				(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak2 , valueStreak2b].						]	].		"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].			flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		test1 = 0.	temp1 := straight1 select: [:a | test1:=test1+1. ( a copyFrom: 1 to: (a size-1) ) asNumber == test1].	test1 = 0.	temp2 := straight2 select: [:a | test1:=test1+1. ( a copyFrom: 1 to: (a size-1) ) asNumber == test1].	straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight isEmpty) ifTrue: [ temp1 size == 5 ifTrue: [ straight := temp1 ]. temp2 size == 5 ifTrue: [ straight := temp2 ]  ].		(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted.   ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 14:27' prior: 34752423!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 test1 test2 test3 test4 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].		Transcript cr; cr; show: straightFlush1 ; cr; cr; show: straightFlush2; cr.		temp1 := OrderedCollection new.	temp2 := OrderedCollection new.	test1 := 0. 	test2 := 0. 	test3 := 0. 	test4 := 0.    temp1 := straight1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	temp2 := straight2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	test1 := straight1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test2 := straight2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].	test4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].			test3 >= test4 ifTrue: [ straightFlush := temp1 ] ifFalse: [  straightFlush := temp2  ].		(test1 ~= 0 ) ifTrue: [ straightFlush add: test1 ].		(test2 ~= 0 ) ifTrue: [ straightFlush add: test2 ].	"straightFlush := self sizeCheck: 5 firstList: temp1 secondList: temp2."	Transcript cr; cr; show: straightFlush.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	"	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		temp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.		temp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )		ifTrue: [ 			((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) 			ifTrue: [					(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ 				valueStreak := valueStreak1 , valueStreak1b]]. 			(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ 			   valueStreak := valueStreak2 , valueStreak2b]]. 							]] 		ifFalse: [ 								(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak1 , valueStreak1b].				(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak2 , valueStreak2b].						]	].		"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].			flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		test1 = 0.	temp1 := straight1 select: [:a | test1:=test1+1. ( a copyFrom: 1 to: (a size-1) ) asNumber == test1].	test1 = 0.	temp2 := straight2 select: [:a | test1:=test1+1. ( a copyFrom: 1 to: (a size-1) ) asNumber == test1].	straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight isEmpty) ifTrue: [ temp1 size == 5 ifTrue: [ straight := temp1 ]. temp2 size == 5 ifTrue: [ straight := temp2 ]  ].		(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted.   ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 14:29' prior: 34759189!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 test1 test2 test3 test4 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].		Transcript cr; cr; show: straightFlush1 ; cr; cr; show: straightFlush2; cr.		temp1 := OrderedCollection new.	temp2 := OrderedCollection new.	test1 := 0. 	test2 := 0. 	test3 := 0. 	test4 := 0.    temp1 := straight1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	temp2 := straight2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	test1 := straight1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test2 := straight2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].	test4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].			test3 >= test4 ifTrue: [ straightFlush := temp1.(test1 ~= 0 ) ifTrue: [ straightFlush add: test1 ]. ] 							ifFalse: [  straightFlush := temp2. (test2 ~= 0 ) ifTrue: [ straightFlush add: test2 ]. ].	"straightFlush := self sizeCheck: 5 firstList: temp1 secondList: temp2."	Transcript cr; cr; show: straightFlush.	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	"	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		temp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.		temp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )		ifTrue: [ 			((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) 			ifTrue: [					(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ 				valueStreak := valueStreak1 , valueStreak1b]]. 			(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ 			   valueStreak := valueStreak2 , valueStreak2b]]. 							]] 		ifFalse: [ 								(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak1 , valueStreak1b].				(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak2 , valueStreak2b].						]	].		"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].			flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		test1 = 0.	temp1 := straight1 select: [:a | test1:=test1+1. ( a copyFrom: 1 to: (a size-1) ) asNumber == test1].	test1 = 0.	temp2 := straight2 select: [:a | test1:=test1+1. ( a copyFrom: 1 to: (a size-1) ) asNumber == test1].	straight := self sizeCheck: 5 firstList: straight1 secondList: straight2.	(straight isEmpty) ifTrue: [ temp1 size == 5 ifTrue: [ straight := temp1 ]. temp2 size == 5 ifTrue: [ straight := temp2 ]  ].		(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted.   ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 14:33' prior: 34766825!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 test1 test2 test3 test4 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].		Transcript cr; cr; show: straightFlush1 ; cr; cr; show: straightFlush2; cr.		temp1 := OrderedCollection new.	temp2 := OrderedCollection new.	test1 := 0. 	test2 := 0. 	test3 := 0. 	test4 := 0.    temp1 := straight1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	temp2 := straight2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	test1 := straight1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test2 := straight2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].	test4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].			test3 >= test4 ifTrue: [ straightFlush := temp1.(test1 ~= 0 ) ifTrue: [ straightFlush add: test1 ]. ] 							ifFalse: [  straightFlush := temp2. (test2 ~= 0 ) ifTrue: [ straightFlush add: test2 ]. ].	"straightFlush := self sizeCheck: 5 firstList: temp1 secondList: temp2."	"Transcript cr; cr; show: straightFlush."	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	"	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		temp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.		temp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )		ifTrue: [ 			((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) 			ifTrue: [					(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ 				valueStreak := valueStreak1 , valueStreak1b]]. 			(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ 			   valueStreak := valueStreak2 , valueStreak2b]]. 							]] 		ifFalse: [ 								(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak1 , valueStreak1b].				(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak2 , valueStreak2b].						]	].		"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].			flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		temp1 := OrderedCollection new.	temp2 := OrderedCollection new.	test1 := 0. 	test2 := 0. 	test3 := 0. 	test4 := 0.    temp1 := straight1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	temp2 := straight2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	test1 := straight1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test2 := straight2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].	test4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].			test3 >= test4 ifTrue: [ straight := temp1.(test1 ~= 0 ) ifTrue: [ straight add: test1 ]. ] 							ifFalse: [  straight := temp2. (test2 ~= 0 ) ifTrue: [ straight add: test2 ]. ].			(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted.   ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 14:34' prior: 34774465!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 test1 test2 test3 test4 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.	"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].		Transcript cr; cr; show: straightFlush1 ; cr; cr; show: straightFlush2; cr.		temp1 := OrderedCollection new.	temp2 := OrderedCollection new.	test1 := 0. 	test2 := 0. 	test3 := 0. 	test4 := 0.    temp1 := straightFlush1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	temp2 := straightFlush2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	test1 := straightFlush1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test2 := straightFlush2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].	test4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].			test3 >= test4 ifTrue: [ straightFlush := temp1.(test1 ~= 0 ) ifTrue: [ straightFlush add: test1 ]. ] 							ifFalse: [  straightFlush := temp2. (test2 ~= 0 ) ifTrue: [ straightFlush add: test2 ]. ].	"straightFlush := self sizeCheck: 5 firstList: temp1 secondList: temp2."	"Transcript cr; cr; show: straightFlush."	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	"	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		temp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.		temp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )		ifTrue: [ 			((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) 			ifTrue: [					(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ 				valueStreak := valueStreak1 , valueStreak1b]]. 			(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ 			   valueStreak := valueStreak2 , valueStreak2b]]. 							]] 		ifFalse: [ 								(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak1 , valueStreak1b].				(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak2 , valueStreak2b].						]	].		"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].			flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		temp1 := OrderedCollection new.	temp2 := OrderedCollection new.	test1 := 0. 	test2 := 0. 	test3 := 0. 	test4 := 0.    temp1 := straight1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	temp2 := straight2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	test1 := straight1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test2 := straight2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].	test4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].			test3 >= test4 ifTrue: [ straight := temp1.(test1 ~= 0 ) ifTrue: [ straight add: test1 ]. ] 							ifFalse: [  straight := temp2. (test2 ~= 0 ) ifTrue: [ straight add: test2 ]. ].			(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted.   ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 14:41' prior: 34782525!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 test1 test2 test3 test4 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.		Transcript cr; cr; show: sorted1 ; cr; cr; show: sorted2; cr.		"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].		Transcript cr; cr; show: straightFlush1 ; cr; cr; show: straightFlush2; cr.		temp1 := OrderedCollection new.	temp2 := OrderedCollection new.	test1 := 0. 	test2 := 0. 	test3 := 0. 	test4 := 0.    temp1 := straightFlush1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	temp2 := straightFlush2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	test1 := straightFlush1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test2 := straightFlush2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].	test4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].			test3 >= test4 ifTrue: [ straightFlush := temp1.(test1 ~= 0 ) ifTrue: [ straightFlush add: test1 ]. ] 							ifFalse: [  straightFlush := temp2. (test2 ~= 0 ) ifTrue: [ straightFlush add: test2 ]. ].	"straightFlush := self sizeCheck: 5 firstList: temp1 secondList: temp2."	"Transcript cr; cr; show: straightFlush."	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	"	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		temp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.		temp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )		ifTrue: [ 			((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) 			ifTrue: [					(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ 				valueStreak := valueStreak1 , valueStreak1b]]. 			(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ 			   valueStreak := valueStreak2 , valueStreak2b]]. 							]] 		ifFalse: [ 								(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak1 , valueStreak1b].				(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak2 , valueStreak2b].						]	].		"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].			flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		temp1 := OrderedCollection new.	temp2 := OrderedCollection new.	test1 := 0. 	test2 := 0. 	test3 := 0. 	test4 := 0.    temp1 := straight1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	temp2 := straight2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	test1 := straight1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test2 := straight2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].	test4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].			test3 >= test4 ifTrue: [ straight := temp1.(test1 ~= 0 ) ifTrue: [ straight add: test1 ]. ] 							ifFalse: [  straight := temp2. (test2 ~= 0 ) ifTrue: [ straight add: test2 ]. ].			(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted.   ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 14:48' prior: 34737594!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak aceFound |streaks := OrderedCollection new.notFound := true.aceFound := nice detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].2 to: nice size do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).	(previous ~= current) ifTrue: [  	( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )		ifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]		ifFalse: [			Transcript show: streaks; cr;cr.			((streaks size == 4) & (previous asNumber == 5)) ifTrue: [ (aceFound ~= 0) ifTrue: [streaks add: aceFound. Transcript cr ;show: 'here'; cr; show: streaks.] ] 				ifFalse: [ (streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false] ]. ]]].Transcript show: 'h'; cr; show: streaks ; cr.highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 14:51' prior: 34798752!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak aceFound |streaks := OrderedCollection new.notFound := true.aceFound := nice detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].2 to: nice size do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).	(previous ~= current) ifTrue: [  	( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )		ifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]		ifFalse: [			Transcript show: previous; cr;cr.			((streaks size == 4) & (previous asNumber == 5)) ifTrue: [ (aceFound ~= 0) ifTrue: [streaks add: aceFound. Transcript cr ;show: 'here'; cr; show: streaks.] ] 				ifFalse: [ (streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false] ]. ]]].Transcript show: 'h'; cr; show: streaks ; cr.highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 14:52' prior: 34800213!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak aceFound |streaks := OrderedCollection new.notFound := true.aceFound := nice detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].2 to: nice size do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).	(previous ~= current) ifTrue: [  	( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )		ifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]		ifFalse: [			Transcript show: previous; show: streaks;cr.			((streaks size == 4) & (previous asNumber == 5)) ifTrue: [ (aceFound ~= 0) ifTrue: [streaks add: aceFound. Transcript cr ;show: 'here'; cr; show: streaks.] ] 				ifFalse: [ (streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false] ]. ]]].Transcript show: 'h'; cr; show: streaks ; cr.highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 15:00' prior: 34801675!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak aceFound |streaks := OrderedCollection new.notFound := true.aceFound := nice detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].2 to: nice size do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).	(previous ~= current) ifTrue: [  	( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) | ((streaks size == 4) & (previous asNumber == 5))  )		ifTrue: [((streaks size == 4) & (previous asNumber == 5)) 			ifTrue: [ (aceFound ~= 0) ifTrue: [streaks add: aceFound. Transcript cr ;show: 'here'; cr; show: streaks.] ] 			ifFalse: [ (streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]]		ifFalse: [			Transcript show: previous; show: streaks;cr.			(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]. ]]].Transcript show: 'h'; cr; show: streaks ; cr.highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 15:08' prior: 34803148!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak aceFound |streaks := OrderedCollection new.notFound := true.aceFound := nice detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].2 to: nice size do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).	(previous ~= current) ifTrue: [  	( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) | ((aceFound ~= 0) & (previous asNumber == 2))  )		ifTrue: [(aceFound ~= 0) & (previous asNumber == 2) 			ifTrue: [ (aceFound ~= 0) & (previous asNumber == 2) ifTrue: [streaks add: aceFound. Transcript cr ;show: 'here'; cr; show: streaks.] ]. 			(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]		ifFalse: [			Transcript show: previous; show: streaks;cr.			(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]. ]]].Transcript show: 'h'; cr; show: streaks ; cr.highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 15:11' prior: 34804675!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak aceFound |streaks := OrderedCollection new.notFound := true.aceFound := nice detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].2 to: nice size do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).	(previous ~= current) ifTrue: [  	( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) | ((aceFound ~= 0) & (previous asNumber == 2))  )		ifTrue: [(aceFound ~= 0) & (previous asNumber == 2) 			ifTrue: [ (aceFound ~= 0) & (previous asNumber == 2) ifTrue: [streaks add: aceFound. Transcript cr ;show: 'here'; cr; show: streaks.] ]. 			(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]		ifFalse: [			Transcript show: previous; show: streaks;cr.			(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]. ]]].Transcript show: 'h'; cr; show: streaks ; cr.highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 15:13' prior: 34806208!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak aceFound |streaks := OrderedCollection new.notFound := true.aceFound := nice detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].2 to: nice size do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).	(previous ~= current) ifTrue: [  	( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) | ((aceFound ~= 0) & (previous asNumber == 2))  )		ifTrue: [			(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card.			(aceFound ~= 0) & (previous asNumber == 2) 			ifTrue: [ (aceFound ~= 0) & (previous asNumber == 2) ifTrue: [streaks add: aceFound. Transcript cr ;show: 'here'; cr; show: streaks.] ]. ]		ifFalse: [			Transcript show: previous; show: streaks;cr.			(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]. ]]].Transcript show: 'h'; cr; show: streaks ; cr.highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 15:13' prior: 34807741!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak aceFound |streaks := OrderedCollection new.notFound := true.aceFound := nice detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].2 to: nice size do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).	(previous ~= current) ifTrue: [  	( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) | ((aceFound ~= 0) & (previous asNumber == 2))  )		ifTrue: [			(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card.			(aceFound ~= 0) & (previous asNumber == 2) 			ifTrue: [ (aceFound ~= 0) & (previous asNumber == 2) ifTrue: [streaks add: aceFound. Transcript cr ;show: 'here'; cr; show: streaks.] ] ]		ifFalse: [			Transcript show: previous; show: streaks;cr.			(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]. ]]].Transcript show: 'h'; cr; show: streaks ; cr.highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 15:15' prior: 34809279!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak aceFound |streaks := OrderedCollection new.notFound := true.aceFound := nice detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].2 to: nice size do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).	(previous ~= current) ifTrue: [  	( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) | ((aceFound ~= 0) & (previous asNumber == 2) & (current asNumber == 3)) )		ifTrue: [			(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card.			(aceFound ~= 0) & (previous asNumber == 2) 			ifTrue: [ (aceFound ~= 0) & (previous asNumber == 2) & (current asNumber == 3) ifTrue: [streaks add: aceFound. Transcript cr ;show: 'here'; cr; show: streaks.] ] ]		ifFalse: [			Transcript show: previous; show: streaks;cr.			(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]. ]]].Transcript show: 'h'; cr; show: streaks ; cr.highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 15:17' prior: 34810816!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak aceFound |streaks := OrderedCollection new.notFound := true.aceFound := nice detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].2 to: nice size do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).	(previous ~= current) ifTrue: [  	( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) | ((aceFound ~= 0) & (previous asNumber == 2) & (current asNumber == 3)) )		ifTrue: [			(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card.			(aceFound ~= 0) & (previous asNumber == 2) & (current asNumber == 3)			ifTrue: [ streaks add: aceFound. Transcript cr ;show: 'here'; cr; show: streaks.] ]		ifFalse: [			Transcript show: previous; show: streaks;cr.			(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]. ]]].Transcript show: 'h'; cr; show: streaks ; cr.highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 15:20' prior: 34812404!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak aceFound |streaks := OrderedCollection new.notFound := true.aceFound := nice detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].2 to: nice size do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).	(previous ~= current) ifTrue: [  	( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) | ((aceFound ~= 0) & (previous asNumber == 2) & (current asNumber == 3)) )		ifTrue: [			(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card.			(aceFound ~= 0) & (previous asNumber == 2) & (current asNumber == 3)			ifTrue: [ streaks addFirst: aceFound. Transcript cr ;show: 'here'; cr; show: streaks.] ]		ifFalse: [			Transcript show: previous; show: streaks;cr.			(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]. ]]].Transcript show: 'h'; cr; show: streaks ; cr.highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak ! !----SNAPSHOT----2021-02-12T15:22:22.162131-05:00 game1.image priorSource: 1182989!!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 15:23' prior: 34790605!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 test1 test2 test3 test4 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.			"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].			temp1 := OrderedCollection new.	temp2 := OrderedCollection new.	test1 := 0. 	test2 := 0. 	test3 := 0. 	test4 := 0.    temp1 := straightFlush1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	temp2 := straightFlush2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	test1 := straightFlush1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test2 := straightFlush2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].	test4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].			test3 >= test4 ifTrue: [ straightFlush := temp1.(test1 ~= 0 ) ifTrue: [ straightFlush add: test1 ]. ] 							ifFalse: [  straightFlush := temp2. (test2 ~= 0 ) ifTrue: [ straightFlush add: test2 ]. ].	"straightFlush := self sizeCheck: 5 firstList: temp1 secondList: temp2."	"Transcript cr; cr; show: straightFlush."	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	"	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		temp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.		temp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )		ifTrue: [ 			((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) 			ifTrue: [					(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ 				valueStreak := valueStreak1 , valueStreak1b]]. 			(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ 			   valueStreak := valueStreak2 , valueStreak2b]]. 							]] 		ifFalse: [ 								(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak1 , valueStreak1b].				(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak2 , valueStreak2b].						]	].		"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].			flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		temp1 := OrderedCollection new.	temp2 := OrderedCollection new.	test1 := 0. 	test2 := 0. 	test3 := 0. 	test4 := 0.    temp1 := straight1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	temp2 := straight2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	test1 := straight1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test2 := straight2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].	test4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].			test3 >= test4 ifTrue: [ straight := temp1.(test1 ~= 0 ) ifTrue: [ straight add: test1 ]. ] 							ifFalse: [  straight := temp2. (test2 ~= 0 ) ifTrue: [ straight add: test2 ]. ].			(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted.   ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 15:24' prior: 34813937!getHighestStreak: nice	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| streaks notFound previousCard previous card current highestStreak aceFound |streaks := OrderedCollection new.notFound := true.aceFound := nice detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].2 to: nice size do: [ :i | 	previousCard := nice at: (i-1).	previous := previousCard copyFrom: 1 to: (previousCard size-1).	card := nice at: i.	current := card copyFrom: 1 to: (card size-1).	(previous ~= current) ifTrue: [  	( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) | ((aceFound ~= 0) & (previous asNumber == 2) & (current asNumber == 3)) )		ifTrue: [			(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card.			(aceFound ~= 0) & (previous asNumber == 2) & (current asNumber == 3)			ifTrue: [ streaks addFirst: aceFound. ] ]		ifFalse: [						(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]. ]]].highestStreak := OrderedCollection new.(streaks size >= 5) 	ifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].^highestStreak ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 15:29' prior: 34815559!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 test1 test2 test3 test4 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.			"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].			temp1 := OrderedCollection new.	temp2 := OrderedCollection new.	test1 := 0. 	test2 := 0. 	test3 := 0. 	test4 := 0.    temp1 := straightFlush1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	temp2 := straightFlush2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	test1 := straightFlush1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test2 := straightFlush2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].	test4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].			test3 >= test4 ifTrue: [ straightFlush := temp1.(test1 ~= 0 ) ifTrue: [ straightFlush add: test1 ]. ] 							ifFalse: [  straightFlush := temp2. (test2 ~= 0 ) ifTrue: [ straightFlush add: test2 ]. ].	"straightFlush := self sizeCheck: 5 firstList: temp1 secondList: temp2."	"Transcript cr; cr; show: straightFlush."	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	"	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		temp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.		temp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )		ifTrue: [ 			((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) 			ifTrue: [					(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ 				valueStreak := valueStreak1 , valueStreak1b]]. 			(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ 			   valueStreak := valueStreak2 , valueStreak2b]]. 							]] 		ifFalse: [ 				Transcript show: valueStreak2b.				(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak1 , valueStreak1b].				(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak2 , valueStreak2b].						]	].		"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].			flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		temp1 := OrderedCollection new.	temp2 := OrderedCollection new.	test1 := 0. 	test2 := 0. 	test3 := 0. 	test4 := 0.    temp1 := straight1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	temp2 := straight2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	test1 := straight1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test2 := straight2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].	test4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].			test3 >= test4 ifTrue: [ straight := temp1.(test1 ~= 0 ) ifTrue: [ straight add: test1 ]. ] 							ifFalse: [  straight := temp2. (test2 ~= 0 ) ifTrue: [ straight add: test2 ]. ].			(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted.   ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 15:29' prior: 34824967!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 test1 test2 test3 test4 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.			"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].			temp1 := OrderedCollection new.	temp2 := OrderedCollection new.	test1 := 0. 	test2 := 0. 	test3 := 0. 	test4 := 0.    temp1 := straightFlush1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	temp2 := straightFlush2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	test1 := straightFlush1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test2 := straightFlush2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].	test4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].			test3 >= test4 ifTrue: [ straightFlush := temp1.(test1 ~= 0 ) ifTrue: [ straightFlush add: test1 ]. ] 							ifFalse: [  straightFlush := temp2. (test2 ~= 0 ) ifTrue: [ straightFlush add: test2 ]. ].	"straightFlush := self sizeCheck: 5 firstList: temp1 secondList: temp2."	"Transcript cr; cr; show: straightFlush."	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	"	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		temp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.		temp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )		ifTrue: [ 			((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) 			ifTrue: [					(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ 				valueStreak := valueStreak1 , valueStreak1b]]. 			(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ 			   valueStreak := valueStreak2 , valueStreak2b]]. 							]] 		ifFalse: [ 				Transcript show: valueStreak2.				(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak1 , valueStreak1b].				(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak2 , valueStreak2b].						]	].		"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].			flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		temp1 := OrderedCollection new.	temp2 := OrderedCollection new.	test1 := 0. 	test2 := 0. 	test3 := 0. 	test4 := 0.    temp1 := straight1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	temp2 := straight2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	test1 := straight1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test2 := straight2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].	test4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].			test3 >= test4 ifTrue: [ straight := temp1.(test1 ~= 0 ) ifTrue: [ straight add: test1 ]. ] 							ifFalse: [  straight := temp2. (test2 ~= 0 ) ifTrue: [ straight add: test2 ]. ].			(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted.   ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 15:29' prior: 34833005!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 test1 test2 test3 test4 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.			"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].			temp1 := OrderedCollection new.	temp2 := OrderedCollection new.	test1 := 0. 	test2 := 0. 	test3 := 0. 	test4 := 0.    temp1 := straightFlush1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	temp2 := straightFlush2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	test1 := straightFlush1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test2 := straightFlush2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].	test4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].			test3 >= test4 ifTrue: [ straightFlush := temp1.(test1 ~= 0 ) ifTrue: [ straightFlush add: test1 ]. ] 							ifFalse: [  straightFlush := temp2. (test2 ~= 0 ) ifTrue: [ straightFlush add: test2 ]. ].	"straightFlush := self sizeCheck: 5 firstList: temp1 secondList: temp2."	"Transcript cr; cr; show: straightFlush."	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	"	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		temp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.		temp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )		ifTrue: [ 			((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) 			ifTrue: [					(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ 				valueStreak := valueStreak1 , valueStreak1b]]. 			(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ 			   valueStreak := valueStreak2 , valueStreak2b]]. 							]] 		ifFalse: [ 				Transcript show: valueStreak1.				(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak1 , valueStreak1b].				(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak2 , valueStreak2b].						]	].		"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].			flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		temp1 := OrderedCollection new.	temp2 := OrderedCollection new.	test1 := 0. 	test2 := 0. 	test3 := 0. 	test4 := 0.    temp1 := straight1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	temp2 := straight2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	test1 := straight1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test2 := straight2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].	test4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].			test3 >= test4 ifTrue: [ straight := temp1.(test1 ~= 0 ) ifTrue: [ straight add: test1 ]. ] 							ifFalse: [  straight := temp2. (test2 ~= 0 ) ifTrue: [ straight add: test2 ]. ].			(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted.   ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 15:30' prior: 34841042!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 test1 test2 test3 test4 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.			"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].			temp1 := OrderedCollection new.	temp2 := OrderedCollection new.	test1 := 0. 	test2 := 0. 	test3 := 0. 	test4 := 0.    temp1 := straightFlush1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	temp2 := straightFlush2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	test1 := straightFlush1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test2 := straightFlush2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].	test4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].			test3 >= test4 ifTrue: [ straightFlush := temp1.(test1 ~= 0 ) ifTrue: [ straightFlush add: test1 ]. ] 							ifFalse: [  straightFlush := temp2. (test2 ~= 0 ) ifTrue: [ straightFlush add: test2 ]. ].	"straightFlush := self sizeCheck: 5 firstList: temp1 secondList: temp2."	"Transcript cr; cr; show: straightFlush."	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	"	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		temp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.		temp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )		ifTrue: [ 			((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) 			ifTrue: [					(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ 				valueStreak := valueStreak1 , valueStreak1b]]. 			(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ 			   valueStreak := valueStreak2 , valueStreak2b]]. 							]] 		ifFalse: [ 				Transcript show: valueStreak1;cr.				Transcript show: valueStreak2;cr.				(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak1 , valueStreak1b].				(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak2 , valueStreak2b].						]	].		"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].			flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		temp1 := OrderedCollection new.	temp2 := OrderedCollection new.	test1 := 0. 	test2 := 0. 	test3 := 0. 	test4 := 0.    temp1 := straight1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	temp2 := straight2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	test1 := straight1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test2 := straight2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].	test4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].			test3 >= test4 ifTrue: [ straight := temp1.(test1 ~= 0 ) ifTrue: [ straight add: test1 ]. ] 							ifFalse: [  straight := temp2. (test2 ~= 0 ) ifTrue: [ straight add: test2 ]. ].			(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted.   ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 15:30' prior: 34849079!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 test1 test2 test3 test4 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.			"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].			temp1 := OrderedCollection new.	temp2 := OrderedCollection new.	test1 := 0. 	test2 := 0. 	test3 := 0. 	test4 := 0.    temp1 := straightFlush1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	temp2 := straightFlush2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	test1 := straightFlush1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test2 := straightFlush2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].	test4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].			test3 >= test4 ifTrue: [ straightFlush := temp1.(test1 ~= 0 ) ifTrue: [ straightFlush add: test1 ]. ] 							ifFalse: [  straightFlush := temp2. (test2 ~= 0 ) ifTrue: [ straightFlush add: test2 ]. ].	"straightFlush := self sizeCheck: 5 firstList: temp1 secondList: temp2."	"Transcript cr; cr; show: straightFlush."	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	"	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		temp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.		temp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )		ifTrue: [ 			((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) 			ifTrue: [		Transcript show: valueStreak1;cr.				Transcript show: valueStreak2;cr.			(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ 				valueStreak := valueStreak1 , valueStreak1b]]. 			(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ 			   valueStreak := valueStreak2 , valueStreak2b]]. 							]] 		ifFalse: [ 				(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak1 , valueStreak1b].				(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak2 , valueStreak2b].						]	].		"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].			flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		temp1 := OrderedCollection new.	temp2 := OrderedCollection new.	test1 := 0. 	test2 := 0. 	test3 := 0. 	test4 := 0.    temp1 := straight1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	temp2 := straight2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	test1 := straight1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test2 := straight2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].	test4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].			test3 >= test4 ifTrue: [ straight := temp1.(test1 ~= 0 ) ifTrue: [ straight add: test1 ]. ] 							ifFalse: [  straight := temp2. (test2 ~= 0 ) ifTrue: [ straight add: test2 ]. ].			(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted.   ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 15:31' prior: 34857157!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 test1 test2 test3 test4 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.			"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].			temp1 := OrderedCollection new.	temp2 := OrderedCollection new.	test1 := 0. 	test2 := 0. 	test3 := 0. 	test4 := 0.    temp1 := straightFlush1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	temp2 := straightFlush2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	test1 := straightFlush1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test2 := straightFlush2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].	test4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].			test3 >= test4 ifTrue: [ straightFlush := temp1.(test1 ~= 0 ) ifTrue: [ straightFlush add: test1 ]. ] 							ifFalse: [  straightFlush := temp2. (test2 ~= 0 ) ifTrue: [ straightFlush add: test2 ]. ].	"straightFlush := self sizeCheck: 5 firstList: temp1 secondList: temp2."	"Transcript cr; cr; show: straightFlush."	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	"	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		temp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.		temp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )		ifTrue: [ 			((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) 			ifTrue: [		Transcript show: valueStreak2b;cr.				Transcript show: valueStreak2;cr.			(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ 				valueStreak := valueStreak1 , valueStreak1b]]. 			(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ 			   valueStreak := valueStreak2 , valueStreak2b]]. 							]] 		ifFalse: [ 				(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak1 , valueStreak1b].				(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak2 , valueStreak2b].						]	].		"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].			flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		temp1 := OrderedCollection new.	temp2 := OrderedCollection new.	test1 := 0. 	test2 := 0. 	test3 := 0. 	test4 := 0.    temp1 := straight1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	temp2 := straight2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	test1 := straight1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test2 := straight2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].	test4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].			test3 >= test4 ifTrue: [ straight := temp1.(test1 ~= 0 ) ifTrue: [ straight add: test1 ]. ] 							ifFalse: [  straight := temp2. (test2 ~= 0 ) ifTrue: [ straight add: test2 ]. ].			(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted.   ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 15:31' prior: 34865230!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 test1 test2 test3 test4 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.			"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].			temp1 := OrderedCollection new.	temp2 := OrderedCollection new.	test1 := 0. 	test2 := 0. 	test3 := 0. 	test4 := 0.    temp1 := straightFlush1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	temp2 := straightFlush2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	test1 := straightFlush1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test2 := straightFlush2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].	test4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].			test3 >= test4 ifTrue: [ straightFlush := temp1.(test1 ~= 0 ) ifTrue: [ straightFlush add: test1 ]. ] 							ifFalse: [  straightFlush := temp2. (test2 ~= 0 ) ifTrue: [ straightFlush add: test2 ]. ].	"straightFlush := self sizeCheck: 5 firstList: temp1 secondList: temp2."	"Transcript cr; cr; show: straightFlush."	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	"	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		temp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.		temp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )		ifTrue: [ 			((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) 			ifTrue: [		Transcript show: temp2;cr.				Transcript show: valueStreak2;cr.			(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ 				valueStreak := valueStreak1 , valueStreak1b]]. 			(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ 			   valueStreak := valueStreak2 , valueStreak2b]]. 							]] 		ifFalse: [ 				(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak1 , valueStreak1b].				(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak2 , valueStreak2b].						]	].		"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].			flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		temp1 := OrderedCollection new.	temp2 := OrderedCollection new.	test1 := 0. 	test2 := 0. 	test3 := 0. 	test4 := 0.    temp1 := straight1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	temp2 := straight2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	test1 := straight1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test2 := straight2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].	test4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].			test3 >= test4 ifTrue: [ straight := temp1.(test1 ~= 0 ) ifTrue: [ straight add: test1 ]. ] 							ifFalse: [  straight := temp2. (test2 ~= 0 ) ifTrue: [ straight add: test2 ]. ].			(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted.   ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 15:32' prior: 34873304!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 test1 test2 test3 test4 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.			"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].			temp1 := OrderedCollection new.	temp2 := OrderedCollection new.	test1 := 0. 	test2 := 0. 	test3 := 0. 	test4 := 0.    temp1 := straightFlush1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	temp2 := straightFlush2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	test1 := straightFlush1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test2 := straightFlush2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].	test4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].			test3 >= test4 ifTrue: [ straightFlush := temp1.(test1 ~= 0 ) ifTrue: [ straightFlush add: test1 ]. ] 							ifFalse: [  straightFlush := temp2. (test2 ~= 0 ) ifTrue: [ straightFlush add: test2 ]. ].	"straightFlush := self sizeCheck: 5 firstList: temp1 secondList: temp2."	"Transcript cr; cr; show: straightFlush."	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	"	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		temp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.		temp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )		ifTrue: [ 			((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) 			ifTrue: [		Transcript show: temp2;cr.				Transcript show: valueStreak2;cr.			(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ 				valueStreak := valueStreak1 , valueStreak1b]]. 			(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1)) | (valueStreak1 size ~= 3) ifTrue: [ 			   valueStreak := valueStreak2 , valueStreak2b]]. 							]] 		ifFalse: [ 				(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak1 , valueStreak1b].				(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak2 , valueStreak2b].						]	].		"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].			flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		temp1 := OrderedCollection new.	temp2 := OrderedCollection new.	test1 := 0. 	test2 := 0. 	test3 := 0. 	test4 := 0.    temp1 := straight1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	temp2 := straight2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	test1 := straight1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test2 := straight2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].	test4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].			test3 >= test4 ifTrue: [ straight := temp1.(test1 ~= 0 ) ifTrue: [ straight add: test1 ]. ] 							ifFalse: [  straight := temp2. (test2 ~= 0 ) ifTrue: [ straight add: test2 ]. ].			(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted.   ! !!Poker methodsFor: 'accessing' stamp: 'MagdalenaDhima 2/12/2021 15:32' prior: 34881370!deal: shuf	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"		| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 test1 test2 test3 test4 |	hand := self convert: shuf.		self divideHands: hand.			sorted1 := self sort: hand1.	sorted2 := self sort: hand2.			"	data := self getData.	Transcript show: 'data'; cr.	Transcript show: data; cr.	"	straight1 := self getHighestStreak: sorted1.	straight2 := self getHighestStreak: sorted2.		valueStreak1 := self getHighestValueStreak: sorted1.	valueStreak2 := self getHighestValueStreak: sorted2.		flushOrSuitStreak1 := self getHighestSuitStreak: sorted1.	flushOrSuitStreak2 := self getHighestSuitStreak: sorted2.		straightFlush1 := OrderedCollection new.	(flushOrSuitStreak1 size > 4) ifTrue: [  		straightFlush1 := self getHighestStreak: flushOrSuitStreak1.].			straightFlush2 := OrderedCollection new.	(flushOrSuitStreak2 size > 4) ifTrue: [  		straightFlush2 := self getHighestStreak: flushOrSuitStreak2.].			temp1 := OrderedCollection new.	temp2 := OrderedCollection new.	test1 := 0. 	test2 := 0. 	test3 := 0. 	test4 := 0.    temp1 := straightFlush1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	temp2 := straightFlush2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	test1 := straightFlush1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test2 := straightFlush2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].	test4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].			test3 >= test4 ifTrue: [ straightFlush := temp1.(test1 ~= 0 ) ifTrue: [ straightFlush add: test1 ]. ] 							ifFalse: [  straightFlush := temp2. (test2 ~= 0 ) ifTrue: [ straightFlush add: test2 ]. ].	"straightFlush := self sizeCheck: 5 firstList: temp1 secondList: temp2."	"Transcript cr; cr; show: straightFlush."	(straightFlush size == 5) ifTrue: [^straightFlush].		valueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 4) ifTrue: [^valueStreak].		"----------------------"		remaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].	remaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].		temp1:= OrderedCollection new.	temp2:= OrderedCollection new.	temp1 := self getHighestValueStreak: remaining1.	temp2 := self getHighestValueStreak: remaining2.		valueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.	(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].	(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].		"----------------------"		valueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. 	"	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  		valueStreakA := valueStreak1 , valueStreak1b.	].	(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		valueStreakB := valueStreak2 , valueStreak2b.	]."	(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ 		temp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.		temp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.		(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )		ifTrue: [ 			((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) 			ifTrue: [			(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ 				valueStreak := valueStreak1 , valueStreak1b]]. 			(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1)) | (valueStreak1 size ~= 3) ifTrue: [ 			   valueStreak := valueStreak2 , valueStreak2b]]. 							]] 		ifFalse: [ 				(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak1 , valueStreak1b].				(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  					valueStreak := valueStreak2 , valueStreak2b].						]	].		"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."	(valueStreak size == 5 ) ifTrue: [^valueStreak].		flush := OrderedCollection new.	(flushOrSuitStreak1 size >= 5) ifTrue: [  	(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. 	flushOrSuitStreak1 := flush. ].	flush := OrderedCollection new.	(flushOrSuitStreak2 size >= 5) ifTrue: [  	(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. 	flushOrSuitStreak2 := flush ].			flushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.	(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].		temp1 := OrderedCollection new.	temp2 := OrderedCollection new.	test1 := 0. 	test2 := 0. 	test3 := 0. 	test4 := 0.    temp1 := straight1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	temp2 := straight2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].	test1 := straight1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test2 := straight2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	test3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].	test4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].			test3 >= test4 ifTrue: [ straight := temp1.(test1 ~= 0 ) ifTrue: [ straight add: test1 ]. ] 							ifFalse: [  straight := temp2. (test2 ~= 0 ) ifTrue: [ straight add: test2 ]. ].			(straight size == 5 ) ifTrue: [^straight].		valueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 3) ifTrue: [^valueStreak].		temp1, temp2 = 0.	temp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].	temp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].	( temp1 ~= temp2 )	ifTrue: [  	valueStreakA := valueStreak1 , valueStreak1b.	valueStreakB := valueStreak2 , valueStreak2b. 	valueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]	ifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].		(valueStreak size == 4) ifTrue: [^(valueStreak)].		valueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.	(valueStreak size == 2) ifTrue: [^valueStreak].			sorted := OrderedCollection new. 	ace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].	ace1 == 0 & ( ace2 == 0 ) ifTrue: 	[ 	  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].	  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .	  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].	  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] 	ifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].	^sorted.   ! !----SNAPSHOT----2021-02-12T15:33:42.242131-05:00 game1.image priorSource: 1260954!