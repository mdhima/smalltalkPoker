OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T20:33:37.097546-05:00' ],		#prior : OmReference [ 'Pharo8.0-SNAPSHOT-32bit-0932da8.ajwvp48p7brujn33ieeg0urkq', '126' ],		#self : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: newList. dataInHand at: \'D\' put: newList. dataInHand at: \'H\' put: newList. dataInHand at: \'S\' put: newList.\r2 to: streaks size do: [ :i | \r\tpreviousCard := streaks at: (i-1).\r\tprevious := previousCard at: previousCard size.\r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\t(previous == current)\r\t\tifTrue: [(suitStreak isEmpty) ifTrue:[suitStreak add: previousCard]. suitStreak add: card]\r\t\tifFalse: [(suitStreak size ~= 0) ifTrue: [dataInHand at: previous put: suitStreak. suitStreak := \t\t\tOrderedCollection new] ] ].\r\t(suitStreak size ~= 0) ifTrue: [dataInHand at: previous put: suitStreak].\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 16:25',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current put: ( (dataInHand at: current) , card , \' \' )]. \r\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tword := \'\'.\r\t\taValue do: [:a | (a ~= \' \') ifTrue: [word,a] ifFalse: [ temp add: word. word := \'\' ] ].\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:33',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T20:33:55.564546-05:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current put: ( (dataInHand at: current) , card , \' \' )]. \r\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tword := \'\'.\r\t\taValue do: [:a | (a ~= \' \') ifTrue: [word,a] ifFalse: [ temp add: word. word := \'\' ] ].\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:33',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current put: ( (dataInHand at: current) , card , \' \' )]. \r\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tword := \'\'.\r\t\taValue do: [:a | (a ~= \' \') ifTrue: [word,a] ifFalse: [ temp add: word. word := \'\' ] ].\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: dataInHand; cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:33',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T20:34:28.627546-05:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current put: ( (dataInHand at: current) , card , \' \' )]. \r\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tword := \'\'.\r\t\taValue do: [:a | (a ~= \' \') ifTrue: [word,a] ifFalse: [ temp add: word. word := \'\' ] ].\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: dataInHand; cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:33',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current put: ( (dataInHand at: current) , card , \' \' )]. \r\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tword := \'\'.\r\t\taValue do: [:a | (a ~= \' \') ifTrue: [word,a] ifFalse: [ temp add: word. word := \'\' ] ].\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: dataInHand; cr.\r\tTranscript show: suitStreak; cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:34',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T20:35:12.160546-05:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current put: ( (dataInHand at: current) , card , \' \' )]. \r\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tword := \'\'.\r\t\taValue do: [:a | (a ~= \' \') ifTrue: [word,a] ifFalse: [ temp add: word. word := \'\' ] ].\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: dataInHand; cr.\r\tTranscript show: suitStreak; cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:34',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current put: ( (dataInHand at: current) , card , \' \' )]. \r\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\t\r\tTranscript show: dataInHand; cr.\r\t\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tword := \'\'.\r\t\taValue do: [:a | (a ~= \' \') ifTrue: [word,a] ifFalse: [ temp add: word. word := \'\' ] ].\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: dataInHand; cr.\r\tTranscript show: suitStreak; cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:35',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T20:35:56.856546-05:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current put: ( (dataInHand at: current) , card , \' \' )]. \r\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\t\r\tTranscript show: dataInHand; cr.\r\t\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tword := \'\'.\r\t\taValue do: [:a | (a ~= \' \') ifTrue: [word,a] ifFalse: [ temp add: word. word := \'\' ] ].\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: dataInHand; cr.\r\tTranscript show: suitStreak; cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:35',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , \' \' )]. \r\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\t\r\tTranscript show: dataInHand; cr.\r\t\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tword := \'\'.\r\t\taValue do: [:a | (a ~= \' \') ifTrue: [word,a] ifFalse: [ temp add: word. word := \'\' ] ].\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: dataInHand; cr.\r\tTranscript show: suitStreak; cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:35',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T20:37:40.785546-05:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , \' \' )]. \r\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\t\r\tTranscript show: dataInHand; cr.\r\t\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tword := \'\'.\r\t\taValue do: [:a | (a ~= \' \') ifTrue: [word,a] ifFalse: [ temp add: word. word := \'\' ] ].\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: dataInHand; cr.\r\tTranscript show: suitStreak; cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:35',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , \' \' )]. \r\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tTranscript show: dataInHand; cr.\r\t\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tword := \'\'.\r\t\taValue do: [:a | (a ~= \' \') ifTrue: [word,a. Transcript show: temp; cr.] ifFalse: [ temp add: word. word := \'\' ] ].\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: dataInHand; cr.\r\tTranscript show: suitStreak; cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:37',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T20:38:24.488546-05:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , \' \' )]. \r\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tTranscript show: dataInHand; cr.\r\t\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tword := \'\'.\r\t\taValue do: [:a | (a ~= \' \') ifTrue: [word,a. Transcript show: temp; cr.] ifFalse: [ temp add: word. word := \'\' ] ].\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: dataInHand; cr.\r\tTranscript show: suitStreak; cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:37',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , \' \' )]. \r\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tTranscript show: dataInHand; cr.\r\t\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tword := \'\'.\r\t\taValue do: [:a | (a ~= \' \') ifTrue: [Transcript show: (word,a); cr. word,a] ifFalse: [ temp add: word. word := \'\' ] ].\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: dataInHand; cr.\r\tTranscript show: suitStreak; cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:38',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T20:39:37.275546-05:00' ],		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , \' \' )]. \r\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tTranscript show: dataInHand; cr.\r\t\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tword := \'\'.\r\t\taValue do: [:a | (a ~= \' \') ifTrue: [Transcript show: (word,a); cr. word,a] ifFalse: [ temp add: word. word := \'\' ] ].\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: dataInHand; cr.\r\tTranscript show: suitStreak; cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:38',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , \' \' )]. \r\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tTranscript show: dataInHand; cr.\r\t\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tword := \'\'.\r\t\taValue do: [:a | (a ~= \' \') ifTrue: [Transcript show: (word,a asString); cr. word,a] ifFalse: [ temp add: word. word := \'\' ] ].\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: dataInHand; cr.\r\tTranscript show: suitStreak; cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:39',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T20:40:18.928546-05:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , \' \' )]. \r\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tTranscript show: dataInHand; cr.\r\t\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tword := \'\'.\r\t\taValue do: [:a | (a ~= \' \') ifTrue: [Transcript show: (word,a asString); cr. word,a] ifFalse: [ temp add: word. word := \'\' ] ].\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: dataInHand; cr.\r\tTranscript show: suitStreak; cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:39',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , \' \' )]. \r\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tTranscript show: dataInHand; cr.\r\t\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tword := \'\'.\r\t\taValue do: [:a | (a ~= \' \') ifTrue: [word := word , a asString] ifFalse: [ temp add: word. word := \'\' ] ].\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: dataInHand; cr.\r\tTranscript show: suitStreak; cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:40',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T20:40:52.162546-05:00' ],		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , \' \' )]. \r\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tTranscript show: dataInHand; cr.\r\t\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tword := \'\'.\r\t\taValue do: [:a | (a ~= \' \') ifTrue: [word := word , a asString] ifFalse: [ temp add: word. word := \'\' ] ].\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: dataInHand; cr.\r\tTranscript show: suitStreak; cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:40',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , \' \' )]. \r\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tTranscript show: dataInHand; cr.\r\t\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tword := \'\'.\r\t\taValue do: [:a | (a ~= \' \') ifTrue: [word := word , a asString] ifFalse: [ temp add: word. word := \'\' ] ].\r\t\tTranscript show: temp; cr.\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: dataInHand; cr.\r\tTranscript show: suitStreak; cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:40',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T20:41:25.571546-05:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , \' \' )]. \r\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tTranscript show: dataInHand; cr.\r\t\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tword := \'\'.\r\t\taValue do: [:a | (a ~= \' \') ifTrue: [word := word , a asString] ifFalse: [ temp add: word. word := \'\' ] ].\r\t\tTranscript show: temp; cr.\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: dataInHand; cr.\r\tTranscript show: suitStreak; cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:40',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , \' \' )]. \r\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tTranscript show: dataInHand; cr.\r\t\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tword := \'\'.\r\t\taValue do: [:a | (a ~= \' \') ifTrue: [Transcript show: word; cr. word := word , a asString] ifFalse: [ temp add: word. word := \'\' ] ].\r\t\tTranscript show: temp; cr.\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: dataInHand; cr.\r\tTranscript show: suitStreak; cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:41',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T20:41:50.417546-05:00' ],		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , \' \' )]. \r\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tTranscript show: dataInHand; cr.\r\t\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tword := \'\'.\r\t\taValue do: [:a | (a ~= \' \') ifTrue: [Transcript show: word; cr. word := word , a asString] ifFalse: [ temp add: word. word := \'\' ] ].\r\t\tTranscript show: temp; cr.\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: dataInHand; cr.\r\tTranscript show: suitStreak; cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:41',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , \' \' )]. \r\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tTranscript show: dataInHand; cr.\r\t\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tword := \'\'.\r\t\taValue do: [:a | (a ~= \' \') ifTrue: [Transcript show: a; cr. word := word , a asString] ifFalse: [ temp add: word. word := \'\' ] ].\r\t\tTranscript show: temp; cr.\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: dataInHand; cr.\r\tTranscript show: suitStreak; cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:41',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T20:42:51.706546-05:00' ],		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , \' \' )]. \r\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tTranscript show: dataInHand; cr.\r\t\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tword := \'\'.\r\t\taValue do: [:a | (a ~= \' \') ifTrue: [Transcript show: a; cr. word := word , a asString] ifFalse: [ temp add: word. word := \'\' ] ].\r\t\tTranscript show: temp; cr.\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: dataInHand; cr.\r\tTranscript show: suitStreak; cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:41',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , \' \' )]. \r\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tTranscript show: dataInHand; cr.\r\t\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tword := \'\'.\r\t\taValue do: [:a | (a ~= \' \' asCharacter) ifTrue: [Transcript show: a; cr. word := word , a asString] ifFalse: [ temp add: word. word := \'\' ] ].\r\t\tTranscript show: temp; cr.\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: dataInHand; cr.\r\tTranscript show: suitStreak; cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:42',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T20:44:16.037546-05:00' ],		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , \' \' )]. \r\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tTranscript show: dataInHand; cr.\r\t\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tword := \'\'.\r\t\taValue do: [:a | (a ~= \' \' asCharacter) ifTrue: [Transcript show: a; cr. word := word , a asString] ifFalse: [ temp add: word. word := \'\' ] ].\r\t\tTranscript show: temp; cr.\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: dataInHand; cr.\r\tTranscript show: suitStreak; cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:42',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , \' \' )]. \r\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tTranscript show: dataInHand; cr.\r\t\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tword := \'\'.\r\t\taValue do: [:a | (a asString ~= \' \') ifTrue: [Transcript show: a; cr. word := word , a asString] ifFalse: [ temp add: word. word := \'\' ] ].\r\t\tTranscript show: temp; cr.\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: dataInHand; cr.\r\tTranscript show: suitStreak; cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:44',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T20:45:12.787546-05:00' ],		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , \' \' )]. \r\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tTranscript show: dataInHand; cr.\r\t\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tword := \'\'.\r\t\taValue do: [:a | (a asString ~= \' \') ifTrue: [Transcript show: a; cr. word := word , a asString] ifFalse: [ temp add: word. word := \'\' ] ].\r\t\tTranscript show: temp; cr.\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: dataInHand; cr.\r\tTranscript show: suitStreak; cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:44',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , \' \' )]. \r\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tTranscript show: dataInHand; cr.\r\t\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tword := \'\'.\r\t\ttemp := OrderedCollection new.\r\t\taValue do: [:a | (a asString ~= \' \') ifTrue: [Transcript show: a; cr. word := word , a asString] ifFalse: [ temp add: word. word := \'\' ] ].\r\t\tTranscript show: temp; cr.\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: dataInHand; cr.\r\tTranscript show: suitStreak; cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:45',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T20:45:52.383546-05:00' ],		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , \' \' )]. \r\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tTranscript show: dataInHand; cr.\r\t\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tword := \'\'.\r\t\ttemp := OrderedCollection new.\r\t\taValue do: [:a | (a asString ~= \' \') ifTrue: [Transcript show: a; cr. word := word , a asString] ifFalse: [ temp add: word. word := \'\' ] ].\r\t\tTranscript show: temp; cr.\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: dataInHand; cr.\r\tTranscript show: suitStreak; cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:45',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , \' \' )]. \r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tTranscript show: dataInHand; cr.\r\t\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tword := \'\'.\r\t\ttemp := OrderedCollection new.\r\t\taValue do: [:a | (a asString ~= \' \') ifTrue: [Transcript show: a; cr. word := word , a asString] ifFalse: [ temp add: word. word := \'\' ] ].\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:45',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T20:46:30.204546-05:00' ],		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , \' \' )]. \r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tTranscript show: dataInHand; cr.\r\t\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tword := \'\'.\r\t\ttemp := OrderedCollection new.\r\t\taValue do: [:a | (a asString ~= \' \') ifTrue: [Transcript show: a; cr. word := word , a asString] ifFalse: [ temp add: word. word := \'\' ] ].\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:45',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , \' \' )]. \r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tTranscript show: dataInHand; cr.\r\t\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tword := \'\'.\r\t\ttemp := OrderedCollection new.\r\t\taValue do: [:a | (a asString ~= \' \') ifTrue: [word := word , a asString] ifFalse: [ temp add: word. word := \'\' ] ].\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:46',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T20:47:00.217546-05:00' ],		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ]	},	#content : EpSessionSnapshot {		#imageName : 'C:\\Users\\Administrator\\Documents\\Pharo\\images\\Pharo 8.0 - 64bit (stable)\\Pharo 8.0 - 64bit (stable).image'	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T20:47:29.155546-05:00' ],		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ]	},	#content : EpSessionSnapshot {		#imageName : 'C:\\Users\\Administrator\\Documents\\Pharo\\images\\Pharo 8.0 - 64bit (stable)\\Pharo 8.0 - 64bit (stable).image'	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T20:51:20.710546-05:00' ],		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\r\t(previous asNumber == (current asNumber -1) & notFound)\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r]].\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:50',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\r\t(previous asNumber == (current asNumber -1) & notFound)\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r]].\r\rTranscript show: streaks; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:51',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T20:54:06.985546-05:00' ],		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\r\t(previous asNumber == (current asNumber -1) & notFound)\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r]].\r\rTranscript show: streaks; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:51',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\r\t(previous ~= current) ifTrue: [  \r\t(previous asNumber == (current asNumber -1) & notFound)\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r] ]].\r\rTranscript show: streaks; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:54',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T20:55:52.548546-05:00' ],		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flushOrSuitStreak straightFlush valueStreak maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tvalueStreak := self getHighestValueStreak: sorted.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak; cr.\r\t\r\tflushOrSuitStreak := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak; cr.\r\t\r\tstraightFlush := OrderedCollection new.\r\t(flushOrSuitStreak size > 4) ifTrue: [  \r\t\tstraightFlush := self getHighestStreak: flushOrSuitStreak.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush; cr.].\r\t\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t^sorted\r\t\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 17:54',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flushOrSuitStreak straightFlush valueStreak maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tvalueStreak := self getHighestValueStreak: sorted.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak; cr.\r\t\r\tTranscript show: \'-----\'; cr.\r\tflushOrSuitStreak := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak; cr.\r\t\r\tstraightFlush := OrderedCollection new.\r\t(flushOrSuitStreak size > 4) ifTrue: [  \r\t\tstraightFlush := self getHighestStreak: flushOrSuitStreak.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush; cr.].\r\t\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t^sorted\r\t\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 20:55',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T20:59:03.957546-05:00' ],		#prior : OmReference [ '22' ],		#self : OmReference [ '23' ]	},	#content : EpSessionSnapshot {		#imageName : 'C:\\Users\\Administrator\\Documents\\Pharo\\images\\Pharo 8.0 - 64bit (stable)\\Pharo 8.0 - 64bit (stable).image'	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T21:01:01.820546-05:00' ],		#prior : OmReference [ '23' ],		#self : OmReference [ '24' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\r\t(previous ~= current) ifTrue: [  \r\t(previous asNumber == (current asNumber -1) & notFound)\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r] ]].\r\rTranscript show: streaks; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:54',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\r\t(previous ~= current) ifTrue: [  \r\t(previous asNumber == (current asNumber -1) & notFound)\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r] ]].\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak',			#stamp : 'MagdalenaDhima 1/30/2021 21:01',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T21:08:45.556546-05:00' ],		#prior : OmReference [ '24' ],		#self : OmReference [ '25' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flushOrSuitStreak straightFlush valueStreak maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tvalueStreak := self getHighestValueStreak: sorted.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak; cr.\r\t\r\tTranscript show: \'-----\'; cr.\r\tflushOrSuitStreak := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak; cr.\r\t\r\tstraightFlush := OrderedCollection new.\r\t(flushOrSuitStreak size > 4) ifTrue: [  \r\t\tstraightFlush := self getHighestStreak: flushOrSuitStreak.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush; cr.].\r\t\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t^sorted\r\t\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 20:55',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data remaining straight flushOrSuitStreak straightFlush valueStreak maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tvalueStreak := self getHighestValueStreak: sorted.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak; cr.\r\t\r\tTranscript show: \'-----\'; cr.\r\tflushOrSuitStreak := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak; cr.\r\t\r\tstraightFlush := OrderedCollection new.\r\t(flushOrSuitStreak size > 4) ifTrue: [  \r\t\tstraightFlush := self getHighestStreak: flushOrSuitStreak.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush; cr.].\r\t\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t\r\tremaining := sorted reject: [:a | valueStreak includes: a ].\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining; cr.\r\t\r\t^sorted\r\t\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 21:08',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T21:16:06.734546-05:00' ],		#prior : OmReference [ '25' ],		#self : OmReference [ '26' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data remaining straight flushOrSuitStreak straightFlush valueStreak maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tvalueStreak := self getHighestValueStreak: sorted.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak; cr.\r\t\r\tTranscript show: \'-----\'; cr.\r\tflushOrSuitStreak := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak; cr.\r\t\r\tstraightFlush := OrderedCollection new.\r\t(flushOrSuitStreak size > 4) ifTrue: [  \r\t\tstraightFlush := self getHighestStreak: flushOrSuitStreak.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush; cr.].\r\t\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t\r\tremaining := sorted reject: [:a | valueStreak includes: a ].\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining; cr.\r\t\r\t^sorted\r\t\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 21:08',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data remaining temp straight flushOrSuitStreak straightFlush valueStreak valueStreak2 maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tvalueStreak := self getHighestValueStreak: sorted.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak; cr.\r\t\r\tTranscript show: \'-----\'; cr.\r\tflushOrSuitStreak := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak; cr.\r\t\r\tstraightFlush := OrderedCollection new.\r\t(flushOrSuitStreak size > 4) ifTrue: [  \r\t\tstraightFlush := self getHighestStreak: flushOrSuitStreak.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush; cr.].\r\t\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t\r\tremaining := sorted reject: [:a | valueStreak includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining; cr.\r\ttemp := self getHighestValueStreak: remaining.\r\tvalueStreak2 := OrderedCollection new.\r\t(temp size >= 2) ifTrue: [ (temp size -1) to: (temp size) do: [ :i | valueStreak2 add: (temp at: i ) ] ].\r\t\r\t(valueStreak size == 3 & (valueStreak2 size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreak2 )].\r\t\r\t^sorted\r\t\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 21:16',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T21:18:29.500546-05:00' ],		#prior : OmReference [ '26' ],		#self : OmReference [ '27' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data remaining temp straight flushOrSuitStreak straightFlush valueStreak valueStreak2 maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tvalueStreak := self getHighestValueStreak: sorted.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak; cr.\r\t\r\tTranscript show: \'-----\'; cr.\r\tflushOrSuitStreak := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak; cr.\r\t\r\tstraightFlush := OrderedCollection new.\r\t(flushOrSuitStreak size > 4) ifTrue: [  \r\t\tstraightFlush := self getHighestStreak: flushOrSuitStreak.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush; cr.].\r\t\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t\r\tremaining := sorted reject: [:a | valueStreak includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining; cr.\r\ttemp := self getHighestValueStreak: remaining.\r\tvalueStreak2 := OrderedCollection new.\r\t(temp size >= 2) ifTrue: [ (temp size -1) to: (temp size) do: [ :i | valueStreak2 add: (temp at: i ) ] ].\r\t\r\t(valueStreak size == 3 & (valueStreak2 size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreak2 )].\r\t\r\t^sorted\r\t\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 21:16',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data remaining temp straight flushOrSuitStreak straightFlush valueStreak valueStreak2 maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tvalueStreak := self getHighestValueStreak: sorted.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak; cr.\r\t\r\tTranscript show: \'-----\'; cr.\r\tflushOrSuitStreak := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak; cr.\r\t\r\tstraightFlush := OrderedCollection new.\r\t(flushOrSuitStreak size > 4) ifTrue: [  \r\t\tstraightFlush := self getHighestStreak: flushOrSuitStreak.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush; cr.].\r\t\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t\r\tremaining := sorted reject: [:a | valueStreak includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining; cr.\r\ttemp := self getHighestValueStreak: remaining.\r\tvalueStreak2 := OrderedCollection new.\r\t(temp size >= 2) ifTrue: [ (temp size -1) to: (temp size) do: [ :i | valueStreak2 add: (temp at: i ) ] ].\r\t\r\t(valueStreak size == 3 & (valueStreak2 size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreak2 )].\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\t^sorted\r\t\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 21:18',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T21:27:21.481546-05:00' ],		#prior : OmReference [ '27' ],		#self : OmReference [ '28' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data remaining temp straight flushOrSuitStreak straightFlush valueStreak valueStreak2 maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tvalueStreak := self getHighestValueStreak: sorted.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak; cr.\r\t\r\tTranscript show: \'-----\'; cr.\r\tflushOrSuitStreak := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak; cr.\r\t\r\tstraightFlush := OrderedCollection new.\r\t(flushOrSuitStreak size > 4) ifTrue: [  \r\t\tstraightFlush := self getHighestStreak: flushOrSuitStreak.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush; cr.].\r\t\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t\r\tremaining := sorted reject: [:a | valueStreak includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining; cr.\r\ttemp := self getHighestValueStreak: remaining.\r\tvalueStreak2 := OrderedCollection new.\r\t(temp size >= 2) ifTrue: [ (temp size -1) to: (temp size) do: [ :i | valueStreak2 add: (temp at: i ) ] ].\r\t\r\t(valueStreak size == 3 & (valueStreak2 size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreak2 )].\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\t^sorted\r\t\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 21:18',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data remaining temp straight flushOrSuitStreak straightFlush valueStreak valueStreak2 maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tvalueStreak := self getHighestValueStreak: sorted.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak; cr.\r\t\r\tTranscript show: \'-----\'; cr.\r\tflushOrSuitStreak := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak; cr.\r\t\r\tstraightFlush := OrderedCollection new.\r\t(flushOrSuitStreak size > 4) ifTrue: [  \r\t\tstraightFlush := self getHighestStreak: flushOrSuitStreak.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush; cr.].\r\t\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t\r\tremaining := sorted reject: [:a | valueStreak includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining; cr.\r\ttemp := self getHighestValueStreak: remaining.\r\tvalueStreak2 := OrderedCollection new.\r\t(temp size >= 2) ifTrue: [ (temp size -1) to: (temp size) do: [ :i | valueStreak2 add: (temp at: i ) ] ].\r\t\r\t(valueStreak size == 3 & (valueStreak2 size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreak2 )].\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\t(straight size == 5) ifTrue: [Transcript show: 6; cr. ^straight].\r\t\r\t^sorted\r\t\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 21:27',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T21:28:57.151546-05:00' ],		#prior : OmReference [ '28' ],		#self : OmReference [ '29' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data remaining temp straight flushOrSuitStreak straightFlush valueStreak valueStreak2 maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tvalueStreak := self getHighestValueStreak: sorted.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak; cr.\r\t\r\tTranscript show: \'-----\'; cr.\r\tflushOrSuitStreak := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak; cr.\r\t\r\tstraightFlush := OrderedCollection new.\r\t(flushOrSuitStreak size > 4) ifTrue: [  \r\t\tstraightFlush := self getHighestStreak: flushOrSuitStreak.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush; cr.].\r\t\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t\r\tremaining := sorted reject: [:a | valueStreak includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining; cr.\r\ttemp := self getHighestValueStreak: remaining.\r\tvalueStreak2 := OrderedCollection new.\r\t(temp size >= 2) ifTrue: [ (temp size -1) to: (temp size) do: [ :i | valueStreak2 add: (temp at: i ) ] ].\r\t\r\t(valueStreak size == 3 & (valueStreak2 size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreak2 )].\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\t(straight size == 5) ifTrue: [Transcript show: 6; cr. ^straight].\r\t\r\t^sorted\r\t\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 21:27',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data remaining temp straight flushOrSuitStreak straightFlush valueStreak valueStreak2 maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tvalueStreak := self getHighestValueStreak: sorted.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak; cr.\r\t\r\tTranscript show: \'-----\'; cr.\r\tflushOrSuitStreak := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak; cr.\r\t\r\tstraightFlush := OrderedCollection new.\r\t(flushOrSuitStreak size > 4) ifTrue: [  \r\t\tstraightFlush := self getHighestStreak: flushOrSuitStreak.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush; cr.].\r\t\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t\r\tremaining := sorted reject: [:a | valueStreak includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining; cr.\r\ttemp := self getHighestValueStreak: remaining.\r\tvalueStreak2 := OrderedCollection new.\r\t(temp size >= 2) ifTrue: [ (temp size -1) to: (temp size) do: [ :i | valueStreak2 add: (temp at: i ) ] ].\r\t\r\t(valueStreak size == 3 & (valueStreak2 size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreak2 )].\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\t^sorted\r\t\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 21:28',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T21:32:41.716546-05:00' ],		#prior : OmReference [ '29' ],		#self : OmReference [ '30' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\r\t(previous ~= current) ifTrue: [  \r\t(previous asNumber == (current asNumber -1) & notFound)\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r] ]].\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak',			#stamp : 'MagdalenaDhima 1/30/2021 21:01',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\r\t(previous ~= current) ifTrue: [  \r\t(previous asNumber == (current asNumber -1) & notFound)\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r] ]].\r\rTranscript show: streaks.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak',			#stamp : 'MagdalenaDhima 1/30/2021 21:32',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T21:33:25.221546-05:00' ],		#prior : OmReference [ '30' ],		#self : OmReference [ '31' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\r\t(previous ~= current) ifTrue: [  \r\t(previous asNumber == (current asNumber -1) & notFound)\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r] ]].\r\rTranscript show: streaks.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak',			#stamp : 'MagdalenaDhima 1/30/2021 21:32',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\r\t(previous ~= current) ifTrue: [  \r\t(previous asNumber == (current asNumber -1) & notFound)\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r] ]].\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\rTranscript show: highestStreak.\r\r^highestStreak',			#stamp : 'MagdalenaDhima 1/30/2021 21:33',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T21:40:50.297546-05:00' ],		#prior : OmReference [ '31' ],		#self : OmReference [ '32' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\t(previous asNumber == current asNumber)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. \t\tvalueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmaxCount := 0.\r\tmaxVal := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > maxCount | (aKey > maxVal & (aValue size >= maxCount))) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue ] ].\r\r\thighestValueStreak := valueStreak.\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/30/2021 17:28',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\t(previous asNumber == current asNumber)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\tTranscript show: dataInHand; cr.  \r\r\tvalueStreak := OrderedCollection new.\r\tmaxCount := 0.\r\tmaxVal := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > maxCount | (aKey > maxVal & (aValue size >= maxCount))) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue ] ].\r\r\thighestValueStreak := valueStreak.\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/30/2021 21:40',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T21:41:50.718546-05:00' ],		#prior : OmReference [ '32' ],		#self : OmReference [ '33' ]	},	#content : EpSessionSnapshot {		#imageName : 'C:\\Users\\Administrator\\Documents\\Pharo\\images\\Pharo 8.0 - 64bit (stable)\\Pharo 8.0 - 64bit (stable).image'	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T21:43:16.129546-05:00' ],		#prior : OmReference [ '33' ],		#self : OmReference [ '34' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\t(previous asNumber == current asNumber)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\tTranscript show: dataInHand; cr.  \r\r\tvalueStreak := OrderedCollection new.\r\tmaxCount := 0.\r\tmaxVal := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > maxCount | (aKey > maxVal & (aValue size >= maxCount))) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue ] ].\r\r\thighestValueStreak := valueStreak.\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/30/2021 21:40',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\t(previous asNumber == current asNumber)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmaxCount := 0.\r\tmaxVal := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > maxCount | (aKey > maxVal & (aValue size >= maxCount))) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue ] ].\r\t\r\tTranscript show: valueStreak; cr.  \r\thighestValueStreak := valueStreak.\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/30/2021 21:43',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T21:44:48.245546-05:00' ],		#prior : OmReference [ '34' ],		#self : OmReference [ '35' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\t(previous asNumber == current asNumber)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmaxCount := 0.\r\tmaxVal := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > maxCount | (aKey > maxVal & (aValue size >= maxCount))) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue ] ].\r\t\r\tTranscript show: valueStreak; cr.  \r\thighestValueStreak := valueStreak.\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/30/2021 21:43',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\t(previous asNumber == current asNumber)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmaxCount := 0.\r\tmaxVal := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > maxCount | (aKey > maxVal & (aValue size >= maxCount))) ifTrue: [maxCount := aValue size. maxVal := aKey. Transcript show: aValue; cr. valueStreak := aValue ] ].\r\t\r\tTranscript show: valueStreak; cr.  \r\thighestValueStreak := valueStreak.\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/30/2021 21:44',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T21:45:20.350546-05:00' ],		#prior : OmReference [ '35' ],		#self : OmReference [ '36' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\t(previous asNumber == current asNumber)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmaxCount := 0.\r\tmaxVal := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > maxCount | (aKey > maxVal & (aValue size >= maxCount))) ifTrue: [maxCount := aValue size. maxVal := aKey. Transcript show: aValue; cr. valueStreak := aValue ] ].\r\t\r\tTranscript show: valueStreak; cr.  \r\thighestValueStreak := valueStreak.\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/30/2021 21:44',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\t(previous asNumber == current asNumber)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmaxCount := 0.\r\tmaxVal := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > maxCount | (aKey > maxVal & (aValue size >= maxCount))) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue. Transcript show: aValue; cr. ] ].\r\t\r\tTranscript show: valueStreak; cr.  \r\thighestValueStreak := valueStreak.\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/30/2021 21:45',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T21:45:45.302546-05:00' ],		#prior : OmReference [ '36' ],		#self : OmReference [ '37' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\t(previous asNumber == current asNumber)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmaxCount := 0.\r\tmaxVal := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > maxCount | (aKey > maxVal & (aValue size >= maxCount))) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue. Transcript show: aValue; cr. ] ].\r\t\r\tTranscript show: valueStreak; cr.  \r\thighestValueStreak := valueStreak.\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/30/2021 21:45',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\t(previous asNumber == current asNumber)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmaxCount := 0.\r\tmaxVal := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > maxCount | (aKey > maxVal & (aValue size >= maxCount))) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue. Transcript show: valueStreak; cr. ] ].\r\t\r\tTranscript show: valueStreak; cr.  \r\thighestValueStreak := valueStreak.\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/30/2021 21:45',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T21:46:14.118546-05:00' ],		#prior : OmReference [ '37' ],		#self : OmReference [ '38' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\t(previous asNumber == current asNumber)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmaxCount := 0.\r\tmaxVal := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > maxCount | (aKey > maxVal & (aValue size >= maxCount))) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue. Transcript show: valueStreak; cr. ] ].\r\t\r\tTranscript show: valueStreak; cr.  \r\thighestValueStreak := valueStreak.\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/30/2021 21:45',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\t(previous asNumber == current asNumber)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmaxCount := 0.\r\tmaxVal := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > maxCount | (aKey > maxVal & (aValue size >= maxCount))) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue. Transcript show: valueStreak; cr. ] ].\r\t\r\tTranscript show: valueStreak; cr.  \r\thighestValueStreak := valueStreak.\r\tTranscript show: valueStreak; cr.\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/30/2021 21:46',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T21:46:22.396546-05:00' ],		#prior : OmReference [ '38' ],		#self : OmReference [ '39' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\t(previous asNumber == current asNumber)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmaxCount := 0.\r\tmaxVal := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > maxCount | (aKey > maxVal & (aValue size >= maxCount))) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue. Transcript show: valueStreak; cr. ] ].\r\t\r\tTranscript show: valueStreak; cr.  \r\thighestValueStreak := valueStreak.\r\tTranscript show: valueStreak; cr.\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/30/2021 21:46',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\t(previous asNumber == current asNumber)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmaxCount := 0.\r\tmaxVal := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > maxCount | (aKey > maxVal & (aValue size >= maxCount))) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue. Transcript show: valueStreak; cr. ] ].\r\t\r\tTranscript show: valueStreak; cr.  \r\thighestValueStreak := valueStreak.\r\tTranscript show: highestValueStreak; cr.\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/30/2021 21:46',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T21:48:55.224546-05:00' ],		#prior : OmReference [ '39' ],		#self : OmReference [ '40' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\t(previous asNumber == current asNumber)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmaxCount := 0.\r\tmaxVal := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > maxCount | (aKey > maxVal & (aValue size >= maxCount))) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue. Transcript show: valueStreak; cr. ] ].\r\t\r\tTranscript show: valueStreak; cr.  \r\thighestValueStreak := valueStreak.\r\tTranscript show: highestValueStreak; cr.\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/30/2021 21:46',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\t(previous asNumber == current asNumber)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmaxCount := 0.\r\tmaxVal := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > maxCount | (aKey asString > maxVal asString & (aValue size >= maxCount))) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue. Transcript show: valueStreak; cr. ] ].\r\t\r\thighestValueStreak := valueStreak.\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/30/2021 21:48',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T21:49:38.617546-05:00' ],		#prior : OmReference [ '40' ],		#self : OmReference [ '41' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\t(previous asNumber == current asNumber)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmaxCount := 0.\r\tmaxVal := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > maxCount | (aKey asString > maxVal asString & (aValue size >= maxCount))) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue. Transcript show: valueStreak; cr. ] ].\r\t\r\thighestValueStreak := valueStreak.\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/30/2021 21:48',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\t(previous asNumber == current asNumber)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmaxCount := 0.\r\tmaxVal := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > maxCount | (aKey asString > maxVal asString & (aValue size >= maxCount))) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue] ].\r\t\r\tTranscript show: valueStreak; cr. \r\thighestValueStreak := valueStreak.\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/30/2021 21:49',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T21:49:53.525546-05:00' ],		#prior : OmReference [ '41' ],		#self : OmReference [ '42' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , \' \' )]. \r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tTranscript show: dataInHand; cr.\r\t\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tword := \'\'.\r\t\ttemp := OrderedCollection new.\r\t\taValue do: [:a | (a asString ~= \' \') ifTrue: [word := word , a asString] ifFalse: [ temp add: word. word := \'\' ] ].\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:46',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , \' \' )]. \r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\t\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tword := \'\'.\r\t\ttemp := OrderedCollection new.\r\t\taValue do: [:a | (a asString ~= \' \') ifTrue: [word := word , a asString] ifFalse: [ temp add: word. word := \'\' ] ].\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 21:49',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T21:50:09.242546-05:00' ],		#prior : OmReference [ '42' ],		#self : OmReference [ '43' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\r\t(previous ~= current) ifTrue: [  \r\t(previous asNumber == (current asNumber -1) & notFound)\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r] ]].\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\rTranscript show: highestStreak.\r\r^highestStreak',			#stamp : 'MagdalenaDhima 1/30/2021 21:33',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\r\t(previous ~= current) ifTrue: [  \r\t(previous asNumber == (current asNumber -1) & notFound)\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r] ]].\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r\r^highestStreak',			#stamp : 'MagdalenaDhima 1/30/2021 21:50',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T21:51:23.380546-05:00' ],		#prior : OmReference [ '43' ],		#self : OmReference [ '44' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\t(previous asNumber == current asNumber)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmaxCount := 0.\r\tmaxVal := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > maxCount | (aKey asString > maxVal asString & (aValue size >= maxCount))) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue] ].\r\t\r\tTranscript show: valueStreak; cr. \r\thighestValueStreak := valueStreak.\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/30/2021 21:49',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\t(previous asNumber == current asNumber)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmaxCount := 0.\r\tmaxVal := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > maxCount | (aKey asNumber > maxVal asNumber & (aValue size >= maxCount))) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue] ].\r\t\r\tTranscript show: valueStreak; cr. \r\thighestValueStreak := valueStreak.\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/30/2021 21:51',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T21:51:41.753546-05:00' ],		#prior : OmReference [ '44' ],		#self : OmReference [ '45' ]	},	#content : EpSessionSnapshot {		#imageName : 'C:\\Users\\Administrator\\Documents\\Pharo\\images\\Pharo 8.0 - 64bit (stable)\\Pharo 8.0 - 64bit (stable).image'	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T22:02:38.961546-05:00' ],		#prior : OmReference [ '45' ],		#self : OmReference [ '46' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data remaining temp straight flushOrSuitStreak straightFlush valueStreak valueStreak2 maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tvalueStreak := self getHighestValueStreak: sorted.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak; cr.\r\t\r\tTranscript show: \'-----\'; cr.\r\tflushOrSuitStreak := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak; cr.\r\t\r\tstraightFlush := OrderedCollection new.\r\t(flushOrSuitStreak size > 4) ifTrue: [  \r\t\tstraightFlush := self getHighestStreak: flushOrSuitStreak.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush; cr.].\r\t\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t\r\tremaining := sorted reject: [:a | valueStreak includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining; cr.\r\ttemp := self getHighestValueStreak: remaining.\r\tvalueStreak2 := OrderedCollection new.\r\t(temp size >= 2) ifTrue: [ (temp size -1) to: (temp size) do: [ :i | valueStreak2 add: (temp at: i ) ] ].\r\t\r\t(valueStreak size == 3 & (valueStreak2 size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreak2 )].\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\t^sorted\r\t\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 21:28',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data remaining temp straight flushOrSuitStreak straightFlush valueStreak valueStreak2 maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tvalueStreak := self getHighestValueStreak: sorted.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak; cr.\r\t\r\tTranscript show: \'-----\'; cr.\r\tflushOrSuitStreak := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak; cr.\r\t\r\tstraightFlush := OrderedCollection new.\r\t(flushOrSuitStreak size > 4) ifTrue: [  \r\t\tstraightFlush := self getHighestStreak: flushOrSuitStreak.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush; cr.].\r\t\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t\r\tremaining := sorted reject: [:a | valueStreak includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining; cr.\r\ttemp := self getHighestValueStreak: remaining.\r\tvalueStreak2 := OrderedCollection new.\r\t(temp size >= 2) ifTrue: [ (temp size -1) to: (temp size) do: [ :i | valueStreak2 add: (temp at: i ) ] ].\r\t\r\t(valueStreak size == 3 & (valueStreak2 size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreak2 )].\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t(valueStreak size == 2 & (valueStreak2 size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreak2 )].\r\r\t\r\t\r\t\r\t^sorted\r\t\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 22:02',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T22:06:56.319546-05:00' ],		#prior : OmReference [ '46' ],		#self : OmReference [ '47' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data remaining temp straight flushOrSuitStreak straightFlush valueStreak valueStreak2 maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tvalueStreak := self getHighestValueStreak: sorted.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak; cr.\r\t\r\tTranscript show: \'-----\'; cr.\r\tflushOrSuitStreak := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak; cr.\r\t\r\tstraightFlush := OrderedCollection new.\r\t(flushOrSuitStreak size > 4) ifTrue: [  \r\t\tstraightFlush := self getHighestStreak: flushOrSuitStreak.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush; cr.].\r\t\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t\r\tremaining := sorted reject: [:a | valueStreak includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining; cr.\r\ttemp := self getHighestValueStreak: remaining.\r\tvalueStreak2 := OrderedCollection new.\r\t(temp size >= 2) ifTrue: [ (temp size -1) to: (temp size) do: [ :i | valueStreak2 add: (temp at: i ) ] ].\r\t\r\t(valueStreak size == 3 & (valueStreak2 size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreak2 )].\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t(valueStreak size == 2 & (valueStreak2 size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreak2 )].\r\r\t\r\t\r\t\r\t^sorted\r\t\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 22:02',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data remaining temp straight flushOrSuitStreak straightFlush valueStreak valueStreak2 maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tvalueStreak := self getHighestValueStreak: sorted.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak; cr.\r\t\r\tTranscript show: \'-----\'; cr.\r\tflushOrSuitStreak := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak; cr.\r\t\r\tstraightFlush := OrderedCollection new.\r\t(flushOrSuitStreak size > 4) ifTrue: [  \r\t\tstraightFlush := self getHighestStreak: flushOrSuitStreak.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush; cr.].\r\t\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t\r\tremaining := sorted reject: [:a | valueStreak includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining; cr.\r\ttemp := self getHighestValueStreak: remaining.\r\tvalueStreak2 := OrderedCollection new.\r\t(temp size >= 2) ifTrue: [ (temp size -1) to: (temp size) do: [ :i | valueStreak2 add: (temp at: i ) ] ].\r\t\r\t(valueStreak size == 3 & (valueStreak2 size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreak2 )].\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t(valueStreak size == 2 & (valueStreak2 size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreak2 )].\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\t\r\t^sorted\r\t\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 22:06',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T22:07:56.775546-05:00' ],		#prior : OmReference [ '47' ],		#self : OmReference [ '48' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data remaining temp straight flushOrSuitStreak straightFlush valueStreak valueStreak2 maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tvalueStreak := self getHighestValueStreak: sorted.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak; cr.\r\t\r\tTranscript show: \'-----\'; cr.\r\tflushOrSuitStreak := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak; cr.\r\t\r\tstraightFlush := OrderedCollection new.\r\t(flushOrSuitStreak size > 4) ifTrue: [  \r\t\tstraightFlush := self getHighestStreak: flushOrSuitStreak.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush; cr.].\r\t\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t\r\tremaining := sorted reject: [:a | valueStreak includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining; cr.\r\ttemp := self getHighestValueStreak: remaining.\r\tvalueStreak2 := OrderedCollection new.\r\t(temp size >= 2) ifTrue: [ (temp size -1) to: (temp size) do: [ :i | valueStreak2 add: (temp at: i ) ] ].\r\t\r\t(valueStreak size == 3 & (valueStreak2 size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreak2 )].\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t(valueStreak size == 2 & (valueStreak2 size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreak2 )].\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\t\r\t^sorted\r\t\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 22:06',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data remaining temp straight flushOrSuitStreak straightFlush valueStreak valueStreak2 maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tvalueStreak := self getHighestValueStreak: sorted.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak; cr.\r\t\r\tTranscript show: \'-----\'; cr.\r\tflushOrSuitStreak := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak; cr.\r\t\r\tstraightFlush := OrderedCollection new.\r\t(flushOrSuitStreak size > 4) ifTrue: [  \r\t\tstraightFlush := self getHighestStreak: flushOrSuitStreak.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush; cr.].\r\t\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t\r\tremaining := sorted reject: [:a | valueStreak includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining; cr.\r\ttemp := self getHighestValueStreak: remaining.\r\tvalueStreak2 := OrderedCollection new.\r\t(temp size >= 2) ifTrue: [ (temp size -1) to: (temp size) do: [ :i | valueStreak2 add: (temp at: i ) ] ].\r\t\r\t(valueStreak size == 3 & (valueStreak2 size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreak2 )].\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t(valueStreak size == 2 & (valueStreak2 size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreak2 )].\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t^sorted\r\t\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 22:07',			#package : #CPS506		}	}}