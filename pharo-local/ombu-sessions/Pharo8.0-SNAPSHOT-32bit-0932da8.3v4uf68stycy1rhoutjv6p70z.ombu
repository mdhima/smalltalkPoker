OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T10:47:30.967003-05:00' ],		#prior : OmReference [ 'Pharo8.0-SNAPSHOT-32bit-0932da8.9db5corx6zk0farvjlgkp0jre', '8' ],		#self : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t(previous asNumber == (current asNumber -1) & notFound)\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r] ]].\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r\r^highestStreak',			#stamp : 'MagdalenaDhima 1/30/2021 23:13',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t( (current asNumber == 1 & ( previous == 13 ) ) | (previous asNumber == (current asNumber -1) & notFound) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r] ]].\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r\r^highestStreak',			#stamp : 'MagdalenaDhima 1/31/2021 10:47',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T10:48:25.019003-05:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t( (current asNumber == 1 & ( previous == 13 ) ) | (previous asNumber == (current asNumber -1) & notFound) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r] ]].\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r\r^highestStreak',			#stamp : 'MagdalenaDhima 1/31/2021 10:47',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous == 13 ) ) | (previous asNumber == (current asNumber -1) ) ) & notFound )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r] ]].\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r\r^highestStreak',			#stamp : 'MagdalenaDhima 1/31/2021 10:48',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T10:50:58.707003-05:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous == 13 ) ) | (previous asNumber == (current asNumber -1) ) ) & notFound )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r] ]].\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r\r^highestStreak',			#stamp : 'MagdalenaDhima 1/31/2021 10:48',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous == 13 ) ) | (previous asNumber == (current asNumber -1) ) ) & notFound )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r] ]].\r\rTranscript show: streaks; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r\r^highestStreak',			#stamp : 'MagdalenaDhima 1/31/2021 10:50',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T11:06:18.294003-05:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous == 13 ) ) | (previous asNumber == (current asNumber -1) ) ) & notFound )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r] ]].\r\rTranscript show: streaks; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r\r^highestStreak',			#stamp : 'MagdalenaDhima 1/31/2021 10:50',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous == 13 ) ) | (previous asNumber == (current asNumber -1) ) ) & notFound )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r] ]].\r\rTranscript show: streaks; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [1 to: 5 do: [ :i | highestStreak add: (streaks at: i) ]].\r\r\r^highestStreak',			#stamp : 'MagdalenaDhima 1/31/2021 11:06',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T11:07:39.314003-05:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data remaining temp straight flushOrSuitStreak straightFlush valueStreak valueStreak2 maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\t\r\tsorted := self sort: hand.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight := self getHighestStreak: sorted.\r\t\r\tvalueStreak := self getHighestValueStreak: sorted.\r\t\r\tflushOrSuitStreak := self getHighestSuitStreak: sorted.\r\t\r\tstraightFlush := OrderedCollection new.\r\t(flushOrSuitStreak size > 4) ifTrue: [  \r\t\tstraightFlush := self getHighestStreak: flushOrSuitStreak].\r\t\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t(flushOrSuitStreak size == 4) ifTrue: [^flushOrSuitStreak].\r\t\r\t\r\tremaining := sorted reject: [:a | valueStreak includes: a ].\r\t\r\ttemp := self getHighestValueStreak: remaining.\r\tvalueStreak2 := OrderedCollection new.\r\t(temp size >= 2) ifTrue: [ (temp size -1) to: (temp size) do: [ :i | valueStreak2 add: (temp at: i ) ] ].\r\t\r\t(valueStreak size == 3 & (valueStreak2 size == 2) ) ifTrue: [^( valueStreak , valueStreak2 )].\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\t^sorted\r\t\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r',			#stamp : 'MagdalenaDhima 1/30/2021 22:22',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data remaining temp straight flushOrSuitStreak straightFlush valueStreak valueStreak2 maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tvalueStreak := self getHighestValueStreak: sorted.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak; cr.\r\t\r\tTranscript show: \'-----\'; cr.\r\tflushOrSuitStreak := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak; cr.\r\t\r\tstraightFlush := OrderedCollection new.\r\t(flushOrSuitStreak size > 4) ifTrue: [  \r\t\tstraightFlush := self getHighestStreak: flushOrSuitStreak.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush; cr.].\r\t\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t\r\tremaining := sorted reject: [:a | valueStreak includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining; cr.\r\ttemp := self getHighestValueStreak: remaining.\r\tvalueStreak2 := OrderedCollection new.\r\t(temp size >= 2) ifTrue: [ (temp size -1) to: (temp size) do: [ :i | valueStreak2 add: (temp at: i ) ] ].\r\t\r\t(valueStreak size == 3 & (valueStreak2 size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreak2 )].\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t(valueStreak size == 2 & (valueStreak2 size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreak2 )].\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t^sorted\r\t\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 11:07',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T11:36:54.124003-05:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous == 13 ) ) | (previous asNumber == (current asNumber -1) ) ) & notFound )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r] ]].\r\rTranscript show: streaks; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [1 to: 5 do: [ :i | highestStreak add: (streaks at: i) ]].\r\r\r^highestStreak',			#stamp : 'MagdalenaDhima 1/31/2021 11:06',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous == 13 ) ) | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r] ]].\r\rTranscript show: streaks; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [1 to: 5 do: [ :i | highestStreak add: (streaks at: i) ]].\r\r\r^highestStreak',			#stamp : 'MagdalenaDhima 1/31/2021 11:36',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T11:37:32.415003-05:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous == 13 ) ) | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r] ]].\r\rTranscript show: streaks; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [1 to: 5 do: [ :i | highestStreak add: (streaks at: i) ]].\r\r\r^highestStreak',			#stamp : 'MagdalenaDhima 1/31/2021 11:36',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous == 13 ) ) | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r] ]].\r\rTranscript show: streaks; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r\r^highestStreak',			#stamp : 'MagdalenaDhima 1/31/2021 11:37',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T11:37:47.453003-05:00' ],		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous == 13 ) ) | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r] ]].\r\rTranscript show: streaks; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r\r^highestStreak',			#stamp : 'MagdalenaDhima 1/31/2021 11:37',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous == 13 ) ) | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r] ]].\r\rTranscript show: \'here\';cr.\rTranscript show: streaks; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r\r^highestStreak',			#stamp : 'MagdalenaDhima 1/31/2021 11:37',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T11:41:06.650003-05:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , \' \' )]. \r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\t\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tword := \'\'.\r\t\ttemp := OrderedCollection new.\r\t\taValue do: [:a | (a asString ~= \' \') ifTrue: [word := word , a asString] ifFalse: [ temp add: word. word := \'\' ] ].\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 21:49',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rTranscript show: streaks; cr.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , \' \' )]. \r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\t\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tword := \'\'.\r\t\ttemp := OrderedCollection new.\r\t\taValue do: [:a | (a asString ~= \' \') ifTrue: [word := word , a asString] ifFalse: [ temp add: word. word := \'\' ] ].\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/31/2021 11:41',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T11:41:39.337003-05:00' ],		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rTranscript show: streaks; cr.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , \' \' )]. \r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\t\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tword := \'\'.\r\t\ttemp := OrderedCollection new.\r\t\taValue do: [:a | (a asString ~= \' \') ifTrue: [word := word , a asString] ifFalse: [ temp add: word. word := \'\' ] ].\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/31/2021 11:41',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rTranscript show: \'looks\'; cr.\rTranscript show: streaks; cr.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , \' \' )]. \r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\t\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tword := \'\'.\r\t\ttemp := OrderedCollection new.\r\t\taValue do: [:a | (a asString ~= \' \') ifTrue: [word := word , a asString] ifFalse: [ temp add: word. word := \'\' ] ].\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/31/2021 11:41',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T11:42:50.208003-05:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rTranscript show: \'looks\'; cr.\rTranscript show: streaks; cr.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , \' \' )]. \r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\t\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tword := \'\'.\r\t\ttemp := OrderedCollection new.\r\t\taValue do: [:a | (a asString ~= \' \') ifTrue: [word := word , a asString] ifFalse: [ temp add: word. word := \'\' ] ].\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/31/2021 11:41',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , \' \' )]. \r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\t\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tword := \'\'.\r\t\ttemp := OrderedCollection new.\r\t\taValue do: [:a | (a asString ~= \' \') ifTrue: [word := word , a asString] ifFalse: [ temp add: word. word := \'\' ] ].\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/31/2021 11:42',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T11:43:44.022003-05:00' ],		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\t(previous asNumber == current asNumber)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmaxCount := 0.\r\tmaxVal := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > maxCount | (aKey asNumber > maxVal asNumber & (aValue size >= maxCount))) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue] ].\r\t\r\thighestValueStreak := valueStreak.\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/30/2021 23:17',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\tTranscript show: streaks; cr.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\t(previous asNumber == current asNumber)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmaxCount := 0.\r\tmaxVal := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > maxCount | (aKey asNumber > maxVal asNumber & (aValue size >= maxCount))) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue] ].\r\t\r\thighestValueStreak := valueStreak.\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/31/2021 11:43',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T11:44:02.295003-05:00' ],		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\tTranscript show: streaks; cr.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\t(previous asNumber == current asNumber)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmaxCount := 0.\r\tmaxVal := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > maxCount | (aKey asNumber > maxVal asNumber & (aValue size >= maxCount))) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue] ].\r\t\r\thighestValueStreak := valueStreak.\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/31/2021 11:43',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\tTranscript show: \'input\'; cr.\r\tTranscript show: streaks; cr.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\t(previous asNumber == current asNumber)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmaxCount := 0.\r\tmaxVal := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > maxCount | (aKey asNumber > maxVal asNumber & (aValue size >= maxCount))) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue] ].\r\t\r\thighestValueStreak := valueStreak.\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/31/2021 11:44',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T11:47:42.331003-05:00' ],		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , \' \' )]. \r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\t\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tword := \'\'.\r\t\ttemp := OrderedCollection new.\r\t\taValue do: [:a | (a asString ~= \' \') ifTrue: [word := word , a asString] ifFalse: [ temp add: word. word := \'\' ] ].\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/31/2021 11:42',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , \' \' )]. \r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\t\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tword := \'\'.\r\t\ttemp := OrderedCollection new.\r\t\taValue do: [:a | (a asString ~= \' \') ifTrue: [word := word , a asString] ifFalse: [ temp add: word. word := \'\' ] ].\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\t\r\tTranscript show:  \'pattern\'; cr.\r\tTranscript show:  highestSuitStreak; cr.\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/31/2021 11:47',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T11:48:53.118003-05:00' ],		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , \' \' )]. \r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\t\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tword := \'\'.\r\t\ttemp := OrderedCollection new.\r\t\taValue do: [:a | (a asString ~= \' \') ifTrue: [word := word , a asString] ifFalse: [ temp add: word. word := \'\' ] ].\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\t\r\tTranscript show:  \'pattern\'; cr.\r\tTranscript show:  highestSuitStreak; cr.\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/31/2021 11:47',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , \' \' )]. \r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\t\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tword := \'\'.\r\t\ttemp := OrderedCollection new.\r\t\taValue do: [:a | (a asString ~= \' \') ifTrue: [word := word , a asString] ifFalse: [ temp add: word. word := \'\' ] ].\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\r\thighestSuitStreak := temp.\r\t"\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak]."\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/31/2021 11:48',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T11:49:22.563003-05:00' ],		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , \' \' )]. \r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\t\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tword := \'\'.\r\t\ttemp := OrderedCollection new.\r\t\taValue do: [:a | (a asString ~= \' \') ifTrue: [word := word , a asString] ifFalse: [ temp add: word. word := \'\' ] ].\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\r\thighestSuitStreak := temp.\r\t"\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak]."\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/31/2021 11:48',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , \' \' )]. \r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\t\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tword := \'\'.\r\t\ttemp := OrderedCollection new.\r\t\taValue do: [:a | (a asString ~= \' \') ifTrue: [word := word , a asString] ifFalse: [ temp add: word. word := \'\' ] ].\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\r\tsuitStreak := temp.\r\t"\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak]."\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/31/2021 11:49',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T11:49:49.825003-05:00' ],		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , \' \' )]. \r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\t\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tword := \'\'.\r\t\ttemp := OrderedCollection new.\r\t\taValue do: [:a | (a asString ~= \' \') ifTrue: [word := word , a asString] ifFalse: [ temp add: word. word := \'\' ] ].\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\r\tsuitStreak := temp.\r\t"\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak]."\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/31/2021 11:49',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , \' \' )]. \r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\t\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tword := \'\'.\r\t\ttemp := OrderedCollection new.\r\t\taValue do: [:a | (a asString ~= \' \') ifTrue: [word := word , a asString] ifFalse: [ temp add: word. word := \'\' ] ].\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\r\thighestSuitStreak := suitStreak.\r\t"\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak]."\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/31/2021 11:49',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T12:03:42.820003-05:00' ],		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\tTranscript show: \'input\'; cr.\r\tTranscript show: streaks; cr.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\t(previous asNumber == current asNumber)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmaxCount := 0.\r\tmaxVal := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > maxCount | (aKey asNumber > maxVal asNumber & (aValue size >= maxCount))) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue] ].\r\t\r\thighestValueStreak := valueStreak.\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/31/2021 11:44',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\tTranscript show: \'input\'; cr.\r\tTranscript show: streaks; cr.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\t(previous asNumber == current asNumber)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmaxCount := 0.\r\tmaxVal := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t( ( ( aKey asNumber ~= 1 & (aKey asNumber > maxVal asNumber) ) | (aKey asNumber == 1) ) & (aValue size >= maxCount) ) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue] ].\r\t\r\thighestValueStreak := valueStreak.\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/31/2021 12:03',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T12:11:02.759003-05:00' ],		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#definitionSource : 'Object subclass: #Poker\r\tinstanceVariableNames: \'hand\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'CPS506\'',				#superclassName : 'Object',				#traitCompositionSource : '{}'			},			#name : #Poker,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Poker,						#isMetaSide : false					},					#name : #hand,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#definitionSource : 'Poker class\r\tinstanceVariableNames: \'\'',					#traitCompositionSource : '{}'				},				#name : #'Poker class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Poker,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #CPS506,			#package : #CPS506,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#definitionSource : 'Object subclass: #Poker\r\tinstanceVariableNames: \'hand hand2\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'CPS506\'',				#superclassName : 'Object',				#traitCompositionSource : '{}'			},			#name : #Poker,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Poker,						#isMetaSide : false					},					#name : #hand,					#parent : @23				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Poker,						#isMetaSide : false					},					#name : #hand2,					#parent : @23				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#definitionSource : 'Poker class\r\tinstanceVariableNames: \'\'',					#traitCompositionSource : '{}'				},				#name : #'Poker class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @23			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Poker,					#isMetaSide : false				},				#parent : @23,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #CPS506,			#package : #CPS506,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T12:13:39.672003-05:00' ],		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sort:',			#protocol : #sorting,			#sourceCode : 'sort: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| threeDigits twoDigits sorted aces |\rthreeDigits := SortedCollection new. \rtwoDigits := SortedCollection new.\r\r1 to: 9 do: [ :i | ((shuf at: i) size == 3) ifTrue: [threeDigits add: (shuf at: i)] ifFalse: [twoDigits add: (shuf at: i)]. ].\r\rsorted := (twoDigits asArray) , (threeDigits asArray).\races := sorted select: [:a |  (a copyFrom: 1 to: (a size-1)) asNumber == 1 ].\rsorted := sorted reject: [:a |  (a copyFrom: 1 to: (a size-1)) asNumber == 1 ].\rsorted := sorted , aces.\rTranscript show: sorted; cr.\r^sorted',			#stamp : 'MagdalenaDhima 1/30/2021 23:03',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sort:',			#protocol : #sorting,			#sourceCode : 'sort: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| threeDigits twoDigits sorted aces |\r\r\t\rthreeDigits := SortedCollection new. \rtwoDigits := SortedCollection new.\r\r1 to: 9 do: [ :i | ((shuf at: i) size == 3) ifTrue: [threeDigits add: (shuf at: i)] ifFalse: [twoDigits add: (shuf at: i)]. ].\r\rsorted := (twoDigits asArray) , (threeDigits asArray).\races := sorted select: [:a |  (a copyFrom: 1 to: (a size-1)) asNumber == 1 ].\rsorted := sorted reject: [:a |  (a copyFrom: 1 to: (a size-1)) asNumber == 1 ].\rsorted := sorted , aces.\rTranscript show: sorted; cr.\r^sorted',			#stamp : 'MagdalenaDhima 1/31/2021 12:13',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T12:20:01.592003-05:00' ],		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'divideHands:',			#protocol : #'as yet unclassified',			#sourceCode : 'divideHands: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temporary variable names |\r\thand := SortedCollection new. \r\thand2 := SortedCollection new. \r\r\t1 to: 4 do: [ :i | (i \\\\ 2 == 1) ifTrue: [ hand add: (shuf at: i) ] ifFalse: [ hand2 add: (shuf at: i) ] ].\r\t5 to: 9 do: [ :i | hand add: (shuf at: i). hand2 add: (shuf at: i) ].',			#stamp : 'MagdalenaDhima 1/31/2021 12:20',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T12:20:07.793003-05:00' ],		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'divideHands:',			#protocol : #'as yet unclassified',			#sourceCode : 'divideHands: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temporary variable names |\r\thand := SortedCollection new. \r\thand2 := SortedCollection new. \r\r\t1 to: 4 do: [ :i | (i \\\\ 2 == 1) ifTrue: [ hand add: (shuf at: i) ] ifFalse: [ hand2 add: (shuf at: i) ] ].\r\t5 to: 9 do: [ :i | hand add: (shuf at: i). hand2 add: (shuf at: i) ].',			#stamp : 'MagdalenaDhima 1/31/2021 12:20',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'divideHands:',			#protocol : #'as yet unclassified',			#sourceCode : 'divideHands: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\thand := SortedCollection new. \r\thand2 := SortedCollection new. \r\r\t1 to: 4 do: [ :i | (i \\\\ 2 == 1) ifTrue: [ hand add: (shuf at: i) ] ifFalse: [ hand2 add: (shuf at: i) ] ].\r\t5 to: 9 do: [ :i | hand add: (shuf at: i). hand2 add: (shuf at: i) ].',			#stamp : 'MagdalenaDhima 1/31/2021 12:20',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T12:20:37.777003-05:00' ],		#prior : OmReference [ '22' ],		#self : OmReference [ '23' ]	},	#content : EpSessionSnapshot {		#imageName : 'C:\\Users\\Administrator\\Documents\\Pharo\\images\\Pharo 8.0 - 64bit (stable)\\Pharo 8.0 - 64bit (stable).image'	}}