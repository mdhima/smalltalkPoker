OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T09:41:58.595131-05:00' ],		#prior : OmReference [ 'Pharo8.0-SNAPSHOT-32bit-0932da8.9hgx7zn2gr3ajsg7c3m467mez', '66' ],		#self : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 23:30',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\tTranscript show: hand.\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak1; show: valueStreak2 ;cr.\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\tTranscript show: valueStreak1; show: valueStreak2 ;cr.\r\t\t(valueStreak1 at: 1) = (valueStreak2 at: 1)  ifTrue: [ \r\t\t\t\r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\t((valueStreak1b at: 1) = (temp2 at: 1)) & (valueStreak1 size == 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]. \r\t\t\t((valueStreak2b at: 1) = (temp2 at: 1)) & (valueStreak2 size == 3)  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]. \r\t\t\t] ifFalse: [ \r\t\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & (valueStreak1 size == 3) ifTrue: [  \r\t\t\t\t\tvalueStreakA := valueStreak1 , valueStreak1b].\r\t\t\t\t((valueStreak2 at: 1) = (temp1 at: 1)) & (valueStreak2 size == 3) ifTrue: [  \r\t\t\t\t\tvalueStreakB := valueStreak2 , valueStreak2b].\r\t\t\t ].\r\t].\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ] ].\r\t^sorted.  ',			#stamp : 'MagdalenaDhima 2/12/2021 09:41',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T09:43:13.856131-05:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\tTranscript show: hand.\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak1; show: valueStreak2 ;cr.\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\tTranscript show: valueStreak1; show: valueStreak2 ;cr.\r\t\t(valueStreak1 at: 1) = (valueStreak2 at: 1)  ifTrue: [ \r\t\t\t\r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\t((valueStreak1b at: 1) = (temp2 at: 1)) & (valueStreak1 size == 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]. \r\t\t\t((valueStreak2b at: 1) = (temp2 at: 1)) & (valueStreak2 size == 3)  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]. \r\t\t\t] ifFalse: [ \r\t\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & (valueStreak1 size == 3) ifTrue: [  \r\t\t\t\t\tvalueStreakA := valueStreak1 , valueStreak1b].\r\t\t\t\t((valueStreak2 at: 1) = (temp1 at: 1)) & (valueStreak2 size == 3) ifTrue: [  \r\t\t\t\t\tvalueStreakB := valueStreak2 , valueStreak2b].\r\t\t\t ].\r\t].\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ] ].\r\t^sorted.  ',			#stamp : 'MagdalenaDhima 2/12/2021 09:41',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\tTranscript show: hand.\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak1; show: valueStreak2 ;cr.\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\tTranscript show: valueStreak1; show: valueStreak2 ;cr.\r\t\t(valueStreak1 at: 1) = (valueStreak2 at: 1)  ifTrue: [ \r\t\t\tTranscript show: valueStreak1; show: valueStreak2 ;cr.\r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\t((valueStreak1b at: 1) = (temp2 at: 1)) & (valueStreak1 size == 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]. \r\t\t\t((valueStreak2b at: 1) = (temp2 at: 1)) & (valueStreak2 size == 3)  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]. \r\t\t\t] ifFalse: [ \r\t\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & (valueStreak1 size == 3) ifTrue: [  \r\t\t\t\t\tvalueStreakA := valueStreak1 , valueStreak1b].\r\t\t\t\t((valueStreak2 at: 1) = (temp1 at: 1)) & (valueStreak2 size == 3) ifTrue: [  \r\t\t\t\t\tvalueStreakB := valueStreak2 , valueStreak2b].\r\t\t\t ].\r\t].\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ] ].\r\t^sorted.  ',			#stamp : 'MagdalenaDhima 2/12/2021 09:43',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T09:44:16.460131-05:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\tTranscript show: hand.\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak1; show: valueStreak2 ;cr.\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\tTranscript show: valueStreak1; show: valueStreak2 ;cr.\r\t\t(valueStreak1 at: 1) = (valueStreak2 at: 1)  ifTrue: [ \r\t\t\tTranscript show: valueStreak1; show: valueStreak2 ;cr.\r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\t((valueStreak1b at: 1) = (temp2 at: 1)) & (valueStreak1 size == 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]. \r\t\t\t((valueStreak2b at: 1) = (temp2 at: 1)) & (valueStreak2 size == 3)  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]. \r\t\t\t] ifFalse: [ \r\t\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & (valueStreak1 size == 3) ifTrue: [  \r\t\t\t\t\tvalueStreakA := valueStreak1 , valueStreak1b].\r\t\t\t\t((valueStreak2 at: 1) = (temp1 at: 1)) & (valueStreak2 size == 3) ifTrue: [  \r\t\t\t\t\tvalueStreakB := valueStreak2 , valueStreak2b].\r\t\t\t ].\r\t].\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ] ].\r\t^sorted.  ',			#stamp : 'MagdalenaDhima 2/12/2021 09:43',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\tTranscript show: hand.\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak1; show: valueStreak2 ;cr.\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\tTranscript show: valueStreak1; show: valueStreak2 ;cr.\r\t\t(valueStreak1 at: 1) = (valueStreak2 at: 1)  ifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\t((valueStreak1b at: 1) = (temp2 at: 1)) & (valueStreak1 size == 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]. \r\t\t\t((valueStreak2b at: 1) = (temp2 at: 1)) & (valueStreak2 size == 3)  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]. \r\t\t\t] ifFalse: [ \r\t\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & (valueStreak1 size == 3) ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t((valueStreak2 at: 1) = (temp1 at: 1)) & (valueStreak2 size == 3) ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t ].\r\t].\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ] ].\r\t^sorted.  ',			#stamp : 'MagdalenaDhima 2/12/2021 09:44',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T09:45:06.743131-05:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\tTranscript show: hand.\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak1; show: valueStreak2 ;cr.\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\tTranscript show: valueStreak1; show: valueStreak2 ;cr.\r\t\t(valueStreak1 at: 1) = (valueStreak2 at: 1)  ifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\t((valueStreak1b at: 1) = (temp2 at: 1)) & (valueStreak1 size == 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]. \r\t\t\t((valueStreak2b at: 1) = (temp2 at: 1)) & (valueStreak2 size == 3)  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]. \r\t\t\t] ifFalse: [ \r\t\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & (valueStreak1 size == 3) ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t((valueStreak2 at: 1) = (temp1 at: 1)) & (valueStreak2 size == 3) ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t ].\r\t].\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ] ].\r\t^sorted.  ',			#stamp : 'MagdalenaDhima 2/12/2021 09:44',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\tTranscript show: hand.\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak1; show: valueStreak2 ;cr.\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\tTranscript show: valueStreak1; show: valueStreak2 ;cr.\r\t\t(valueStreak1 at: 1) = (valueStreak2 at: 1)  ifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\t((valueStreak1b at: 1) = (temp2 at: 1)) & (valueStreak1 size == 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]. \r\t\t\t((valueStreak2b at: 1) = (temp2 at: 1)) & (valueStreak2 size == 3)  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]. \r\t\t\t] ifFalse: [ \r\t\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & (valueStreak1 size == 3) ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t((valueStreak2 at: 1) = (temp1 at: 1)) & (valueStreak2 size == 3) ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\tTranscript show: valueStreak1; show: valueStreak2 ; show: valueStreak; cr.\r\t\t\t ].\r\t].\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ] ].\r\t^sorted.  ',			#stamp : 'MagdalenaDhima 2/12/2021 09:45',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T09:46:03.501131-05:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\tTranscript show: hand.\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak1; show: valueStreak2 ;cr.\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\tTranscript show: valueStreak1; show: valueStreak2 ;cr.\r\t\t(valueStreak1 at: 1) = (valueStreak2 at: 1)  ifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\t((valueStreak1b at: 1) = (temp2 at: 1)) & (valueStreak1 size == 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]. \r\t\t\t((valueStreak2b at: 1) = (temp2 at: 1)) & (valueStreak2 size == 3)  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]. \r\t\t\t] ifFalse: [ \r\t\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & (valueStreak1 size == 3) ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t((valueStreak2 at: 1) = (temp1 at: 1)) & (valueStreak2 size == 3) ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\tTranscript show: valueStreak1; show: valueStreak2 ; show: valueStreak; cr.\r\t\t\t ].\r\t].\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ] ].\r\t^sorted.  ',			#stamp : 'MagdalenaDhima 2/12/2021 09:45',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\tTranscript show: hand.\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak1; show: valueStreak2 ;cr.\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\tTranscript show: valueStreak1; show: valueStreak2 ;cr.\r\t\t(valueStreak1 at: 1) = (valueStreak2 at: 1)  ifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\t((valueStreak1b at: 1) = (temp2 at: 1)) & (valueStreak1 size == 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]. \r\t\t\t((valueStreak2b at: 1) = (temp2 at: 1)) & (valueStreak2 size == 3)  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]. \r\t\t\t] ifFalse: [ \r\t\t\t\tTranscript show: \'f\'; cr.\r\t\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & (valueStreak1 size == 3) ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t((valueStreak2 at: 1) = (temp1 at: 1)) & (valueStreak2 size == 3) ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\tTranscript show: valueStreak1; show: valueStreak2 ; show: valueStreak; cr.\r\t\t\t ].\r\t].\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ] ].\r\t^sorted.  ',			#stamp : 'MagdalenaDhima 2/12/2021 09:46',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T09:46:20.403131-05:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\tTranscript show: hand.\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak1; show: valueStreak2 ;cr.\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\tTranscript show: valueStreak1; show: valueStreak2 ;cr.\r\t\t(valueStreak1 at: 1) = (valueStreak2 at: 1)  ifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\t((valueStreak1b at: 1) = (temp2 at: 1)) & (valueStreak1 size == 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]. \r\t\t\t((valueStreak2b at: 1) = (temp2 at: 1)) & (valueStreak2 size == 3)  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]. \r\t\t\t] ifFalse: [ \r\t\t\t\tTranscript show: \'f\'; cr.\r\t\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & (valueStreak1 size == 3) ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t((valueStreak2 at: 1) = (temp1 at: 1)) & (valueStreak2 size == 3) ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\tTranscript show: valueStreak1; show: valueStreak2 ; show: valueStreak; cr.\r\t\t\t ].\r\t].\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ] ].\r\t^sorted.  ',			#stamp : 'MagdalenaDhima 2/12/2021 09:46',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\tTranscript show: hand.\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak1; show: valueStreak2 ;cr.\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\tTranscript show: valueStreak1; show: valueStreak2 ;cr.\r\t\t(valueStreak1 at: 1) = (valueStreak2 at: 1)  ifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\t\tTranscript show: \'f\'; cr.\r\t\t\t((valueStreak1b at: 1) = (temp2 at: 1)) & (valueStreak1 size == 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]. \r\t\t\t((valueStreak2b at: 1) = (temp2 at: 1)) & (valueStreak2 size == 3)  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]. \r\t\t\t] ifFalse: [ \r\t\t\t\tTranscript show: \'f\'; cr.\r\t\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & (valueStreak1 size == 3) ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t((valueStreak2 at: 1) = (temp1 at: 1)) & (valueStreak2 size == 3) ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\tTranscript show: valueStreak1; show: valueStreak2 ; show: valueStreak; cr.\r\t\t\t ].\r\t].\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ] ].\r\t^sorted.  ',			#stamp : 'MagdalenaDhima 2/12/2021 09:46',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T09:52:11.478131-05:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\tTranscript show: hand.\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak1; show: valueStreak2 ;cr.\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\tTranscript show: valueStreak1; show: valueStreak2 ;cr.\r\t\t(valueStreak1 at: 1) = (valueStreak2 at: 1)  ifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\t\tTranscript show: \'f\'; cr.\r\t\t\t((valueStreak1b at: 1) = (temp2 at: 1)) & (valueStreak1 size == 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]. \r\t\t\t((valueStreak2b at: 1) = (temp2 at: 1)) & (valueStreak2 size == 3)  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]. \r\t\t\t] ifFalse: [ \r\t\t\t\tTranscript show: \'f\'; cr.\r\t\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & (valueStreak1 size == 3) ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t((valueStreak2 at: 1) = (temp1 at: 1)) & (valueStreak2 size == 3) ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\tTranscript show: valueStreak1; show: valueStreak2 ; show: valueStreak; cr.\r\t\t\t ].\r\t].\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ] ].\r\t^sorted.  ',			#stamp : 'MagdalenaDhima 2/12/2021 09:46',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\tTranscript show: hand.\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak1; show: valueStreak2 ;cr.\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\tTranscript show: valueStreak1; show: valueStreak2 ;cr.\r\t\t(valueStreak1 at: 1) = (valueStreak2 at: 1)  \r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\t\tTranscript show: \'g\'; cr.\r\t\t\t((valueStreak1b at: 1) = (temp2 at: 1)) & (valueStreak1 size == 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]. \r\t\t\t((valueStreak2b at: 1) = (temp2 at: 1)) & (valueStreak2 size == 3)  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]. \r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\tTranscript show: \'f\'; cr.\r\t\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & (valueStreak1 size == 3) ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t((valueStreak2 at: 1) = (temp1 at: 1)) & (valueStreak2 size == 3) ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\tTranscript show: valueStreak1; show: valueStreak2 ; show: valueStreak; cr.\r\t\t]\r\t].\r\tTranscript show: \'A\'; cr.\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 09:52',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T09:53:04.332131-05:00' ],		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\tTranscript show: hand.\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak1; show: valueStreak2 ;cr.\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\tTranscript show: valueStreak1; show: valueStreak2 ;cr.\r\t\t(valueStreak1 at: 1) = (valueStreak2 at: 1)  \r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\t\tTranscript show: \'g\'; cr.\r\t\t\t((valueStreak1b at: 1) = (temp2 at: 1)) & (valueStreak1 size == 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]. \r\t\t\t((valueStreak2b at: 1) = (temp2 at: 1)) & (valueStreak2 size == 3)  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]. \r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\tTranscript show: \'f\'; cr.\r\t\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & (valueStreak1 size == 3) ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t((valueStreak2 at: 1) = (temp1 at: 1)) & (valueStreak2 size == 3) ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\tTranscript show: valueStreak1; show: valueStreak2 ; show: valueStreak; cr.\r\t\t]\r\t].\r\tTranscript show: \'A\'; cr.\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 09:52',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\tTranscript show: hand.\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak1; show: valueStreak2 ;cr.\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\tTranscript show: valueStreak1b; show: valueStreak2b ;cr.\r\t\t(valueStreak1 at: 1) = (valueStreak2 at: 1)  \r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\t\tTranscript show: \'g\'; cr.\r\t\t\t((valueStreak1b at: 1) = (temp2 at: 1)) & (valueStreak1 size == 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]. \r\t\t\t((valueStreak2b at: 1) = (temp2 at: 1)) & (valueStreak2 size == 3)  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]. \r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\tTranscript show: \'f\'; cr.\r\t\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & (valueStreak1 size == 3) ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t((valueStreak2 at: 1) = (temp1 at: 1)) & (valueStreak2 size == 3) ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\tTranscript show: valueStreak1; show: valueStreak2 ; show: valueStreak; cr.\r\t\t]\r\t].\r\tTranscript show: \'A\'; cr.\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 09:53',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T10:08:38.068131-05:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\tTranscript show: hand.\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak1; show: valueStreak2 ;cr.\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\tTranscript show: valueStreak1b; show: valueStreak2b ;cr.\r\t\t(valueStreak1 at: 1) = (valueStreak2 at: 1)  \r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\t\tTranscript show: \'g\'; cr.\r\t\t\t((valueStreak1b at: 1) = (temp2 at: 1)) & (valueStreak1 size == 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]. \r\t\t\t((valueStreak2b at: 1) = (temp2 at: 1)) & (valueStreak2 size == 3)  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]. \r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\tTranscript show: \'f\'; cr.\r\t\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & (valueStreak1 size == 3) ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t((valueStreak2 at: 1) = (temp1 at: 1)) & (valueStreak2 size == 3) ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\tTranscript show: valueStreak1; show: valueStreak2 ; show: valueStreak; cr.\r\t\t]\r\t].\r\tTranscript show: \'A\'; cr.\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 09:53',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\tTranscript show: hand.\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak1; show: valueStreak2 ;cr.\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\tTranscript show: valueStreak1b; show: valueStreak2b ;cr.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1)  )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\t\tTranscript show: \'g\'; cr.\r\t\t\t((valueStreak1b at: 1) = (temp2 at: 1)) & (valueStreak1 size == 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]. \r\t\t\t((valueStreak2b at: 1) = (temp2 at: 1)) & (valueStreak2 size == 3)  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]. \r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\tTranscript show: \'f\'; cr.\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\tTranscript show: valueStreak1; show: valueStreak2 ; show: valueStreak; cr.\r\t\t]\r\t].\r\tTranscript show: \'A\'; cr.\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 10:08',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T10:10:37.977131-05:00' ],		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\tTranscript show: hand.\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak1; show: valueStreak2 ;cr.\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\tTranscript show: valueStreak1b; show: valueStreak2b ;cr.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1)  )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\t\tTranscript show: \'g\'; cr.\r\t\t\t((valueStreak1b at: 1) = (temp2 at: 1)) & (valueStreak1 size == 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]. \r\t\t\t((valueStreak2b at: 1) = (temp2 at: 1)) & (valueStreak2 size == 3)  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]. \r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\tTranscript show: \'f\'; cr.\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\tTranscript show: valueStreak1; show: valueStreak2 ; show: valueStreak; cr.\r\t\t]\r\t].\r\tTranscript show: \'A\'; cr.\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 10:08',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\tTranscript show: hand.\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak1; show: valueStreak2 ;cr.\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\tTranscript show: valueStreak1b; show: valueStreak2b ;cr.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\t\tTranscript show: \'g\'; cr.\r\t\t\t(valueStreak1 size == 3) & ((valueStreak1b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]. \r\t\t\t(valueStreak2 size == 3) & ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]. \r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\tTranscript show: \'f\'; cr.\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\tTranscript show: valueStreak1; show: valueStreak2 ; show: valueStreak; cr.\r\t\t]\r\t].\r\tTranscript show: \'A\'; cr.\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 10:10',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T10:11:52.767131-05:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\tTranscript show: hand.\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak1; show: valueStreak2 ;cr.\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\tTranscript show: valueStreak1b; show: valueStreak2b ;cr.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\t\tTranscript show: \'g\'; cr.\r\t\t\t(valueStreak1 size == 3) & ((valueStreak1b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]. \r\t\t\t(valueStreak2 size == 3) & ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]. \r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\tTranscript show: \'f\'; cr.\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\tTranscript show: valueStreak1; show: valueStreak2 ; show: valueStreak; cr.\r\t\t]\r\t].\r\tTranscript show: \'A\'; cr.\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 10:10',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\tTranscript show: hand.\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak1; show: valueStreak2 ;cr.\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\tTranscript show: valueStreak1b; show: valueStreak2b ;cr.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\t\tTranscript show: \'g\'; cr.\r\t\t\t(valueStreak1 size == 3) & ((valueStreak1b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]. \r\t\t\t(valueStreak2 size == 3) & ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]. \r\t\t\t\tTranscript show: \'g\'; cr.\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\tTranscript show: \'f\'; cr.\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\tTranscript show: valueStreak1; show: valueStreak2 ; show: valueStreak; cr.\r\t\t]\r\t].\r\tTranscript show: \'A\'; cr.\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 10:11',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T10:13:29.367131-05:00' ],		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\tTranscript show: hand.\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak1; show: valueStreak2 ;cr.\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\tTranscript show: valueStreak1b; show: valueStreak2b ;cr.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\t\tTranscript show: \'g\'; cr.\r\t\t\t(valueStreak1 size == 3) & ((valueStreak1b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]. \r\t\t\t(valueStreak2 size == 3) & ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]. \r\t\t\t\tTranscript show: \'g\'; cr.\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\tTranscript show: \'f\'; cr.\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\tTranscript show: valueStreak1; show: valueStreak2 ; show: valueStreak; cr.\r\t\t]\r\t].\r\tTranscript show: \'A\'; cr.\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 10:11',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\tTranscript show: hand.\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak1; show: valueStreak2 ;cr.\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\tTranscript show: valueStreak1b; show: valueStreak2b ;cr.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\t\tTranscript show: \'g\'; cr.\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) & ((valueStreak1b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) & ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]. \r\t\t\t\tTranscript show: \'g\'; cr.\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\tTranscript show: \'f\'; cr.\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\tTranscript show: valueStreak1; show: valueStreak2 ; show: valueStreak; cr.\r\t\t]\r\t].\r\tTranscript show: \'A\'; cr.\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 10:13',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T10:14:10.580131-05:00' ],		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\tTranscript show: hand.\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak1; show: valueStreak2 ;cr.\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\tTranscript show: valueStreak1b; show: valueStreak2b ;cr.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\t\tTranscript show: \'g\'; cr.\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) & ((valueStreak1b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) & ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]. \r\t\t\t\tTranscript show: \'g\'; cr.\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\tTranscript show: \'f\'; cr.\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\tTranscript show: valueStreak1; show: valueStreak2 ; show: valueStreak; cr.\r\t\t]\r\t].\r\tTranscript show: \'A\'; cr.\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 10:13',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\tTranscript show: hand.\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak1; show: valueStreak2 ;cr.\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\tTranscript show: valueStreak1b; show: valueStreak2b ; show: temp1; show: temp2 ;cr.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\t\tTranscript show: \'g\'; cr.\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) & ((valueStreak1b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) & ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]. \r\t\t\t\tTranscript show: \'g\'; cr.\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\tTranscript show: \'f\'; cr.\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\tTranscript show: valueStreak1; show: valueStreak2 ; show: valueStreak; cr.\r\t\t]\r\t].\r\tTranscript show: \'A\'; cr.\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 10:14',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T10:14:43.188131-05:00' ],		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\tTranscript show: hand.\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak1; show: valueStreak2 ;cr.\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\tTranscript show: valueStreak1b; show: valueStreak2b ; show: temp1; show: temp2 ;cr.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\t\tTranscript show: \'g\'; cr.\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) & ((valueStreak1b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) & ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]. \r\t\t\t\tTranscript show: \'g\'; cr.\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\tTranscript show: \'f\'; cr.\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\tTranscript show: valueStreak1; show: valueStreak2 ; show: valueStreak; cr.\r\t\t]\r\t].\r\tTranscript show: \'A\'; cr.\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 10:14',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\tTranscript show: hand.\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak1; show: valueStreak2 ;cr.\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\tTranscript show: valueStreak1b; show: valueStreak2b ; show: temp1; show: temp2; cr.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\t\tTranscript show: \'g\'; cr.\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) & ((valueStreak1b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) & ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]. \r\t\t\t\tTranscript show: \'g\'; cr.\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\tTranscript show: \'f\'; cr.\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\tTranscript show: valueStreak1; show: valueStreak2 ; show: valueStreak; cr.\r\t\t]\r\t].\r\tTranscript show: \'A\'; cr.\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 10:14',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T10:16:55.356131-05:00' ],		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\tTranscript show: hand.\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak1; show: valueStreak2 ;cr.\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\tTranscript show: valueStreak1b; show: valueStreak2b ; show: temp1; show: temp2; cr.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\t\tTranscript show: \'g\'; cr.\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) & ((valueStreak1b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) & ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]. \r\t\t\t\tTranscript show: \'g\'; cr.\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\tTranscript show: \'f\'; cr.\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\tTranscript show: valueStreak1; show: valueStreak2 ; show: valueStreak; cr.\r\t\t]\r\t].\r\tTranscript show: \'A\'; cr.\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 10:14',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\tTranscript show: hand.\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak1; show: valueStreak2 ;cr.\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\tTranscript show: valueStreak1b; show: (valueStreak1b size == 2) ; show: temp1; show: temp2; cr.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\t\tTranscript show: \'g\'; cr.\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) & ((valueStreak1b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) & ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]. \r\t\t\t\tTranscript show: \'g\'; cr.\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\tTranscript show: \'f\'; cr.\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\tTranscript show: valueStreak1; show: valueStreak2 ; show: valueStreak; cr.\r\t\t]\r\t].\r\tTranscript show: \'A\'; cr.\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 10:16',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T10:18:09.089131-05:00' ],		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\tTranscript show: hand.\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak1; show: valueStreak2 ;cr.\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\tTranscript show: valueStreak1b; show: (valueStreak1b size == 2) ; show: temp1; show: temp2; cr.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\t\tTranscript show: \'g\'; cr.\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) & ((valueStreak1b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) & ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]. \r\t\t\t\tTranscript show: \'g\'; cr.\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\tTranscript show: \'f\'; cr.\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\tTranscript show: valueStreak1; show: valueStreak2 ; show: valueStreak; cr.\r\t\t]\r\t].\r\tTranscript show: \'A\'; cr.\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 10:16',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\tTranscript show: hand.\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak1; show: valueStreak2 ;cr.\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\tTranscript show: valueStreak1b; show: (valueStreak1b size == 2) ; show: temp1; show: temp2; cr.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\t\tTranscript show: \'g\'; cr.\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\tTranscript show: \'g\'; cr.\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\tTranscript show: \'f\'; cr.\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\tTranscript show: valueStreak1; show: valueStreak2 ; show: valueStreak; cr.\r\t\t]\r\t].\r\tTranscript show: \'A\'; cr.\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 10:18',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T10:40:52.256131-05:00' ],		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) ) | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r] ]].\r\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r\r^highestStreak',			#stamp : 'MagdalenaDhima 2/11/2021 21:41',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak twoFound |\rstreaks := OrderedCollection new.\rnotFound := true.\rtwoFound := 0.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous asNumber == 2) ifTrue: [ twoFound := 1 ].\r\t(previous ~= current) ifTrue: [  \r\t( ( ( (current asNumber == 1 & ( previous asNumber == 13 ) ) | (current asNumber == 1 & ( twoFound == 1 ) ) ) | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r] ]].\r\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r\r^highestStreak',			#stamp : 'MagdalenaDhima 2/12/2021 10:40',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T10:43:49.112131-05:00' ],		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak twoFound |\rstreaks := OrderedCollection new.\rnotFound := true.\rtwoFound := 0.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous asNumber == 2) ifTrue: [ twoFound := 1 ].\r\t(previous ~= current) ifTrue: [  \r\t( ( ( (current asNumber == 1 & ( previous asNumber == 13 ) ) | (current asNumber == 1 & ( twoFound == 1 ) ) ) | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r] ]].\r\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r\r^highestStreak',			#stamp : 'MagdalenaDhima 2/12/2021 10:40',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak twoFound |\rstreaks := OrderedCollection new.\rnotFound := true.\rtwoFound := 0.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous asNumber == 2) ifTrue: [ twoFound := 1 ].\r\t(previous ~= current) ifTrue: [  \r\t( ( ( (current asNumber == 1 & ( previous asNumber == 13 ) ) | (current asNumber == 1 & ( twoFound == 1 ) ) ) | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r] ]].\r\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\rTranscript show: highestStreak.\r^highestStreak',			#stamp : 'MagdalenaDhima 2/12/2021 10:43',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T10:44:07.298131-05:00' ],		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak twoFound |\rstreaks := OrderedCollection new.\rnotFound := true.\rtwoFound := 0.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous asNumber == 2) ifTrue: [ twoFound := 1 ].\r\t(previous ~= current) ifTrue: [  \r\t( ( ( (current asNumber == 1 & ( previous asNumber == 13 ) ) | (current asNumber == 1 & ( twoFound == 1 ) ) ) | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r] ]].\r\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\rTranscript show: highestStreak.\r^highestStreak',			#stamp : 'MagdalenaDhima 2/12/2021 10:43',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak twoFound |\rstreaks := OrderedCollection new.\rnotFound := true.\rtwoFound := 0.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous asNumber == 2) ifTrue: [ twoFound := 1 ].\r\t(previous ~= current) ifTrue: [  \r\t( ( ( (current asNumber == 1 & ( previous asNumber == 13 ) ) | (current asNumber == 1 & ( twoFound == 1 ) ) ) | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r] ]].\r\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\rTranscript cr; show: highestStreak; cr.\r^highestStreak',			#stamp : 'MagdalenaDhima 2/12/2021 10:44',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T10:44:28.127131-05:00' ],		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak twoFound |\rstreaks := OrderedCollection new.\rnotFound := true.\rtwoFound := 0.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous asNumber == 2) ifTrue: [ twoFound := 1 ].\r\t(previous ~= current) ifTrue: [  \r\t( ( ( (current asNumber == 1 & ( previous asNumber == 13 ) ) | (current asNumber == 1 & ( twoFound == 1 ) ) ) | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r] ]].\r\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\rTranscript cr; show: highestStreak; cr.\r^highestStreak',			#stamp : 'MagdalenaDhima 2/12/2021 10:44',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak twoFound |\rstreaks := OrderedCollection new.\rnotFound := true.\rtwoFound := 0.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous asNumber == 2) ifTrue: [ twoFound := 1 ].\r\t(previous ~= current) ifTrue: [  \r\t( ( ( (current asNumber == 1 & ( previous asNumber == 13 ) ) | (current asNumber == 1 & ( twoFound == 1 ) ) ) | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r] ]].\r\rTranscript cr; show: streaks; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak',			#stamp : 'MagdalenaDhima 2/12/2021 10:44',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T10:46:50.860131-05:00' ],		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak twoFound |\rstreaks := OrderedCollection new.\rnotFound := true.\rtwoFound := 0.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous asNumber == 2) ifTrue: [ twoFound := 1 ].\r\t(previous ~= current) ifTrue: [  \r\t( ( ( (current asNumber == 1 & ( previous asNumber == 13 ) ) | (current asNumber == 1 & ( twoFound == 1 ) ) ) | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r] ]].\r\rTranscript cr; show: streaks; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak',			#stamp : 'MagdalenaDhima 2/12/2021 10:44',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak twoFound |\rstreaks := OrderedCollection new.\rnotFound := true.\rtwoFound := 0.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous asNumber == 2) ifTrue: [ twoFound := 1 ].\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r] ]].\r\rTranscript cr; show: streaks ; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak',			#stamp : 'MagdalenaDhima 2/12/2021 10:46',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T10:47:23.484131-05:00' ],		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak twoFound |\rstreaks := OrderedCollection new.\rnotFound := true.\rtwoFound := 0.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous asNumber == 2) ifTrue: [ twoFound := 1 ].\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r] ]].\r\rTranscript cr; show: streaks ; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak',			#stamp : 'MagdalenaDhima 2/12/2021 10:46',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak twoFound |\rstreaks := OrderedCollection new.\rnotFound := true.\rtwoFound := 0.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous asNumber == 2) ifTrue: [ twoFound := 1 ].\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r] ]].\r\rTranscript show: \'h\'; cr; show: streaks ; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak',			#stamp : 'MagdalenaDhima 2/12/2021 10:47',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T10:48:05.156131-05:00' ],		#prior : OmReference [ '22' ],		#self : OmReference [ '23' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\tTranscript show: hand.\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak1; show: valueStreak2 ;cr.\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\tTranscript show: valueStreak1b; show: (valueStreak1b size == 2) ; show: temp1; show: temp2; cr.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\t\tTranscript show: \'g\'; cr.\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\tTranscript show: \'g\'; cr.\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\tTranscript show: \'f\'; cr.\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\tTranscript show: valueStreak1; show: valueStreak2 ; show: valueStreak; cr.\r\t\t]\r\t].\r\tTranscript show: \'A\'; cr.\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 10:18',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: sorted1;cr;show: sorted2;cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\tTranscript show: hand.\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak1; show: valueStreak2 ;cr.\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\tTranscript show: valueStreak1b; show: (valueStreak1b size == 2) ; show: temp1; show: temp2; cr.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\t\tTranscript show: \'g\'; cr.\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\tTranscript show: \'g\'; cr.\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\tTranscript show: \'f\'; cr.\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\tTranscript show: valueStreak1; show: valueStreak2 ; show: valueStreak; cr.\r\t\t]\r\t].\r\tTranscript show: \'A\'; cr.\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 10:48',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T11:00:17.940131-05:00' ],		#prior : OmReference [ '23' ],		#self : OmReference [ '24' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak twoFound |\rstreaks := OrderedCollection new.\rnotFound := true.\rtwoFound := 0.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous asNumber == 2) ifTrue: [ twoFound := 1 ].\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r] ]].\r\rTranscript show: \'h\'; cr; show: streaks ; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak',			#stamp : 'MagdalenaDhima 2/12/2021 10:47',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak aceFound |\rstreaks := OrderedCollection new.\rnotFound := true.\raceFound := 0.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(current asNumber == 1) ifTrue: [ aceFound := i ].\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [\r\t\t\tTranscript show: streaks.\r\t\t\t((streaks size == 4) & (previous asNumber == 5)) ifTrue: [ (aceFound ~= 0) ifTrue: [streaks add: (nice at: aceFound)] ] \r\t\t\t\tifFalse: [ (streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false] ].\r ]]].\r\rTranscript show: \'h\'; cr; show: streaks ; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak ',			#stamp : 'MagdalenaDhima 2/12/2021 11:00',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T11:01:22.931131-05:00' ],		#prior : OmReference [ '24' ],		#self : OmReference [ '25' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak aceFound |\rstreaks := OrderedCollection new.\rnotFound := true.\raceFound := 0.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(current asNumber == 1) ifTrue: [ aceFound := i ].\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [\r\t\t\tTranscript show: streaks.\r\t\t\t((streaks size == 4) & (previous asNumber == 5)) ifTrue: [ (aceFound ~= 0) ifTrue: [streaks add: (nice at: aceFound)] ] \r\t\t\t\tifFalse: [ (streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false] ].\r ]]].\r\rTranscript show: \'h\'; cr; show: streaks ; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak ',			#stamp : 'MagdalenaDhima 2/12/2021 11:00',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak aceFound |\rstreaks := OrderedCollection new.\rnotFound := true.\raceFound := 0.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(current asNumber == 1) ifTrue: [ aceFound := i ].\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [\r\t\t\tTranscript show: streaks.\r\t\t\t((streaks size == 4) & (previous asNumber == 5)) ifTrue: [ (aceFound ~= 0) ifTrue: [streaks add: (nice at: aceFound). Transcript show: streaks.] ] \r\t\t\t\tifFalse: [ (streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false] ].\r ]]].\r\rTranscript show: \'h\'; cr; show: streaks ; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak ',			#stamp : 'MagdalenaDhima 2/12/2021 11:01',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T11:01:54.394131-05:00' ],		#prior : OmReference [ '25' ],		#self : OmReference [ '26' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak aceFound |\rstreaks := OrderedCollection new.\rnotFound := true.\raceFound := 0.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(current asNumber == 1) ifTrue: [ aceFound := i ].\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [\r\t\t\tTranscript show: streaks.\r\t\t\t((streaks size == 4) & (previous asNumber == 5)) ifTrue: [ (aceFound ~= 0) ifTrue: [streaks add: (nice at: aceFound). Transcript show: streaks.] ] \r\t\t\t\tifFalse: [ (streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false] ].\r ]]].\r\rTranscript show: \'h\'; cr; show: streaks ; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak ',			#stamp : 'MagdalenaDhima 2/12/2021 11:01',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak aceFound |\rstreaks := OrderedCollection new.\rnotFound := true.\raceFound := 0.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(current asNumber == 1) ifTrue: [ aceFound := i ].\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [\r\t\t\tTranscript show: streaks.\r\t\t\t((streaks size == 4) & (previous asNumber == 5)) ifTrue: [ (aceFound ~= 0) ifTrue: [streaks add: (nice at: aceFound). Transcript show: \'here\'; cr; show: streaks.] ] \r\t\t\t\tifFalse: [ (streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false] ].\r ]]].\r\rTranscript show: \'h\'; cr; show: streaks ; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak ',			#stamp : 'MagdalenaDhima 2/12/2021 11:01',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T11:02:50.416131-05:00' ],		#prior : OmReference [ '26' ],		#self : OmReference [ '27' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak aceFound |\rstreaks := OrderedCollection new.\rnotFound := true.\raceFound := 0.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(current asNumber == 1) ifTrue: [ aceFound := i ].\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [\r\t\t\tTranscript show: streaks.\r\t\t\t((streaks size == 4) & (previous asNumber == 5)) ifTrue: [ (aceFound ~= 0) ifTrue: [streaks add: (nice at: aceFound). Transcript show: \'here\'; cr; show: streaks.] ] \r\t\t\t\tifFalse: [ (streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false] ].\r ]]].\r\rTranscript show: \'h\'; cr; show: streaks ; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak ',			#stamp : 'MagdalenaDhima 2/12/2021 11:01',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak aceFound |\rstreaks := OrderedCollection new.\rnotFound := true.\raceFound := 0.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(current asNumber == 1) ifTrue: [ aceFound := i ].\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [\r\t\t\tTranscript show: streaks.\r\t\t\t((streaks size == 4) & (current asNumber == 5)) ifTrue: [ (aceFound ~= 0) ifTrue: [streaks add: (nice at: aceFound). Transcript show: \'here\'; cr; show: streaks.] ] \r\t\t\t\tifFalse: [ (streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false] ].\r ]]].\r\rTranscript show: \'h\'; cr; show: streaks ; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak ',			#stamp : 'MagdalenaDhima 2/12/2021 11:02',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T11:03:38.024131-05:00' ],		#prior : OmReference [ '27' ],		#self : OmReference [ '28' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak aceFound |\rstreaks := OrderedCollection new.\rnotFound := true.\raceFound := 0.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(current asNumber == 1) ifTrue: [ aceFound := i ].\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [\r\t\t\tTranscript show: streaks.\r\t\t\t((streaks size == 4) & (current asNumber == 5)) ifTrue: [ (aceFound ~= 0) ifTrue: [streaks add: (nice at: aceFound). Transcript show: \'here\'; cr; show: streaks.] ] \r\t\t\t\tifFalse: [ (streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false] ].\r ]]].\r\rTranscript show: \'h\'; cr; show: streaks ; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak ',			#stamp : 'MagdalenaDhima 2/12/2021 11:02',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak aceFound |\rstreaks := OrderedCollection new.\rnotFound := true.\raceFound := 0.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(current asNumber == 1) ifTrue: [ aceFound := i ].\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [\r\t\t\tTranscript show: current.\r\t\t\t((streaks size == 4) & (current asNumber == 5)) ifTrue: [ (aceFound ~= 0) ifTrue: [streaks add: (nice at: aceFound). Transcript cr ;show: \'here\'; cr; show: streaks.] ] \r\t\t\t\tifFalse: [ (streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false] ].\r ]]].\r\rTranscript show: \'h\'; cr; show: streaks ; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak ',			#stamp : 'MagdalenaDhima 2/12/2021 11:03',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T11:04:23.635131-05:00' ],		#prior : OmReference [ '28' ],		#self : OmReference [ '29' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak aceFound |\rstreaks := OrderedCollection new.\rnotFound := true.\raceFound := 0.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(current asNumber == 1) ifTrue: [ aceFound := i ].\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [\r\t\t\tTranscript show: current.\r\t\t\t((streaks size == 4) & (current asNumber == 5)) ifTrue: [ (aceFound ~= 0) ifTrue: [streaks add: (nice at: aceFound). Transcript cr ;show: \'here\'; cr; show: streaks.] ] \r\t\t\t\tifFalse: [ (streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false] ].\r ]]].\r\rTranscript show: \'h\'; cr; show: streaks ; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak ',			#stamp : 'MagdalenaDhima 2/12/2021 11:03',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak aceFound |\rstreaks := OrderedCollection new.\rnotFound := true.\raceFound := 0.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(current asNumber == 1) ifTrue: [ aceFound := i ].\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [\r\t\t\tTranscript show: previous.\r\t\t\t((streaks size == 4) & (previous asNumber == 5)) ifTrue: [ (aceFound ~= 0) ifTrue: [streaks add: (nice at: aceFound). Transcript cr ;show: \'here\'; cr; show: streaks.] ] \r\t\t\t\tifFalse: [ (streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false] ].\r ]]].\r\rTranscript show: \'h\'; cr; show: streaks ; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak ',			#stamp : 'MagdalenaDhima 2/12/2021 11:04',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T11:04:50.734131-05:00' ],		#prior : OmReference [ '29' ],		#self : OmReference [ '30' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak aceFound |\rstreaks := OrderedCollection new.\rnotFound := true.\raceFound := 0.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(current asNumber == 1) ifTrue: [ aceFound := i ].\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [\r\t\t\tTranscript show: previous.\r\t\t\t((streaks size == 4) & (previous asNumber == 5)) ifTrue: [ (aceFound ~= 0) ifTrue: [streaks add: (nice at: aceFound). Transcript cr ;show: \'here\'; cr; show: streaks.] ] \r\t\t\t\tifFalse: [ (streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false] ].\r ]]].\r\rTranscript show: \'h\'; cr; show: streaks ; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak ',			#stamp : 'MagdalenaDhima 2/12/2021 11:04',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak aceFound |\rstreaks := OrderedCollection new.\rnotFound := true.\raceFound := 0.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(current asNumber == 1) ifTrue: [ aceFound := i ].\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [\r\t\t\tTranscript show: streaks.\r\t\t\t((streaks size == 4) & (previous asNumber == 5)) ifTrue: [ (aceFound ~= 0) ifTrue: [streaks add: (nice at: aceFound). Transcript cr ;show: \'here\'; cr; show: streaks.] ] \r\t\t\t\tifFalse: [ (streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false] ].\r ]]].\r\rTranscript show: \'h\'; cr; show: streaks ; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak ',			#stamp : 'MagdalenaDhima 2/12/2021 11:04',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T11:07:05.547131-05:00' ],		#prior : OmReference [ '30' ],		#self : OmReference [ '31' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak aceFound |\rstreaks := OrderedCollection new.\rnotFound := true.\raceFound := 0.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(current asNumber == 1) ifTrue: [ aceFound := i ].\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [\r\t\t\tTranscript show: streaks.\r\t\t\t((streaks size == 4) & (previous asNumber == 5)) ifTrue: [ (aceFound ~= 0) ifTrue: [streaks add: (nice at: aceFound). Transcript cr ;show: \'here\'; cr; show: streaks.] ] \r\t\t\t\tifFalse: [ (streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false] ].\r ]]].\r\rTranscript show: \'h\'; cr; show: streaks ; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak ',			#stamp : 'MagdalenaDhima 2/12/2021 11:04',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak aceFound |\rstreaks := OrderedCollection new.\rnotFound := true.\raceFound := nice detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(current asNumber == 1) ifTrue: [ aceFound := i ].\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [\r\t\t\tTranscript show: streaks.\r\t\t\t((streaks size == 4) & (previous asNumber == 5)) ifTrue: [ (aceFound ~= 0) ifTrue: [streaks add: (nice at: aceFound). Transcript cr ;show: \'here\'; cr; show: streaks.] ] \r\t\t\t\tifFalse: [ (streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false] ].\r ]]].\r\rTranscript show: \'h\'; cr; show: streaks ; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak ',			#stamp : 'MagdalenaDhima 2/12/2021 11:07',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T11:07:20.257131-05:00' ],		#prior : OmReference [ '31' ],		#self : OmReference [ '32' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak aceFound |\rstreaks := OrderedCollection new.\rnotFound := true.\raceFound := nice detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(current asNumber == 1) ifTrue: [ aceFound := i ].\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [\r\t\t\tTranscript show: streaks.\r\t\t\t((streaks size == 4) & (previous asNumber == 5)) ifTrue: [ (aceFound ~= 0) ifTrue: [streaks add: (nice at: aceFound). Transcript cr ;show: \'here\'; cr; show: streaks.] ] \r\t\t\t\tifFalse: [ (streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false] ].\r ]]].\r\rTranscript show: \'h\'; cr; show: streaks ; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak ',			#stamp : 'MagdalenaDhima 2/12/2021 11:07',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak aceFound |\rstreaks := OrderedCollection new.\rnotFound := true.\raceFound := nice detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [\r\t\t\tTranscript show: streaks.\r\t\t\t((streaks size == 4) & (previous asNumber == 5)) ifTrue: [ (aceFound ~= 0) ifTrue: [streaks add: (nice at: aceFound). Transcript cr ;show: \'here\'; cr; show: streaks.] ] \r\t\t\t\tifFalse: [ (streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false] ].\r ]]].\r\rTranscript show: \'h\'; cr; show: streaks ; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak ',			#stamp : 'MagdalenaDhima 2/12/2021 11:07',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T11:10:18.248131-05:00' ],		#prior : OmReference [ '32' ],		#self : OmReference [ '33' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak aceFound |\rstreaks := OrderedCollection new.\rnotFound := true.\raceFound := nice detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [\r\t\t\tTranscript show: streaks.\r\t\t\t((streaks size == 4) & (previous asNumber == 5)) ifTrue: [ (aceFound ~= 0) ifTrue: [streaks add: (nice at: aceFound). Transcript cr ;show: \'here\'; cr; show: streaks.] ] \r\t\t\t\tifFalse: [ (streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false] ].\r ]]].\r\rTranscript show: \'h\'; cr; show: streaks ; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak ',			#stamp : 'MagdalenaDhima 2/12/2021 11:07',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak aceFound |\rstreaks := OrderedCollection new.\rnotFound := true.\raceFound := nice detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [\r\t\t\tTranscript show: streaks.\r\t\t\t((streaks size == 4) & (previous asNumber == 5)) ifTrue: [ (aceFound ~= 0) ifTrue: [streaks add: aceFound. Transcript cr ;show: \'here\'; cr; show: streaks.] ] \r\t\t\t\tifFalse: [ (streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false] ].\r ]]].\r\rTranscript show: \'h\'; cr; show: streaks ; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak ',			#stamp : 'MagdalenaDhima 2/12/2021 11:10',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T12:03:21.817131-05:00' ],		#prior : OmReference [ '33' ],		#self : OmReference [ '34' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak aceFound |\rstreaks := OrderedCollection new.\rnotFound := true.\raceFound := nice detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [\r\t\t\tTranscript show: streaks.\r\t\t\t((streaks size == 4) & (previous asNumber == 5)) ifTrue: [ (aceFound ~= 0) ifTrue: [streaks add: aceFound. Transcript cr ;show: \'here\'; cr; show: streaks.] ] \r\t\t\t\tifFalse: [ (streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false] ].\r ]]].\r\rTranscript show: \'h\'; cr; show: streaks ; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak ',			#stamp : 'MagdalenaDhima 2/12/2021 11:10',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) ) | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r] ]].\r\rTranscript show: \'here\';cr.\rTranscript show: streaks; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r\r^highestStreak',			#stamp : 'MagdalenaDhima 2/12/2021 12:03',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T12:03:50.774131-05:00' ],		#prior : OmReference [ '34' ],		#self : OmReference [ '35' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) ) | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r] ]].\r\rTranscript show: \'here\';cr.\rTranscript show: streaks; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r\r^highestStreak',			#stamp : 'MagdalenaDhima 2/12/2021 12:03',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) ) | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r] ]].\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r\r^highestStreak',			#stamp : 'MagdalenaDhima 2/12/2021 12:03',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T12:04:20.393131-05:00' ],		#prior : OmReference [ '35' ],		#self : OmReference [ '36' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: sorted1;cr;show: sorted2;cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\tTranscript show: hand.\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak1; show: valueStreak2 ;cr.\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\tTranscript show: valueStreak1b; show: (valueStreak1b size == 2) ; show: temp1; show: temp2; cr.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\t\tTranscript show: \'g\'; cr.\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\tTranscript show: \'g\'; cr.\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\tTranscript show: \'f\'; cr.\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\tTranscript show: valueStreak1; show: valueStreak2 ; show: valueStreak; cr.\r\t\t]\r\t].\r\tTranscript show: \'A\'; cr.\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 10:48',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\tTranscript show: hand.\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\t\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\t\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\t\r\t\t]\r\t].\r\t\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 12:04',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T12:04:36.001131-05:00' ],		#prior : OmReference [ '36' ],		#self : OmReference [ '37' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\tTranscript show: hand.\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\t\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\t\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\t\r\t\t]\r\t].\r\t\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 12:04',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\t\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\t\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\t\r\t\t]\r\t].\r\t\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 12:04',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T12:08:13.494131-05:00' ],		#prior : OmReference [ '37' ],		#self : OmReference [ '38' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\t\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\t\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\t\r\t\t]\r\t].\r\t\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 12:04',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\tTranscript show: temp2.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\t\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\t\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\t\r\t\t]\r\t].\r\t\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 12:08',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T12:08:47.285131-05:00' ],		#prior : OmReference [ '38' ],		#self : OmReference [ '39' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\tTranscript show: temp2.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\t\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\t\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\t\r\t\t]\r\t].\r\t\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 12:08',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\tTranscript show: temp2.\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\t\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\t\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\t\r\t\t]\r\t].\r\t\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 12:08',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T12:09:10.986131-05:00' ],		#prior : OmReference [ '39' ],		#self : OmReference [ '40' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\tTranscript show: temp2.\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\t\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\t\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\t\r\t\t]\r\t].\r\t\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 12:08',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ Transcript show: temp2. ((valueStreak1b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\t\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\t\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\t\r\t\t]\r\t].\r\t\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 12:09',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T12:09:28.698131-05:00' ],		#prior : OmReference [ '40' ],		#self : OmReference [ '41' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ Transcript show: temp2. ((valueStreak1b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\t\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\t\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\t\r\t\t]\r\t].\r\t\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 12:09',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ Transcript show: valueStreak1b. ((valueStreak1b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\t\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\t\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\t\r\t\t]\r\t].\r\t\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 12:09',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T12:11:31.294131-05:00' ],		#prior : OmReference [ '41' ],		#self : OmReference [ '42' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ Transcript show: valueStreak1b. ((valueStreak1b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\t\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\t\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\t\r\t\t]\r\t].\r\t\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 12:09',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ Transcript show: valueStreak1. ((valueStreak1b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\t\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\t\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\t\r\t\t]\r\t].\r\t\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 12:11',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T12:13:12.269131-05:00' ],		#prior : OmReference [ '42' ],		#self : OmReference [ '43' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ Transcript show: valueStreak1. ((valueStreak1b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\t\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\t\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\t\r\t\t]\r\t].\r\t\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 12:11',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ Transcript show: valueStreak1b. ((valueStreak1b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\t\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\t\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\t\r\t\t]\r\t].\r\t\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 12:13',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T12:23:22.348131-05:00' ],		#prior : OmReference [ '43' ],		#self : OmReference [ '44' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ Transcript show: valueStreak1b. ((valueStreak1b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\t\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\t\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\t\r\t\t]\r\t].\r\t\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 12:13',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\t\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\t\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\t\r\t\t]\r\t].\r\t\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 12:23',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T12:26:12.787131-05:00' ],		#prior : OmReference [ '44' ],		#self : OmReference [ '45' ]	},	#content : EpSessionSnapshot {		#imageName : 'C:\\Users\\Administrator\\Documents\\Pharo\\images\\Pharo 8.0 - 64bit (stable)\\game1.image'	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T13:19:49.422131-05:00' ],		#prior : OmReference [ '45' ],		#self : OmReference [ '46' ]	},	#content : EpSessionSnapshot {		#imageName : 'C:\\Users\\Administrator\\Documents\\Pharo\\images\\Pharo 8.0 - 64bit (stable)\\game1.image'	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T13:21:32.736131-05:00' ],		#prior : OmReference [ '46' ],		#self : OmReference [ '47' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) ) | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r] ]].\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r\r^highestStreak',			#stamp : 'MagdalenaDhima 2/12/2021 12:03',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak aceFound |\rstreaks := OrderedCollection new.\rnotFound := true.\raceFound := nice detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [\r\t\t\tTranscript show: streaks.\r\t\t\t((streaks size == 4) & (previous asNumber == 5)) ifTrue: [ (aceFound ~= 0) ifTrue: [streaks add: aceFound. Transcript cr ;show: \'here\'; cr; show: streaks.] ] \r\t\t\t\tifFalse: [ (streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false] ].\r ]]].\r\rTranscript show: \'h\'; cr; show: streaks ; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak ',			#stamp : 'MagdalenaDhima 2/12/2021 13:21',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T13:41:36.691131-05:00' ],		#prior : OmReference [ '47' ],		#self : OmReference [ '48' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\t\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\t\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\t\r\t\t]\r\t].\r\t\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 12:23',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 test1 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\t\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\t\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\t\r\t\t]\r\t].\r\t\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\ttest1 = 0.\r\ttemp1 := straight1 select: [:a | test1:=test1+1. ( a copyFrom: 1 to: (a size-1) ) asNumber == test1].\r\ttest1 = 0.\r\ttemp2 := straight2 select: [:a | test1:=test1+1. ( a copyFrom: 1 to: (a size-1) ) asNumber == test1].\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight isEmpty) ifTrue: [ temp1 size == 5 ifTrue: [ straight := temp1 ]. temp2 size == 5 ifTrue: [ straight := temp2 ]  ].\r\t\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 13:41',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T13:43:23.788131-05:00' ],		#prior : OmReference [ '48' ],		#self : OmReference [ '49' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 test1 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\t\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\t\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\t\r\t\t]\r\t].\r\t\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\ttest1 = 0.\r\ttemp1 := straight1 select: [:a | test1:=test1+1. ( a copyFrom: 1 to: (a size-1) ) asNumber == test1].\r\ttest1 = 0.\r\ttemp2 := straight2 select: [:a | test1:=test1+1. ( a copyFrom: 1 to: (a size-1) ) asNumber == test1].\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight isEmpty) ifTrue: [ temp1 size == 5 ifTrue: [ straight := temp1 ]. temp2 size == 5 ifTrue: [ straight := temp2 ]  ].\r\t\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 13:41',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 test1 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\tTranscript cr; cr; show: straightFlush1 ; cr; cr; show: straightFlush2; cr.\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\t\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\t\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\t\r\t\t]\r\t].\r\t\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\ttest1 = 0.\r\ttemp1 := straight1 select: [:a | test1:=test1+1. ( a copyFrom: 1 to: (a size-1) ) asNumber == test1].\r\ttest1 = 0.\r\ttemp2 := straight2 select: [:a | test1:=test1+1. ( a copyFrom: 1 to: (a size-1) ) asNumber == test1].\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight isEmpty) ifTrue: [ temp1 size == 5 ifTrue: [ straight := temp1 ]. temp2 size == 5 ifTrue: [ straight := temp2 ]  ].\r\t\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 13:43',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T13:44:02.600131-05:00' ],		#prior : OmReference [ '49' ],		#self : OmReference [ '50' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 test1 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\tTranscript cr; cr; show: straightFlush1 ; cr; cr; show: straightFlush2; cr.\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\t\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\t\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\t\r\t\t]\r\t].\r\t\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\ttest1 = 0.\r\ttemp1 := straight1 select: [:a | test1:=test1+1. ( a copyFrom: 1 to: (a size-1) ) asNumber == test1].\r\ttest1 = 0.\r\ttemp2 := straight2 select: [:a | test1:=test1+1. ( a copyFrom: 1 to: (a size-1) ) asNumber == test1].\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight isEmpty) ifTrue: [ temp1 size == 5 ifTrue: [ straight := temp1 ]. temp2 size == 5 ifTrue: [ straight := temp2 ]  ].\r\t\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 13:43',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 test1 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\tTranscript cr; cr; show: straightFlush1 ; cr; cr; show: straightFlush2; cr.\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\tTranscript cr; cr; show: straightFlush.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\t\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\t\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\t\r\t\t]\r\t].\r\t\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\ttest1 = 0.\r\ttemp1 := straight1 select: [:a | test1:=test1+1. ( a copyFrom: 1 to: (a size-1) ) asNumber == test1].\r\ttest1 = 0.\r\ttemp2 := straight2 select: [:a | test1:=test1+1. ( a copyFrom: 1 to: (a size-1) ) asNumber == test1].\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight isEmpty) ifTrue: [ temp1 size == 5 ifTrue: [ straight := temp1 ]. temp2 size == 5 ifTrue: [ straight := temp2 ]  ].\r\t\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 13:44',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T14:27:31.681131-05:00' ],		#prior : OmReference [ '50' ],		#self : OmReference [ '51' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 test1 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\tTranscript cr; cr; show: straightFlush1 ; cr; cr; show: straightFlush2; cr.\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\tTranscript cr; cr; show: straightFlush.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\t\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\t\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\t\r\t\t]\r\t].\r\t\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\ttest1 = 0.\r\ttemp1 := straight1 select: [:a | test1:=test1+1. ( a copyFrom: 1 to: (a size-1) ) asNumber == test1].\r\ttest1 = 0.\r\ttemp2 := straight2 select: [:a | test1:=test1+1. ( a copyFrom: 1 to: (a size-1) ) asNumber == test1].\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight isEmpty) ifTrue: [ temp1 size == 5 ifTrue: [ straight := temp1 ]. temp2 size == 5 ifTrue: [ straight := temp2 ]  ].\r\t\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 13:44',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 test1 test2 test3 test4 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\tTranscript cr; cr; show: straightFlush1 ; cr; cr; show: straightFlush2; cr.\r\t\r\ttemp1 := OrderedCollection new.\r\ttemp2 := OrderedCollection new.\r\ttest1 := 0. \r\ttest2 := 0. \r\ttest3 := 0. \r\ttest4 := 0. \r   temp1 := straight1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttemp2 := straight2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttest1 := straight1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest2 := straight2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\ttest4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\t\r\t\ttest3 >= test4 ifTrue: [ straightFlush := temp1 ] ifFalse: [  straightFlush := temp2  ].\r\t\t(test1 ~= 0 ) ifTrue: [ straightFlush add: test1 ].\r\t\t(test2 ~= 0 ) ifTrue: [ straightFlush add: test2 ].\r\r\t"straightFlush := self sizeCheck: 5 firstList: temp1 secondList: temp2."\r\tTranscript cr; cr; show: straightFlush.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\t\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\t\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\t\r\t\t]\r\t].\r\t\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\ttest1 = 0.\r\ttemp1 := straight1 select: [:a | test1:=test1+1. ( a copyFrom: 1 to: (a size-1) ) asNumber == test1].\r\ttest1 = 0.\r\ttemp2 := straight2 select: [:a | test1:=test1+1. ( a copyFrom: 1 to: (a size-1) ) asNumber == test1].\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight isEmpty) ifTrue: [ temp1 size == 5 ifTrue: [ straight := temp1 ]. temp2 size == 5 ifTrue: [ straight := temp2 ]  ].\r\t\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 14:27',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T14:29:30.849131-05:00' ],		#prior : OmReference [ '51' ],		#self : OmReference [ '52' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 test1 test2 test3 test4 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\tTranscript cr; cr; show: straightFlush1 ; cr; cr; show: straightFlush2; cr.\r\t\r\ttemp1 := OrderedCollection new.\r\ttemp2 := OrderedCollection new.\r\ttest1 := 0. \r\ttest2 := 0. \r\ttest3 := 0. \r\ttest4 := 0. \r   temp1 := straight1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttemp2 := straight2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttest1 := straight1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest2 := straight2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\ttest4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\t\r\t\ttest3 >= test4 ifTrue: [ straightFlush := temp1 ] ifFalse: [  straightFlush := temp2  ].\r\t\t(test1 ~= 0 ) ifTrue: [ straightFlush add: test1 ].\r\t\t(test2 ~= 0 ) ifTrue: [ straightFlush add: test2 ].\r\r\t"straightFlush := self sizeCheck: 5 firstList: temp1 secondList: temp2."\r\tTranscript cr; cr; show: straightFlush.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\t\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\t\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\t\r\t\t]\r\t].\r\t\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\ttest1 = 0.\r\ttemp1 := straight1 select: [:a | test1:=test1+1. ( a copyFrom: 1 to: (a size-1) ) asNumber == test1].\r\ttest1 = 0.\r\ttemp2 := straight2 select: [:a | test1:=test1+1. ( a copyFrom: 1 to: (a size-1) ) asNumber == test1].\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight isEmpty) ifTrue: [ temp1 size == 5 ifTrue: [ straight := temp1 ]. temp2 size == 5 ifTrue: [ straight := temp2 ]  ].\r\t\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 14:27',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 test1 test2 test3 test4 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\tTranscript cr; cr; show: straightFlush1 ; cr; cr; show: straightFlush2; cr.\r\t\r\ttemp1 := OrderedCollection new.\r\ttemp2 := OrderedCollection new.\r\ttest1 := 0. \r\ttest2 := 0. \r\ttest3 := 0. \r\ttest4 := 0. \r   temp1 := straight1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttemp2 := straight2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttest1 := straight1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest2 := straight2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\ttest4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\t\r\t\ttest3 >= test4 ifTrue: [ straightFlush := temp1.(test1 ~= 0 ) ifTrue: [ straightFlush add: test1 ]. ] \r\t\t\t\t\t\t\tifFalse: [  straightFlush := temp2. (test2 ~= 0 ) ifTrue: [ straightFlush add: test2 ]. ].\r\r\t"straightFlush := self sizeCheck: 5 firstList: temp1 secondList: temp2."\r\tTranscript cr; cr; show: straightFlush.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\t\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\t\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\t\r\t\t]\r\t].\r\t\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\ttest1 = 0.\r\ttemp1 := straight1 select: [:a | test1:=test1+1. ( a copyFrom: 1 to: (a size-1) ) asNumber == test1].\r\ttest1 = 0.\r\ttemp2 := straight2 select: [:a | test1:=test1+1. ( a copyFrom: 1 to: (a size-1) ) asNumber == test1].\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight isEmpty) ifTrue: [ temp1 size == 5 ifTrue: [ straight := temp1 ]. temp2 size == 5 ifTrue: [ straight := temp2 ]  ].\r\t\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 14:29',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T14:33:51.684131-05:00' ],		#prior : OmReference [ '52' ],		#self : OmReference [ '53' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 test1 test2 test3 test4 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\tTranscript cr; cr; show: straightFlush1 ; cr; cr; show: straightFlush2; cr.\r\t\r\ttemp1 := OrderedCollection new.\r\ttemp2 := OrderedCollection new.\r\ttest1 := 0. \r\ttest2 := 0. \r\ttest3 := 0. \r\ttest4 := 0. \r   temp1 := straight1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttemp2 := straight2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttest1 := straight1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest2 := straight2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\ttest4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\t\r\t\ttest3 >= test4 ifTrue: [ straightFlush := temp1.(test1 ~= 0 ) ifTrue: [ straightFlush add: test1 ]. ] \r\t\t\t\t\t\t\tifFalse: [  straightFlush := temp2. (test2 ~= 0 ) ifTrue: [ straightFlush add: test2 ]. ].\r\r\t"straightFlush := self sizeCheck: 5 firstList: temp1 secondList: temp2."\r\tTranscript cr; cr; show: straightFlush.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\t\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\t\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\t\r\t\t]\r\t].\r\t\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\ttest1 = 0.\r\ttemp1 := straight1 select: [:a | test1:=test1+1. ( a copyFrom: 1 to: (a size-1) ) asNumber == test1].\r\ttest1 = 0.\r\ttemp2 := straight2 select: [:a | test1:=test1+1. ( a copyFrom: 1 to: (a size-1) ) asNumber == test1].\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight isEmpty) ifTrue: [ temp1 size == 5 ifTrue: [ straight := temp1 ]. temp2 size == 5 ifTrue: [ straight := temp2 ]  ].\r\t\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 14:29',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 test1 test2 test3 test4 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\tTranscript cr; cr; show: straightFlush1 ; cr; cr; show: straightFlush2; cr.\r\t\r\ttemp1 := OrderedCollection new.\r\ttemp2 := OrderedCollection new.\r\ttest1 := 0. \r\ttest2 := 0. \r\ttest3 := 0. \r\ttest4 := 0. \r   temp1 := straight1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttemp2 := straight2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttest1 := straight1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest2 := straight2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\ttest4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\t\r\t\ttest3 >= test4 ifTrue: [ straightFlush := temp1.(test1 ~= 0 ) ifTrue: [ straightFlush add: test1 ]. ] \r\t\t\t\t\t\t\tifFalse: [  straightFlush := temp2. (test2 ~= 0 ) ifTrue: [ straightFlush add: test2 ]. ].\r\r\t"straightFlush := self sizeCheck: 5 firstList: temp1 secondList: temp2."\r\t"Transcript cr; cr; show: straightFlush."\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\t\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\t\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\t\r\t\t]\r\t].\r\t\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\ttemp1 := OrderedCollection new.\r\ttemp2 := OrderedCollection new.\r\ttest1 := 0. \r\ttest2 := 0. \r\ttest3 := 0. \r\ttest4 := 0. \r   temp1 := straight1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttemp2 := straight2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttest1 := straight1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest2 := straight2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\ttest4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\t\r\t\ttest3 >= test4 ifTrue: [ straight := temp1.(test1 ~= 0 ) ifTrue: [ straight add: test1 ]. ] \r\t\t\t\t\t\t\tifFalse: [  straight := temp2. (test2 ~= 0 ) ifTrue: [ straight add: test2 ]. ].\t\r\t\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 14:33',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T14:34:50.568131-05:00' ],		#prior : OmReference [ '53' ],		#self : OmReference [ '54' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 test1 test2 test3 test4 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\tTranscript cr; cr; show: straightFlush1 ; cr; cr; show: straightFlush2; cr.\r\t\r\ttemp1 := OrderedCollection new.\r\ttemp2 := OrderedCollection new.\r\ttest1 := 0. \r\ttest2 := 0. \r\ttest3 := 0. \r\ttest4 := 0. \r   temp1 := straight1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttemp2 := straight2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttest1 := straight1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest2 := straight2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\ttest4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\t\r\t\ttest3 >= test4 ifTrue: [ straightFlush := temp1.(test1 ~= 0 ) ifTrue: [ straightFlush add: test1 ]. ] \r\t\t\t\t\t\t\tifFalse: [  straightFlush := temp2. (test2 ~= 0 ) ifTrue: [ straightFlush add: test2 ]. ].\r\r\t"straightFlush := self sizeCheck: 5 firstList: temp1 secondList: temp2."\r\t"Transcript cr; cr; show: straightFlush."\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\t\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\t\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\t\r\t\t]\r\t].\r\t\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\ttemp1 := OrderedCollection new.\r\ttemp2 := OrderedCollection new.\r\ttest1 := 0. \r\ttest2 := 0. \r\ttest3 := 0. \r\ttest4 := 0. \r   temp1 := straight1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttemp2 := straight2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttest1 := straight1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest2 := straight2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\ttest4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\t\r\t\ttest3 >= test4 ifTrue: [ straight := temp1.(test1 ~= 0 ) ifTrue: [ straight add: test1 ]. ] \r\t\t\t\t\t\t\tifFalse: [  straight := temp2. (test2 ~= 0 ) ifTrue: [ straight add: test2 ]. ].\t\r\t\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 14:33',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 test1 test2 test3 test4 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\tTranscript cr; cr; show: straightFlush1 ; cr; cr; show: straightFlush2; cr.\r\t\r\ttemp1 := OrderedCollection new.\r\ttemp2 := OrderedCollection new.\r\ttest1 := 0. \r\ttest2 := 0. \r\ttest3 := 0. \r\ttest4 := 0. \r   temp1 := straightFlush1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttemp2 := straightFlush2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttest1 := straightFlush1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest2 := straightFlush2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\ttest4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\t\r\t\ttest3 >= test4 ifTrue: [ straightFlush := temp1.(test1 ~= 0 ) ifTrue: [ straightFlush add: test1 ]. ] \r\t\t\t\t\t\t\tifFalse: [  straightFlush := temp2. (test2 ~= 0 ) ifTrue: [ straightFlush add: test2 ]. ].\r\r\t"straightFlush := self sizeCheck: 5 firstList: temp1 secondList: temp2."\r\t"Transcript cr; cr; show: straightFlush."\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\t\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\t\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\t\r\t\t]\r\t].\r\t\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\ttemp1 := OrderedCollection new.\r\ttemp2 := OrderedCollection new.\r\ttest1 := 0. \r\ttest2 := 0. \r\ttest3 := 0. \r\ttest4 := 0. \r   temp1 := straight1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttemp2 := straight2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttest1 := straight1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest2 := straight2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\ttest4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\t\r\t\ttest3 >= test4 ifTrue: [ straight := temp1.(test1 ~= 0 ) ifTrue: [ straight add: test1 ]. ] \r\t\t\t\t\t\t\tifFalse: [  straight := temp2. (test2 ~= 0 ) ifTrue: [ straight add: test2 ]. ].\t\r\t\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 14:34',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T14:41:41.834131-05:00' ],		#prior : OmReference [ '54' ],		#self : OmReference [ '55' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 test1 test2 test3 test4 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\tTranscript cr; cr; show: straightFlush1 ; cr; cr; show: straightFlush2; cr.\r\t\r\ttemp1 := OrderedCollection new.\r\ttemp2 := OrderedCollection new.\r\ttest1 := 0. \r\ttest2 := 0. \r\ttest3 := 0. \r\ttest4 := 0. \r   temp1 := straightFlush1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttemp2 := straightFlush2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttest1 := straightFlush1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest2 := straightFlush2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\ttest4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\t\r\t\ttest3 >= test4 ifTrue: [ straightFlush := temp1.(test1 ~= 0 ) ifTrue: [ straightFlush add: test1 ]. ] \r\t\t\t\t\t\t\tifFalse: [  straightFlush := temp2. (test2 ~= 0 ) ifTrue: [ straightFlush add: test2 ]. ].\r\r\t"straightFlush := self sizeCheck: 5 firstList: temp1 secondList: temp2."\r\t"Transcript cr; cr; show: straightFlush."\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\t\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\t\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\t\r\t\t]\r\t].\r\t\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\ttemp1 := OrderedCollection new.\r\ttemp2 := OrderedCollection new.\r\ttest1 := 0. \r\ttest2 := 0. \r\ttest3 := 0. \r\ttest4 := 0. \r   temp1 := straight1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttemp2 := straight2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttest1 := straight1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest2 := straight2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\ttest4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\t\r\t\ttest3 >= test4 ifTrue: [ straight := temp1.(test1 ~= 0 ) ifTrue: [ straight add: test1 ]. ] \r\t\t\t\t\t\t\tifFalse: [  straight := temp2. (test2 ~= 0 ) ifTrue: [ straight add: test2 ]. ].\t\r\t\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 14:34',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 test1 test2 test3 test4 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\t\r\tTranscript cr; cr; show: sorted1 ; cr; cr; show: sorted2; cr.\r\t\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\tTranscript cr; cr; show: straightFlush1 ; cr; cr; show: straightFlush2; cr.\r\t\r\ttemp1 := OrderedCollection new.\r\ttemp2 := OrderedCollection new.\r\ttest1 := 0. \r\ttest2 := 0. \r\ttest3 := 0. \r\ttest4 := 0. \r   temp1 := straightFlush1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttemp2 := straightFlush2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttest1 := straightFlush1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest2 := straightFlush2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\ttest4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\t\r\t\ttest3 >= test4 ifTrue: [ straightFlush := temp1.(test1 ~= 0 ) ifTrue: [ straightFlush add: test1 ]. ] \r\t\t\t\t\t\t\tifFalse: [  straightFlush := temp2. (test2 ~= 0 ) ifTrue: [ straightFlush add: test2 ]. ].\r\r\t"straightFlush := self sizeCheck: 5 firstList: temp1 secondList: temp2."\r\t"Transcript cr; cr; show: straightFlush."\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\t\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\t\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\t\r\t\t]\r\t].\r\t\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\ttemp1 := OrderedCollection new.\r\ttemp2 := OrderedCollection new.\r\ttest1 := 0. \r\ttest2 := 0. \r\ttest3 := 0. \r\ttest4 := 0. \r   temp1 := straight1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttemp2 := straight2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttest1 := straight1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest2 := straight2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\ttest4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\t\r\t\ttest3 >= test4 ifTrue: [ straight := temp1.(test1 ~= 0 ) ifTrue: [ straight add: test1 ]. ] \r\t\t\t\t\t\t\tifFalse: [  straight := temp2. (test2 ~= 0 ) ifTrue: [ straight add: test2 ]. ].\t\r\t\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 14:41',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T14:48:18.389131-05:00' ],		#prior : OmReference [ '55' ],		#self : OmReference [ '56' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak aceFound |\rstreaks := OrderedCollection new.\rnotFound := true.\raceFound := nice detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [\r\t\t\tTranscript show: streaks.\r\t\t\t((streaks size == 4) & (previous asNumber == 5)) ifTrue: [ (aceFound ~= 0) ifTrue: [streaks add: aceFound. Transcript cr ;show: \'here\'; cr; show: streaks.] ] \r\t\t\t\tifFalse: [ (streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false] ].\r ]]].\r\rTranscript show: \'h\'; cr; show: streaks ; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak ',			#stamp : 'MagdalenaDhima 2/12/2021 13:21',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak aceFound |\rstreaks := OrderedCollection new.\rnotFound := true.\raceFound := nice detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [\r\t\t\tTranscript show: streaks; cr;cr.\r\t\t\t((streaks size == 4) & (previous asNumber == 5)) ifTrue: [ (aceFound ~= 0) ifTrue: [streaks add: aceFound. Transcript cr ;show: \'here\'; cr; show: streaks.] ] \r\t\t\t\tifFalse: [ (streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false] ].\r ]]].\r\rTranscript show: \'h\'; cr; show: streaks ; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak ',			#stamp : 'MagdalenaDhima 2/12/2021 14:48',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T14:51:20.134131-05:00' ],		#prior : OmReference [ '56' ],		#self : OmReference [ '57' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak aceFound |\rstreaks := OrderedCollection new.\rnotFound := true.\raceFound := nice detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [\r\t\t\tTranscript show: streaks; cr;cr.\r\t\t\t((streaks size == 4) & (previous asNumber == 5)) ifTrue: [ (aceFound ~= 0) ifTrue: [streaks add: aceFound. Transcript cr ;show: \'here\'; cr; show: streaks.] ] \r\t\t\t\tifFalse: [ (streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false] ].\r ]]].\r\rTranscript show: \'h\'; cr; show: streaks ; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak ',			#stamp : 'MagdalenaDhima 2/12/2021 14:48',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak aceFound |\rstreaks := OrderedCollection new.\rnotFound := true.\raceFound := nice detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [\r\t\t\tTranscript show: previous; cr;cr.\r\t\t\t((streaks size == 4) & (previous asNumber == 5)) ifTrue: [ (aceFound ~= 0) ifTrue: [streaks add: aceFound. Transcript cr ;show: \'here\'; cr; show: streaks.] ] \r\t\t\t\tifFalse: [ (streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false] ].\r ]]].\r\rTranscript show: \'h\'; cr; show: streaks ; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak ',			#stamp : 'MagdalenaDhima 2/12/2021 14:51',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T14:52:23.448131-05:00' ],		#prior : OmReference [ '57' ],		#self : OmReference [ '58' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak aceFound |\rstreaks := OrderedCollection new.\rnotFound := true.\raceFound := nice detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [\r\t\t\tTranscript show: previous; cr;cr.\r\t\t\t((streaks size == 4) & (previous asNumber == 5)) ifTrue: [ (aceFound ~= 0) ifTrue: [streaks add: aceFound. Transcript cr ;show: \'here\'; cr; show: streaks.] ] \r\t\t\t\tifFalse: [ (streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false] ].\r ]]].\r\rTranscript show: \'h\'; cr; show: streaks ; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak ',			#stamp : 'MagdalenaDhima 2/12/2021 14:51',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak aceFound |\rstreaks := OrderedCollection new.\rnotFound := true.\raceFound := nice detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [\r\t\t\tTranscript show: previous; show: streaks;cr.\r\t\t\t((streaks size == 4) & (previous asNumber == 5)) ifTrue: [ (aceFound ~= 0) ifTrue: [streaks add: aceFound. Transcript cr ;show: \'here\'; cr; show: streaks.] ] \r\t\t\t\tifFalse: [ (streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false] ].\r ]]].\r\rTranscript show: \'h\'; cr; show: streaks ; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak ',			#stamp : 'MagdalenaDhima 2/12/2021 14:52',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T15:00:08.935131-05:00' ],		#prior : OmReference [ '58' ],		#self : OmReference [ '59' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak aceFound |\rstreaks := OrderedCollection new.\rnotFound := true.\raceFound := nice detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [\r\t\t\tTranscript show: previous; show: streaks;cr.\r\t\t\t((streaks size == 4) & (previous asNumber == 5)) ifTrue: [ (aceFound ~= 0) ifTrue: [streaks add: aceFound. Transcript cr ;show: \'here\'; cr; show: streaks.] ] \r\t\t\t\tifFalse: [ (streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false] ].\r ]]].\r\rTranscript show: \'h\'; cr; show: streaks ; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak ',			#stamp : 'MagdalenaDhima 2/12/2021 14:52',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak aceFound |\rstreaks := OrderedCollection new.\rnotFound := true.\raceFound := nice detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) | ((streaks size == 4) & (previous asNumber == 5))  )\r\t\tifTrue: [((streaks size == 4) & (previous asNumber == 5)) \r\t\t\tifTrue: [ (aceFound ~= 0) ifTrue: [streaks add: aceFound. Transcript cr ;show: \'here\'; cr; show: streaks.] ] \r\t\t\tifFalse: [ (streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]]\r\t\tifFalse: [\r\t\t\tTranscript show: previous; show: streaks;cr.\r\t\t\t(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false].\r ]]].\r\rTranscript show: \'h\'; cr; show: streaks ; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak ',			#stamp : 'MagdalenaDhima 2/12/2021 15:00',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T15:08:10.117131-05:00' ],		#prior : OmReference [ '59' ],		#self : OmReference [ '60' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak aceFound |\rstreaks := OrderedCollection new.\rnotFound := true.\raceFound := nice detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) | ((streaks size == 4) & (previous asNumber == 5))  )\r\t\tifTrue: [((streaks size == 4) & (previous asNumber == 5)) \r\t\t\tifTrue: [ (aceFound ~= 0) ifTrue: [streaks add: aceFound. Transcript cr ;show: \'here\'; cr; show: streaks.] ] \r\t\t\tifFalse: [ (streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]]\r\t\tifFalse: [\r\t\t\tTranscript show: previous; show: streaks;cr.\r\t\t\t(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false].\r ]]].\r\rTranscript show: \'h\'; cr; show: streaks ; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak ',			#stamp : 'MagdalenaDhima 2/12/2021 15:00',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak aceFound |\rstreaks := OrderedCollection new.\rnotFound := true.\raceFound := nice detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) | ((aceFound ~= 0) & (previous asNumber == 2))  )\r\t\tifTrue: [(aceFound ~= 0) & (previous asNumber == 2) \r\t\t\tifTrue: [ (aceFound ~= 0) & (previous asNumber == 2) ifTrue: [streaks add: aceFound. Transcript cr ;show: \'here\'; cr; show: streaks.] ]. \r\t\t\t(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [\r\t\t\tTranscript show: previous; show: streaks;cr.\r\t\t\t(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false].\r ]]].\r\rTranscript show: \'h\'; cr; show: streaks ; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak ',			#stamp : 'MagdalenaDhima 2/12/2021 15:08',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T15:13:32.686131-05:00' ],		#prior : OmReference [ '60' ],		#self : OmReference [ '61' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak aceFound |\rstreaks := OrderedCollection new.\rnotFound := true.\raceFound := nice detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) | ((aceFound ~= 0) & (previous asNumber == 2))  )\r\t\tifTrue: [(aceFound ~= 0) & (previous asNumber == 2) \r\t\t\tifTrue: [ (aceFound ~= 0) & (previous asNumber == 2) ifTrue: [streaks add: aceFound. Transcript cr ;show: \'here\'; cr; show: streaks.] ]. \r\t\t\t(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [\r\t\t\tTranscript show: previous; show: streaks;cr.\r\t\t\t(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false].\r ]]].\r\rTranscript show: \'h\'; cr; show: streaks ; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak ',			#stamp : 'MagdalenaDhima 2/12/2021 15:11',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak aceFound |\rstreaks := OrderedCollection new.\rnotFound := true.\raceFound := nice detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) | ((aceFound ~= 0) & (previous asNumber == 2))  )\r\t\tifTrue: [\r\t\t\t(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card.\r\t\t\t(aceFound ~= 0) & (previous asNumber == 2) \r\t\t\tifTrue: [ (aceFound ~= 0) & (previous asNumber == 2) ifTrue: [streaks add: aceFound. Transcript cr ;show: \'here\'; cr; show: streaks.] ]. ]\r\t\tifFalse: [\r\t\t\tTranscript show: previous; show: streaks;cr.\r\t\t\t(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false].\r ]]].\r\rTranscript show: \'h\'; cr; show: streaks ; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak ',			#stamp : 'MagdalenaDhima 2/12/2021 15:13',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T15:13:36.046131-05:00' ],		#prior : OmReference [ '61' ],		#self : OmReference [ '62' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak aceFound |\rstreaks := OrderedCollection new.\rnotFound := true.\raceFound := nice detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) | ((aceFound ~= 0) & (previous asNumber == 2))  )\r\t\tifTrue: [\r\t\t\t(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card.\r\t\t\t(aceFound ~= 0) & (previous asNumber == 2) \r\t\t\tifTrue: [ (aceFound ~= 0) & (previous asNumber == 2) ifTrue: [streaks add: aceFound. Transcript cr ;show: \'here\'; cr; show: streaks.] ]. ]\r\t\tifFalse: [\r\t\t\tTranscript show: previous; show: streaks;cr.\r\t\t\t(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false].\r ]]].\r\rTranscript show: \'h\'; cr; show: streaks ; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak ',			#stamp : 'MagdalenaDhima 2/12/2021 15:13',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak aceFound |\rstreaks := OrderedCollection new.\rnotFound := true.\raceFound := nice detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) | ((aceFound ~= 0) & (previous asNumber == 2))  )\r\t\tifTrue: [\r\t\t\t(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card.\r\t\t\t(aceFound ~= 0) & (previous asNumber == 2) \r\t\t\tifTrue: [ (aceFound ~= 0) & (previous asNumber == 2) ifTrue: [streaks add: aceFound. Transcript cr ;show: \'here\'; cr; show: streaks.] ] ]\r\t\tifFalse: [\r\t\t\tTranscript show: previous; show: streaks;cr.\r\t\t\t(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false].\r ]]].\r\rTranscript show: \'h\'; cr; show: streaks ; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak ',			#stamp : 'MagdalenaDhima 2/12/2021 15:13',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T15:15:59.665131-05:00' ],		#prior : OmReference [ '62' ],		#self : OmReference [ '63' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak aceFound |\rstreaks := OrderedCollection new.\rnotFound := true.\raceFound := nice detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) | ((aceFound ~= 0) & (previous asNumber == 2))  )\r\t\tifTrue: [\r\t\t\t(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card.\r\t\t\t(aceFound ~= 0) & (previous asNumber == 2) \r\t\t\tifTrue: [ (aceFound ~= 0) & (previous asNumber == 2) ifTrue: [streaks add: aceFound. Transcript cr ;show: \'here\'; cr; show: streaks.] ] ]\r\t\tifFalse: [\r\t\t\tTranscript show: previous; show: streaks;cr.\r\t\t\t(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false].\r ]]].\r\rTranscript show: \'h\'; cr; show: streaks ; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak ',			#stamp : 'MagdalenaDhima 2/12/2021 15:13',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak aceFound |\rstreaks := OrderedCollection new.\rnotFound := true.\raceFound := nice detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) | ((aceFound ~= 0) & (previous asNumber == 2) & (current asNumber == 3)) )\r\t\tifTrue: [\r\t\t\t(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card.\r\t\t\t(aceFound ~= 0) & (previous asNumber == 2) \r\t\t\tifTrue: [ (aceFound ~= 0) & (previous asNumber == 2) & (current asNumber == 3) ifTrue: [streaks add: aceFound. Transcript cr ;show: \'here\'; cr; show: streaks.] ] ]\r\t\tifFalse: [\r\t\t\tTranscript show: previous; show: streaks;cr.\r\t\t\t(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false].\r ]]].\r\rTranscript show: \'h\'; cr; show: streaks ; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak ',			#stamp : 'MagdalenaDhima 2/12/2021 15:15',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T15:17:02.537131-05:00' ],		#prior : OmReference [ '63' ],		#self : OmReference [ '64' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak aceFound |\rstreaks := OrderedCollection new.\rnotFound := true.\raceFound := nice detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) | ((aceFound ~= 0) & (previous asNumber == 2) & (current asNumber == 3)) )\r\t\tifTrue: [\r\t\t\t(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card.\r\t\t\t(aceFound ~= 0) & (previous asNumber == 2) \r\t\t\tifTrue: [ (aceFound ~= 0) & (previous asNumber == 2) & (current asNumber == 3) ifTrue: [streaks add: aceFound. Transcript cr ;show: \'here\'; cr; show: streaks.] ] ]\r\t\tifFalse: [\r\t\t\tTranscript show: previous; show: streaks;cr.\r\t\t\t(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false].\r ]]].\r\rTranscript show: \'h\'; cr; show: streaks ; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak ',			#stamp : 'MagdalenaDhima 2/12/2021 15:15',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak aceFound |\rstreaks := OrderedCollection new.\rnotFound := true.\raceFound := nice detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) | ((aceFound ~= 0) & (previous asNumber == 2) & (current asNumber == 3)) )\r\t\tifTrue: [\r\t\t\t(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card.\r\t\t\t(aceFound ~= 0) & (previous asNumber == 2) & (current asNumber == 3)\r\t\t\tifTrue: [ streaks add: aceFound. Transcript cr ;show: \'here\'; cr; show: streaks.] ]\r\t\tifFalse: [\r\t\t\tTranscript show: previous; show: streaks;cr.\r\t\t\t(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false].\r ]]].\r\rTranscript show: \'h\'; cr; show: streaks ; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak ',			#stamp : 'MagdalenaDhima 2/12/2021 15:17',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T15:20:50.995131-05:00' ],		#prior : OmReference [ '64' ],		#self : OmReference [ '65' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak aceFound |\rstreaks := OrderedCollection new.\rnotFound := true.\raceFound := nice detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) | ((aceFound ~= 0) & (previous asNumber == 2) & (current asNumber == 3)) )\r\t\tifTrue: [\r\t\t\t(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card.\r\t\t\t(aceFound ~= 0) & (previous asNumber == 2) & (current asNumber == 3)\r\t\t\tifTrue: [ streaks add: aceFound. Transcript cr ;show: \'here\'; cr; show: streaks.] ]\r\t\tifFalse: [\r\t\t\tTranscript show: previous; show: streaks;cr.\r\t\t\t(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false].\r ]]].\r\rTranscript show: \'h\'; cr; show: streaks ; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak ',			#stamp : 'MagdalenaDhima 2/12/2021 15:17',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak aceFound |\rstreaks := OrderedCollection new.\rnotFound := true.\raceFound := nice detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) | ((aceFound ~= 0) & (previous asNumber == 2) & (current asNumber == 3)) )\r\t\tifTrue: [\r\t\t\t(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card.\r\t\t\t(aceFound ~= 0) & (previous asNumber == 2) & (current asNumber == 3)\r\t\t\tifTrue: [ streaks addFirst: aceFound. Transcript cr ;show: \'here\'; cr; show: streaks.] ]\r\t\tifFalse: [\r\t\t\tTranscript show: previous; show: streaks;cr.\r\t\t\t(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false].\r ]]].\r\rTranscript show: \'h\'; cr; show: streaks ; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak ',			#stamp : 'MagdalenaDhima 2/12/2021 15:20',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T15:22:24.550131-05:00' ],		#prior : OmReference [ '65' ],		#self : OmReference [ '66' ]	},	#content : EpSessionSnapshot {		#imageName : 'C:\\Users\\Administrator\\Documents\\Pharo\\images\\Pharo 8.0 - 64bit (stable)\\game1.image'	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T15:23:49.517131-05:00' ],		#prior : OmReference [ '66' ],		#self : OmReference [ '67' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 test1 test2 test3 test4 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\t\r\tTranscript cr; cr; show: sorted1 ; cr; cr; show: sorted2; cr.\r\t\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\tTranscript cr; cr; show: straightFlush1 ; cr; cr; show: straightFlush2; cr.\r\t\r\ttemp1 := OrderedCollection new.\r\ttemp2 := OrderedCollection new.\r\ttest1 := 0. \r\ttest2 := 0. \r\ttest3 := 0. \r\ttest4 := 0. \r   temp1 := straightFlush1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttemp2 := straightFlush2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttest1 := straightFlush1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest2 := straightFlush2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\ttest4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\t\r\t\ttest3 >= test4 ifTrue: [ straightFlush := temp1.(test1 ~= 0 ) ifTrue: [ straightFlush add: test1 ]. ] \r\t\t\t\t\t\t\tifFalse: [  straightFlush := temp2. (test2 ~= 0 ) ifTrue: [ straightFlush add: test2 ]. ].\r\r\t"straightFlush := self sizeCheck: 5 firstList: temp1 secondList: temp2."\r\t"Transcript cr; cr; show: straightFlush."\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\t\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\t\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\t\r\t\t]\r\t].\r\t\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\ttemp1 := OrderedCollection new.\r\ttemp2 := OrderedCollection new.\r\ttest1 := 0. \r\ttest2 := 0. \r\ttest3 := 0. \r\ttest4 := 0. \r   temp1 := straight1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttemp2 := straight2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttest1 := straight1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest2 := straight2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\ttest4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\t\r\t\ttest3 >= test4 ifTrue: [ straight := temp1.(test1 ~= 0 ) ifTrue: [ straight add: test1 ]. ] \r\t\t\t\t\t\t\tifFalse: [  straight := temp2. (test2 ~= 0 ) ifTrue: [ straight add: test2 ]. ].\t\r\t\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 14:41',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 test1 test2 test3 test4 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\t\r\t\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\t\r\ttemp1 := OrderedCollection new.\r\ttemp2 := OrderedCollection new.\r\ttest1 := 0. \r\ttest2 := 0. \r\ttest3 := 0. \r\ttest4 := 0. \r   temp1 := straightFlush1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttemp2 := straightFlush2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttest1 := straightFlush1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest2 := straightFlush2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\ttest4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\t\r\t\ttest3 >= test4 ifTrue: [ straightFlush := temp1.(test1 ~= 0 ) ifTrue: [ straightFlush add: test1 ]. ] \r\t\t\t\t\t\t\tifFalse: [  straightFlush := temp2. (test2 ~= 0 ) ifTrue: [ straightFlush add: test2 ]. ].\r\r\t"straightFlush := self sizeCheck: 5 firstList: temp1 secondList: temp2."\r\t"Transcript cr; cr; show: straightFlush."\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\t\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\t\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\t\r\t\t]\r\t].\r\t\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\ttemp1 := OrderedCollection new.\r\ttemp2 := OrderedCollection new.\r\ttest1 := 0. \r\ttest2 := 0. \r\ttest3 := 0. \r\ttest4 := 0. \r   temp1 := straight1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttemp2 := straight2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttest1 := straight1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest2 := straight2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\ttest4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\t\r\t\ttest3 >= test4 ifTrue: [ straight := temp1.(test1 ~= 0 ) ifTrue: [ straight add: test1 ]. ] \r\t\t\t\t\t\t\tifFalse: [  straight := temp2. (test2 ~= 0 ) ifTrue: [ straight add: test2 ]. ].\t\r\t\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 15:23',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T15:24:20.366131-05:00' ],		#prior : OmReference [ '67' ],		#self : OmReference [ '68' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak aceFound |\rstreaks := OrderedCollection new.\rnotFound := true.\raceFound := nice detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) | ((aceFound ~= 0) & (previous asNumber == 2) & (current asNumber == 3)) )\r\t\tifTrue: [\r\t\t\t(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card.\r\t\t\t(aceFound ~= 0) & (previous asNumber == 2) & (current asNumber == 3)\r\t\t\tifTrue: [ streaks addFirst: aceFound. Transcript cr ;show: \'here\'; cr; show: streaks.] ]\r\t\tifFalse: [\r\t\t\tTranscript show: previous; show: streaks;cr.\r\t\t\t(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false].\r ]]].\r\rTranscript show: \'h\'; cr; show: streaks ; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak ',			#stamp : 'MagdalenaDhima 2/12/2021 15:20',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak aceFound |\rstreaks := OrderedCollection new.\rnotFound := true.\raceFound := nice detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) )  | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) | ((aceFound ~= 0) & (previous asNumber == 2) & (current asNumber == 3)) )\r\t\tifTrue: [\r\t\t\t(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card.\r\t\t\t(aceFound ~= 0) & (previous asNumber == 2) & (current asNumber == 3)\r\t\t\tifTrue: [ streaks addFirst: aceFound. ] ]\r\t\tifFalse: [\r\t\t\t\r\t\t\t(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false].\r ]]].\r\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak ',			#stamp : 'MagdalenaDhima 2/12/2021 15:24',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T15:29:10.794131-05:00' ],		#prior : OmReference [ '68' ],		#self : OmReference [ '69' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 test1 test2 test3 test4 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\t\r\t\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\t\r\ttemp1 := OrderedCollection new.\r\ttemp2 := OrderedCollection new.\r\ttest1 := 0. \r\ttest2 := 0. \r\ttest3 := 0. \r\ttest4 := 0. \r   temp1 := straightFlush1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttemp2 := straightFlush2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttest1 := straightFlush1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest2 := straightFlush2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\ttest4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\t\r\t\ttest3 >= test4 ifTrue: [ straightFlush := temp1.(test1 ~= 0 ) ifTrue: [ straightFlush add: test1 ]. ] \r\t\t\t\t\t\t\tifFalse: [  straightFlush := temp2. (test2 ~= 0 ) ifTrue: [ straightFlush add: test2 ]. ].\r\r\t"straightFlush := self sizeCheck: 5 firstList: temp1 secondList: temp2."\r\t"Transcript cr; cr; show: straightFlush."\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\t\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\t\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\t\r\t\t]\r\t].\r\t\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\ttemp1 := OrderedCollection new.\r\ttemp2 := OrderedCollection new.\r\ttest1 := 0. \r\ttest2 := 0. \r\ttest3 := 0. \r\ttest4 := 0. \r   temp1 := straight1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttemp2 := straight2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttest1 := straight1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest2 := straight2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\ttest4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\t\r\t\ttest3 >= test4 ifTrue: [ straight := temp1.(test1 ~= 0 ) ifTrue: [ straight add: test1 ]. ] \r\t\t\t\t\t\t\tifFalse: [  straight := temp2. (test2 ~= 0 ) ifTrue: [ straight add: test2 ]. ].\t\r\t\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 15:23',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 test1 test2 test3 test4 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\t\r\t\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\t\r\ttemp1 := OrderedCollection new.\r\ttemp2 := OrderedCollection new.\r\ttest1 := 0. \r\ttest2 := 0. \r\ttest3 := 0. \r\ttest4 := 0. \r   temp1 := straightFlush1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttemp2 := straightFlush2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttest1 := straightFlush1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest2 := straightFlush2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\ttest4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\t\r\t\ttest3 >= test4 ifTrue: [ straightFlush := temp1.(test1 ~= 0 ) ifTrue: [ straightFlush add: test1 ]. ] \r\t\t\t\t\t\t\tifFalse: [  straightFlush := temp2. (test2 ~= 0 ) ifTrue: [ straightFlush add: test2 ]. ].\r\r\t"straightFlush := self sizeCheck: 5 firstList: temp1 secondList: temp2."\r\t"Transcript cr; cr; show: straightFlush."\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\t\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\tTranscript show: valueStreak2b.\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\t\r\t\t]\r\t].\r\t\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\ttemp1 := OrderedCollection new.\r\ttemp2 := OrderedCollection new.\r\ttest1 := 0. \r\ttest2 := 0. \r\ttest3 := 0. \r\ttest4 := 0. \r   temp1 := straight1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttemp2 := straight2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttest1 := straight1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest2 := straight2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\ttest4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\t\r\t\ttest3 >= test4 ifTrue: [ straight := temp1.(test1 ~= 0 ) ifTrue: [ straight add: test1 ]. ] \r\t\t\t\t\t\t\tifFalse: [  straight := temp2. (test2 ~= 0 ) ifTrue: [ straight add: test2 ]. ].\t\r\t\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 15:29',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T15:29:38.357131-05:00' ],		#prior : OmReference [ '69' ],		#self : OmReference [ '70' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 test1 test2 test3 test4 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\t\r\t\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\t\r\ttemp1 := OrderedCollection new.\r\ttemp2 := OrderedCollection new.\r\ttest1 := 0. \r\ttest2 := 0. \r\ttest3 := 0. \r\ttest4 := 0. \r   temp1 := straightFlush1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttemp2 := straightFlush2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttest1 := straightFlush1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest2 := straightFlush2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\ttest4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\t\r\t\ttest3 >= test4 ifTrue: [ straightFlush := temp1.(test1 ~= 0 ) ifTrue: [ straightFlush add: test1 ]. ] \r\t\t\t\t\t\t\tifFalse: [  straightFlush := temp2. (test2 ~= 0 ) ifTrue: [ straightFlush add: test2 ]. ].\r\r\t"straightFlush := self sizeCheck: 5 firstList: temp1 secondList: temp2."\r\t"Transcript cr; cr; show: straightFlush."\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\t\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\tTranscript show: valueStreak2b.\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\t\r\t\t]\r\t].\r\t\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\ttemp1 := OrderedCollection new.\r\ttemp2 := OrderedCollection new.\r\ttest1 := 0. \r\ttest2 := 0. \r\ttest3 := 0. \r\ttest4 := 0. \r   temp1 := straight1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttemp2 := straight2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttest1 := straight1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest2 := straight2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\ttest4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\t\r\t\ttest3 >= test4 ifTrue: [ straight := temp1.(test1 ~= 0 ) ifTrue: [ straight add: test1 ]. ] \r\t\t\t\t\t\t\tifFalse: [  straight := temp2. (test2 ~= 0 ) ifTrue: [ straight add: test2 ]. ].\t\r\t\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 15:29',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 test1 test2 test3 test4 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\t\r\t\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\t\r\ttemp1 := OrderedCollection new.\r\ttemp2 := OrderedCollection new.\r\ttest1 := 0. \r\ttest2 := 0. \r\ttest3 := 0. \r\ttest4 := 0. \r   temp1 := straightFlush1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttemp2 := straightFlush2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttest1 := straightFlush1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest2 := straightFlush2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\ttest4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\t\r\t\ttest3 >= test4 ifTrue: [ straightFlush := temp1.(test1 ~= 0 ) ifTrue: [ straightFlush add: test1 ]. ] \r\t\t\t\t\t\t\tifFalse: [  straightFlush := temp2. (test2 ~= 0 ) ifTrue: [ straightFlush add: test2 ]. ].\r\r\t"straightFlush := self sizeCheck: 5 firstList: temp1 secondList: temp2."\r\t"Transcript cr; cr; show: straightFlush."\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\t\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\tTranscript show: valueStreak2.\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\t\r\t\t]\r\t].\r\t\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\ttemp1 := OrderedCollection new.\r\ttemp2 := OrderedCollection new.\r\ttest1 := 0. \r\ttest2 := 0. \r\ttest3 := 0. \r\ttest4 := 0. \r   temp1 := straight1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttemp2 := straight2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttest1 := straight1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest2 := straight2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\ttest4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\t\r\t\ttest3 >= test4 ifTrue: [ straight := temp1.(test1 ~= 0 ) ifTrue: [ straight add: test1 ]. ] \r\t\t\t\t\t\t\tifFalse: [  straight := temp2. (test2 ~= 0 ) ifTrue: [ straight add: test2 ]. ].\t\r\t\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 15:29',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T15:29:45.565131-05:00' ],		#prior : OmReference [ '70' ],		#self : OmReference [ '71' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 test1 test2 test3 test4 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\t\r\t\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\t\r\ttemp1 := OrderedCollection new.\r\ttemp2 := OrderedCollection new.\r\ttest1 := 0. \r\ttest2 := 0. \r\ttest3 := 0. \r\ttest4 := 0. \r   temp1 := straightFlush1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttemp2 := straightFlush2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttest1 := straightFlush1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest2 := straightFlush2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\ttest4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\t\r\t\ttest3 >= test4 ifTrue: [ straightFlush := temp1.(test1 ~= 0 ) ifTrue: [ straightFlush add: test1 ]. ] \r\t\t\t\t\t\t\tifFalse: [  straightFlush := temp2. (test2 ~= 0 ) ifTrue: [ straightFlush add: test2 ]. ].\r\r\t"straightFlush := self sizeCheck: 5 firstList: temp1 secondList: temp2."\r\t"Transcript cr; cr; show: straightFlush."\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\t\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\tTranscript show: valueStreak2.\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\t\r\t\t]\r\t].\r\t\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\ttemp1 := OrderedCollection new.\r\ttemp2 := OrderedCollection new.\r\ttest1 := 0. \r\ttest2 := 0. \r\ttest3 := 0. \r\ttest4 := 0. \r   temp1 := straight1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttemp2 := straight2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttest1 := straight1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest2 := straight2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\ttest4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\t\r\t\ttest3 >= test4 ifTrue: [ straight := temp1.(test1 ~= 0 ) ifTrue: [ straight add: test1 ]. ] \r\t\t\t\t\t\t\tifFalse: [  straight := temp2. (test2 ~= 0 ) ifTrue: [ straight add: test2 ]. ].\t\r\t\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 15:29',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 test1 test2 test3 test4 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\t\r\t\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\t\r\ttemp1 := OrderedCollection new.\r\ttemp2 := OrderedCollection new.\r\ttest1 := 0. \r\ttest2 := 0. \r\ttest3 := 0. \r\ttest4 := 0. \r   temp1 := straightFlush1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttemp2 := straightFlush2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttest1 := straightFlush1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest2 := straightFlush2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\ttest4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\t\r\t\ttest3 >= test4 ifTrue: [ straightFlush := temp1.(test1 ~= 0 ) ifTrue: [ straightFlush add: test1 ]. ] \r\t\t\t\t\t\t\tifFalse: [  straightFlush := temp2. (test2 ~= 0 ) ifTrue: [ straightFlush add: test2 ]. ].\r\r\t"straightFlush := self sizeCheck: 5 firstList: temp1 secondList: temp2."\r\t"Transcript cr; cr; show: straightFlush."\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\t\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\tTranscript show: valueStreak1.\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\t\r\t\t]\r\t].\r\t\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\ttemp1 := OrderedCollection new.\r\ttemp2 := OrderedCollection new.\r\ttest1 := 0. \r\ttest2 := 0. \r\ttest3 := 0. \r\ttest4 := 0. \r   temp1 := straight1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttemp2 := straight2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttest1 := straight1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest2 := straight2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\ttest4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\t\r\t\ttest3 >= test4 ifTrue: [ straight := temp1.(test1 ~= 0 ) ifTrue: [ straight add: test1 ]. ] \r\t\t\t\t\t\t\tifFalse: [  straight := temp2. (test2 ~= 0 ) ifTrue: [ straight add: test2 ]. ].\t\r\t\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 15:29',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T15:30:11.893131-05:00' ],		#prior : OmReference [ '71' ],		#self : OmReference [ '72' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 test1 test2 test3 test4 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\t\r\t\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\t\r\ttemp1 := OrderedCollection new.\r\ttemp2 := OrderedCollection new.\r\ttest1 := 0. \r\ttest2 := 0. \r\ttest3 := 0. \r\ttest4 := 0. \r   temp1 := straightFlush1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttemp2 := straightFlush2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttest1 := straightFlush1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest2 := straightFlush2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\ttest4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\t\r\t\ttest3 >= test4 ifTrue: [ straightFlush := temp1.(test1 ~= 0 ) ifTrue: [ straightFlush add: test1 ]. ] \r\t\t\t\t\t\t\tifFalse: [  straightFlush := temp2. (test2 ~= 0 ) ifTrue: [ straightFlush add: test2 ]. ].\r\r\t"straightFlush := self sizeCheck: 5 firstList: temp1 secondList: temp2."\r\t"Transcript cr; cr; show: straightFlush."\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\t\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\tTranscript show: valueStreak1.\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\t\r\t\t]\r\t].\r\t\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\ttemp1 := OrderedCollection new.\r\ttemp2 := OrderedCollection new.\r\ttest1 := 0. \r\ttest2 := 0. \r\ttest3 := 0. \r\ttest4 := 0. \r   temp1 := straight1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttemp2 := straight2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttest1 := straight1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest2 := straight2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\ttest4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\t\r\t\ttest3 >= test4 ifTrue: [ straight := temp1.(test1 ~= 0 ) ifTrue: [ straight add: test1 ]. ] \r\t\t\t\t\t\t\tifFalse: [  straight := temp2. (test2 ~= 0 ) ifTrue: [ straight add: test2 ]. ].\t\r\t\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 15:29',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 test1 test2 test3 test4 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\t\r\t\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\t\r\ttemp1 := OrderedCollection new.\r\ttemp2 := OrderedCollection new.\r\ttest1 := 0. \r\ttest2 := 0. \r\ttest3 := 0. \r\ttest4 := 0. \r   temp1 := straightFlush1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttemp2 := straightFlush2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttest1 := straightFlush1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest2 := straightFlush2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\ttest4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\t\r\t\ttest3 >= test4 ifTrue: [ straightFlush := temp1.(test1 ~= 0 ) ifTrue: [ straightFlush add: test1 ]. ] \r\t\t\t\t\t\t\tifFalse: [  straightFlush := temp2. (test2 ~= 0 ) ifTrue: [ straightFlush add: test2 ]. ].\r\r\t"straightFlush := self sizeCheck: 5 firstList: temp1 secondList: temp2."\r\t"Transcript cr; cr; show: straightFlush."\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\t\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\tTranscript show: valueStreak1;cr.\r\t\t\t\tTranscript show: valueStreak2;cr.\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\t\r\t\t]\r\t].\r\t\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\ttemp1 := OrderedCollection new.\r\ttemp2 := OrderedCollection new.\r\ttest1 := 0. \r\ttest2 := 0. \r\ttest3 := 0. \r\ttest4 := 0. \r   temp1 := straight1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttemp2 := straight2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttest1 := straight1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest2 := straight2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\ttest4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\t\r\t\ttest3 >= test4 ifTrue: [ straight := temp1.(test1 ~= 0 ) ifTrue: [ straight add: test1 ]. ] \r\t\t\t\t\t\t\tifFalse: [  straight := temp2. (test2 ~= 0 ) ifTrue: [ straight add: test2 ]. ].\t\r\t\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 15:30',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T15:30:26.466131-05:00' ],		#prior : OmReference [ '72' ],		#self : OmReference [ '73' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 test1 test2 test3 test4 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\t\r\t\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\t\r\ttemp1 := OrderedCollection new.\r\ttemp2 := OrderedCollection new.\r\ttest1 := 0. \r\ttest2 := 0. \r\ttest3 := 0. \r\ttest4 := 0. \r   temp1 := straightFlush1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttemp2 := straightFlush2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttest1 := straightFlush1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest2 := straightFlush2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\ttest4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\t\r\t\ttest3 >= test4 ifTrue: [ straightFlush := temp1.(test1 ~= 0 ) ifTrue: [ straightFlush add: test1 ]. ] \r\t\t\t\t\t\t\tifFalse: [  straightFlush := temp2. (test2 ~= 0 ) ifTrue: [ straightFlush add: test2 ]. ].\r\r\t"straightFlush := self sizeCheck: 5 firstList: temp1 secondList: temp2."\r\t"Transcript cr; cr; show: straightFlush."\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\t\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\tTranscript show: valueStreak1;cr.\r\t\t\t\tTranscript show: valueStreak2;cr.\r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\t\r\t\t]\r\t].\r\t\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\ttemp1 := OrderedCollection new.\r\ttemp2 := OrderedCollection new.\r\ttest1 := 0. \r\ttest2 := 0. \r\ttest3 := 0. \r\ttest4 := 0. \r   temp1 := straight1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttemp2 := straight2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttest1 := straight1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest2 := straight2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\ttest4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\t\r\t\ttest3 >= test4 ifTrue: [ straight := temp1.(test1 ~= 0 ) ifTrue: [ straight add: test1 ]. ] \r\t\t\t\t\t\t\tifFalse: [  straight := temp2. (test2 ~= 0 ) ifTrue: [ straight add: test2 ]. ].\t\r\t\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 15:30',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 test1 test2 test3 test4 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\t\r\t\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\t\r\ttemp1 := OrderedCollection new.\r\ttemp2 := OrderedCollection new.\r\ttest1 := 0. \r\ttest2 := 0. \r\ttest3 := 0. \r\ttest4 := 0. \r   temp1 := straightFlush1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttemp2 := straightFlush2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttest1 := straightFlush1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest2 := straightFlush2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\ttest4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\t\r\t\ttest3 >= test4 ifTrue: [ straightFlush := temp1.(test1 ~= 0 ) ifTrue: [ straightFlush add: test1 ]. ] \r\t\t\t\t\t\t\tifFalse: [  straightFlush := temp2. (test2 ~= 0 ) ifTrue: [ straightFlush add: test2 ]. ].\r\r\t"straightFlush := self sizeCheck: 5 firstList: temp1 secondList: temp2."\r\t"Transcript cr; cr; show: straightFlush."\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\tTranscript show: valueStreak1;cr.\r\t\t\t\tTranscript show: valueStreak2;cr.\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\t\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\t\r\t\t]\r\t].\r\t\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\ttemp1 := OrderedCollection new.\r\ttemp2 := OrderedCollection new.\r\ttest1 := 0. \r\ttest2 := 0. \r\ttest3 := 0. \r\ttest4 := 0. \r   temp1 := straight1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttemp2 := straight2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttest1 := straight1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest2 := straight2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\ttest4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\t\r\t\ttest3 >= test4 ifTrue: [ straight := temp1.(test1 ~= 0 ) ifTrue: [ straight add: test1 ]. ] \r\t\t\t\t\t\t\tifFalse: [  straight := temp2. (test2 ~= 0 ) ifTrue: [ straight add: test2 ]. ].\t\r\t\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 15:30',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T15:31:37.240131-05:00' ],		#prior : OmReference [ '73' ],		#self : OmReference [ '74' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 test1 test2 test3 test4 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\t\r\t\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\t\r\ttemp1 := OrderedCollection new.\r\ttemp2 := OrderedCollection new.\r\ttest1 := 0. \r\ttest2 := 0. \r\ttest3 := 0. \r\ttest4 := 0. \r   temp1 := straightFlush1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttemp2 := straightFlush2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttest1 := straightFlush1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest2 := straightFlush2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\ttest4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\t\r\t\ttest3 >= test4 ifTrue: [ straightFlush := temp1.(test1 ~= 0 ) ifTrue: [ straightFlush add: test1 ]. ] \r\t\t\t\t\t\t\tifFalse: [  straightFlush := temp2. (test2 ~= 0 ) ifTrue: [ straightFlush add: test2 ]. ].\r\r\t"straightFlush := self sizeCheck: 5 firstList: temp1 secondList: temp2."\r\t"Transcript cr; cr; show: straightFlush."\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\tTranscript show: valueStreak1;cr.\r\t\t\t\tTranscript show: valueStreak2;cr.\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\t\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\t\r\t\t]\r\t].\r\t\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\ttemp1 := OrderedCollection new.\r\ttemp2 := OrderedCollection new.\r\ttest1 := 0. \r\ttest2 := 0. \r\ttest3 := 0. \r\ttest4 := 0. \r   temp1 := straight1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttemp2 := straight2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttest1 := straight1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest2 := straight2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\ttest4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\t\r\t\ttest3 >= test4 ifTrue: [ straight := temp1.(test1 ~= 0 ) ifTrue: [ straight add: test1 ]. ] \r\t\t\t\t\t\t\tifFalse: [  straight := temp2. (test2 ~= 0 ) ifTrue: [ straight add: test2 ]. ].\t\r\t\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 15:30',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 test1 test2 test3 test4 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\t\r\t\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\t\r\ttemp1 := OrderedCollection new.\r\ttemp2 := OrderedCollection new.\r\ttest1 := 0. \r\ttest2 := 0. \r\ttest3 := 0. \r\ttest4 := 0. \r   temp1 := straightFlush1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttemp2 := straightFlush2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttest1 := straightFlush1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest2 := straightFlush2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\ttest4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\t\r\t\ttest3 >= test4 ifTrue: [ straightFlush := temp1.(test1 ~= 0 ) ifTrue: [ straightFlush add: test1 ]. ] \r\t\t\t\t\t\t\tifFalse: [  straightFlush := temp2. (test2 ~= 0 ) ifTrue: [ straightFlush add: test2 ]. ].\r\r\t"straightFlush := self sizeCheck: 5 firstList: temp1 secondList: temp2."\r\t"Transcript cr; cr; show: straightFlush."\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\tTranscript show: valueStreak2b;cr.\r\t\t\t\tTranscript show: valueStreak2;cr.\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\t\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\t\r\t\t]\r\t].\r\t\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\ttemp1 := OrderedCollection new.\r\ttemp2 := OrderedCollection new.\r\ttest1 := 0. \r\ttest2 := 0. \r\ttest3 := 0. \r\ttest4 := 0. \r   temp1 := straight1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttemp2 := straight2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttest1 := straight1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest2 := straight2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\ttest4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\t\r\t\ttest3 >= test4 ifTrue: [ straight := temp1.(test1 ~= 0 ) ifTrue: [ straight add: test1 ]. ] \r\t\t\t\t\t\t\tifFalse: [  straight := temp2. (test2 ~= 0 ) ifTrue: [ straight add: test2 ]. ].\t\r\t\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 15:31',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T15:31:57.762131-05:00' ],		#prior : OmReference [ '74' ],		#self : OmReference [ '75' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 test1 test2 test3 test4 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\t\r\t\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\t\r\ttemp1 := OrderedCollection new.\r\ttemp2 := OrderedCollection new.\r\ttest1 := 0. \r\ttest2 := 0. \r\ttest3 := 0. \r\ttest4 := 0. \r   temp1 := straightFlush1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttemp2 := straightFlush2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttest1 := straightFlush1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest2 := straightFlush2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\ttest4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\t\r\t\ttest3 >= test4 ifTrue: [ straightFlush := temp1.(test1 ~= 0 ) ifTrue: [ straightFlush add: test1 ]. ] \r\t\t\t\t\t\t\tifFalse: [  straightFlush := temp2. (test2 ~= 0 ) ifTrue: [ straightFlush add: test2 ]. ].\r\r\t"straightFlush := self sizeCheck: 5 firstList: temp1 secondList: temp2."\r\t"Transcript cr; cr; show: straightFlush."\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\tTranscript show: valueStreak2b;cr.\r\t\t\t\tTranscript show: valueStreak2;cr.\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\t\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\t\r\t\t]\r\t].\r\t\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\ttemp1 := OrderedCollection new.\r\ttemp2 := OrderedCollection new.\r\ttest1 := 0. \r\ttest2 := 0. \r\ttest3 := 0. \r\ttest4 := 0. \r   temp1 := straight1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttemp2 := straight2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttest1 := straight1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest2 := straight2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\ttest4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\t\r\t\ttest3 >= test4 ifTrue: [ straight := temp1.(test1 ~= 0 ) ifTrue: [ straight add: test1 ]. ] \r\t\t\t\t\t\t\tifFalse: [  straight := temp2. (test2 ~= 0 ) ifTrue: [ straight add: test2 ]. ].\t\r\t\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 15:31',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 test1 test2 test3 test4 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\t\r\t\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\t\r\ttemp1 := OrderedCollection new.\r\ttemp2 := OrderedCollection new.\r\ttest1 := 0. \r\ttest2 := 0. \r\ttest3 := 0. \r\ttest4 := 0. \r   temp1 := straightFlush1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttemp2 := straightFlush2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttest1 := straightFlush1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest2 := straightFlush2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\ttest4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\t\r\t\ttest3 >= test4 ifTrue: [ straightFlush := temp1.(test1 ~= 0 ) ifTrue: [ straightFlush add: test1 ]. ] \r\t\t\t\t\t\t\tifFalse: [  straightFlush := temp2. (test2 ~= 0 ) ifTrue: [ straightFlush add: test2 ]. ].\r\r\t"straightFlush := self sizeCheck: 5 firstList: temp1 secondList: temp2."\r\t"Transcript cr; cr; show: straightFlush."\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\tTranscript show: temp2;cr.\r\t\t\t\tTranscript show: valueStreak2;cr.\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\t\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\t\r\t\t]\r\t].\r\t\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\ttemp1 := OrderedCollection new.\r\ttemp2 := OrderedCollection new.\r\ttest1 := 0. \r\ttest2 := 0. \r\ttest3 := 0. \r\ttest4 := 0. \r   temp1 := straight1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttemp2 := straight2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttest1 := straight1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest2 := straight2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\ttest4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\t\r\t\ttest3 >= test4 ifTrue: [ straight := temp1.(test1 ~= 0 ) ifTrue: [ straight add: test1 ]. ] \r\t\t\t\t\t\t\tifFalse: [  straight := temp2. (test2 ~= 0 ) ifTrue: [ straight add: test2 ]. ].\t\r\t\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 15:31',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T15:32:20.525131-05:00' ],		#prior : OmReference [ '75' ],		#self : OmReference [ '76' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 test1 test2 test3 test4 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\t\r\t\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\t\r\ttemp1 := OrderedCollection new.\r\ttemp2 := OrderedCollection new.\r\ttest1 := 0. \r\ttest2 := 0. \r\ttest3 := 0. \r\ttest4 := 0. \r   temp1 := straightFlush1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttemp2 := straightFlush2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttest1 := straightFlush1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest2 := straightFlush2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\ttest4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\t\r\t\ttest3 >= test4 ifTrue: [ straightFlush := temp1.(test1 ~= 0 ) ifTrue: [ straightFlush add: test1 ]. ] \r\t\t\t\t\t\t\tifFalse: [  straightFlush := temp2. (test2 ~= 0 ) ifTrue: [ straightFlush add: test2 ]. ].\r\r\t"straightFlush := self sizeCheck: 5 firstList: temp1 secondList: temp2."\r\t"Transcript cr; cr; show: straightFlush."\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\tTranscript show: temp2;cr.\r\t\t\t\tTranscript show: valueStreak2;cr.\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1))  ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\t\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\t\r\t\t]\r\t].\r\t\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\ttemp1 := OrderedCollection new.\r\ttemp2 := OrderedCollection new.\r\ttest1 := 0. \r\ttest2 := 0. \r\ttest3 := 0. \r\ttest4 := 0. \r   temp1 := straight1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttemp2 := straight2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttest1 := straight1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest2 := straight2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\ttest4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\t\r\t\ttest3 >= test4 ifTrue: [ straight := temp1.(test1 ~= 0 ) ifTrue: [ straight add: test1 ]. ] \r\t\t\t\t\t\t\tifFalse: [  straight := temp2. (test2 ~= 0 ) ifTrue: [ straight add: test2 ]. ].\t\r\t\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 15:31',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 test1 test2 test3 test4 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\t\r\t\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\t\r\ttemp1 := OrderedCollection new.\r\ttemp2 := OrderedCollection new.\r\ttest1 := 0. \r\ttest2 := 0. \r\ttest3 := 0. \r\ttest4 := 0. \r   temp1 := straightFlush1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttemp2 := straightFlush2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttest1 := straightFlush1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest2 := straightFlush2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\ttest4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\t\r\t\ttest3 >= test4 ifTrue: [ straightFlush := temp1.(test1 ~= 0 ) ifTrue: [ straightFlush add: test1 ]. ] \r\t\t\t\t\t\t\tifFalse: [  straightFlush := temp2. (test2 ~= 0 ) ifTrue: [ straightFlush add: test2 ]. ].\r\r\t"straightFlush := self sizeCheck: 5 firstList: temp1 secondList: temp2."\r\t"Transcript cr; cr; show: straightFlush."\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\tTranscript show: temp2;cr.\r\t\t\t\tTranscript show: valueStreak2;cr.\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1)) | (valueStreak1 size ~= 3) ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\t\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\t\r\t\t]\r\t].\r\t\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\ttemp1 := OrderedCollection new.\r\ttemp2 := OrderedCollection new.\r\ttest1 := 0. \r\ttest2 := 0. \r\ttest3 := 0. \r\ttest4 := 0. \r   temp1 := straight1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttemp2 := straight2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttest1 := straight1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest2 := straight2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\ttest4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\t\r\t\ttest3 >= test4 ifTrue: [ straight := temp1.(test1 ~= 0 ) ifTrue: [ straight add: test1 ]. ] \r\t\t\t\t\t\t\tifFalse: [  straight := temp2. (test2 ~= 0 ) ifTrue: [ straight add: test2 ]. ].\t\r\t\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 15:32',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T15:32:37.666131-05:00' ],		#prior : OmReference [ '76' ],		#self : OmReference [ '77' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 test1 test2 test3 test4 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\t\r\t\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\t\r\ttemp1 := OrderedCollection new.\r\ttemp2 := OrderedCollection new.\r\ttest1 := 0. \r\ttest2 := 0. \r\ttest3 := 0. \r\ttest4 := 0. \r   temp1 := straightFlush1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttemp2 := straightFlush2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttest1 := straightFlush1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest2 := straightFlush2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\ttest4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\t\r\t\ttest3 >= test4 ifTrue: [ straightFlush := temp1.(test1 ~= 0 ) ifTrue: [ straightFlush add: test1 ]. ] \r\t\t\t\t\t\t\tifFalse: [  straightFlush := temp2. (test2 ~= 0 ) ifTrue: [ straightFlush add: test2 ]. ].\r\r\t"straightFlush := self sizeCheck: 5 firstList: temp1 secondList: temp2."\r\t"Transcript cr; cr; show: straightFlush."\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\tTranscript show: temp2;cr.\r\t\t\t\tTranscript show: valueStreak2;cr.\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1)) | (valueStreak1 size ~= 3) ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\t\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\t\r\t\t]\r\t].\r\t\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\ttemp1 := OrderedCollection new.\r\ttemp2 := OrderedCollection new.\r\ttest1 := 0. \r\ttest2 := 0. \r\ttest3 := 0. \r\ttest4 := 0. \r   temp1 := straight1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttemp2 := straight2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttest1 := straight1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest2 := straight2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\ttest4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\t\r\t\ttest3 >= test4 ifTrue: [ straight := temp1.(test1 ~= 0 ) ifTrue: [ straight add: test1 ]. ] \r\t\t\t\t\t\t\tifFalse: [  straight := temp2. (test2 ~= 0 ) ifTrue: [ straight add: test2 ]. ].\t\r\t\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 15:32',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 test1 test2 test3 test4 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\t\r\t\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\r\t\r\ttemp1 := OrderedCollection new.\r\ttemp2 := OrderedCollection new.\r\ttest1 := 0. \r\ttest2 := 0. \r\ttest3 := 0. \r\ttest4 := 0. \r   temp1 := straightFlush1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttemp2 := straightFlush2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttest1 := straightFlush1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest2 := straightFlush2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\ttest4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\t\r\t\ttest3 >= test4 ifTrue: [ straightFlush := temp1.(test1 ~= 0 ) ifTrue: [ straightFlush add: test1 ]. ] \r\t\t\t\t\t\t\tifFalse: [  straightFlush := temp2. (test2 ~= 0 ) ifTrue: [ straightFlush add: test2 ]. ].\r\r\t"straightFlush := self sizeCheck: 5 firstList: temp1 secondList: temp2."\r\t"Transcript cr; cr; show: straightFlush."\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t"\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) | (valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\ttemp1  := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\ttemp2  := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\t(valueStreak1 notEmpty & valueStreak2 notEmpty) & ((valueStreak1 at: 1) = (valueStreak2 at: 1) )\r\t\tifTrue: [ \r\t\t\t((valueStreak1 at: 1) = (temp1 at: 1)) & ((valueStreak2 at: 1) = (temp1 at: 1)) \r\t\t\tifTrue: [\r\t\t\t(valueStreak1 size == 3) & (valueStreak1b size == 2) ifTrue: [ ((valueStreak1b at: 1) = (temp2 at: 1)) | (valueStreak2 size ~= 3) ifTrue: [ \r\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b]]. \r\t\t\t(valueStreak2 size == 3) & (valueStreak2b size == 2) ifTrue: [ ((valueStreak2b at: 1) = (temp2 at: 1)) | (valueStreak1 size ~= 3) ifTrue: [ \r\t\t\t   valueStreak := valueStreak2 , valueStreak2b]]. \r\t\t\t\t\r\t\t\t]] \r\t\tifFalse: [ \r\t\t\t\t(valueStreak1 size == 3) & ((valueStreak1 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak1 , valueStreak1b].\r\t\t\t\t(valueStreak2 size == 3) & ((valueStreak2 at: 1) = (temp1 at: 1))  ifTrue: [  \r\t\t\t\t\tvalueStreak := valueStreak2 , valueStreak2b].\r\t\t\t\t\r\t\t]\r\t].\r\t\r\t"valueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB."\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\ttemp1 := OrderedCollection new.\r\ttemp2 := OrderedCollection new.\r\ttest1 := 0. \r\ttest2 := 0. \r\ttest3 := 0. \r\ttest4 := 0. \r   temp1 := straight1 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttemp2 := straight2 select: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber ~= 1].\r\ttest1 := straight1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest2 := straight2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\ttest3 := temp1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\ttest4 := temp2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ].\r\t\r\t\ttest3 >= test4 ifTrue: [ straight := temp1.(test1 ~= 0 ) ifTrue: [ straight add: test1 ]. ] \r\t\t\t\t\t\t\tifFalse: [  straight := temp2. (test2 ~= 0 ) ifTrue: [ straight add: test2 ]. ].\t\r\t\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted.   ',			#stamp : 'MagdalenaDhima 2/12/2021 15:32',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T15:33:44.378131-05:00' ],		#prior : OmReference [ '77' ],		#self : OmReference [ '78' ]	},	#content : EpSessionSnapshot {		#imageName : 'C:\\Users\\Administrator\\Documents\\Pharo\\images\\Pharo 8.0 - 64bit (stable)\\game1.image'	}}