OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T20:57:23.972875-05:00' ],		#prior : OmReference [ 'Pharo8.0-SNAPSHOT-32bit-0932da8.a2t0l2cwg82d01lg5tfkj9zcb', '103' ],		#self : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b.\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 8; cr. ^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 17:24',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b.\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 8; cr. ^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t\r\tace1 := sorted1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) == 1] ifNone: [0].\r\tace2 := sorted2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ sorted1 := sorted1 inject: 0 into: [:a :c | ( (a copyFrom: 1 to: (a size-1) ) > ( c copyFrom: 1 to: (a size-1) ) ) \r\t\tifTrue: [a] ifFalse: [c]]. \r\t  sorted2 := sorted2 inject: 0 into: [:a :c | ( (a copyFrom: 1 to: (a size-1) ) > ( c copyFrom: 1 to: (a size-1) ) ) \r\t\tifTrue: [a] ifFalse: [c]]. \r\t  sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2. ] \r\tifFalse: [ sorted := self sizeCheck: 1 firstList: ace1 secondList: ace2. ].\r\t\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 2/11/2021 20:57',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T20:58:23.223875-05:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b.\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 8; cr. ^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t\r\tace1 := sorted1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) == 1] ifNone: [0].\r\tace2 := sorted2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ sorted1 := sorted1 inject: 0 into: [:a :c | ( (a copyFrom: 1 to: (a size-1) ) > ( c copyFrom: 1 to: (a size-1) ) ) \r\t\tifTrue: [a] ifFalse: [c]]. \r\t  sorted2 := sorted2 inject: 0 into: [:a :c | ( (a copyFrom: 1 to: (a size-1) ) > ( c copyFrom: 1 to: (a size-1) ) ) \r\t\tifTrue: [a] ifFalse: [c]]. \r\t  sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2. ] \r\tifFalse: [ sorted := self sizeCheck: 1 firstList: ace1 secondList: ace2. ].\r\t\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 2/11/2021 20:57',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b.\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 8; cr. ^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t\r\tace1 := sorted1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) == 1] ifNone: [0].\r\tace2 := sorted2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ sorted1 := sorted1 inject: 0 into: [:a :c | ( (a copyFrom: 1 to: (a size-1) ) asNumber > ( c copyFrom: 1 to: (a size-1) ) asNumber ) \r\t\tifTrue: [a] ifFalse: [c]]. \r\t  sorted2 := sorted2 inject: 0 into: [:a :c | ( (a copyFrom: 1 to: (a size-1) ) asNumber > ( c copyFrom: 1 to: (a size-1) ) asNumber ) \r\t\tifTrue: [a] ifFalse: [c]]. \r\t  sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2. ] \r\tifFalse: [ sorted := self sizeCheck: 1 firstList: ace1 secondList: ace2. ].\r\t\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 2/11/2021 20:58',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T20:58:31.780875-05:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b.\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 8; cr. ^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t\r\tace1 := sorted1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) == 1] ifNone: [0].\r\tace2 := sorted2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ sorted1 := sorted1 inject: 0 into: [:a :c | ( (a copyFrom: 1 to: (a size-1) ) asNumber > ( c copyFrom: 1 to: (a size-1) ) asNumber ) \r\t\tifTrue: [a] ifFalse: [c]]. \r\t  sorted2 := sorted2 inject: 0 into: [:a :c | ( (a copyFrom: 1 to: (a size-1) ) asNumber > ( c copyFrom: 1 to: (a size-1) ) asNumber ) \r\t\tifTrue: [a] ifFalse: [c]]. \r\t  sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2. ] \r\tifFalse: [ sorted := self sizeCheck: 1 firstList: ace1 secondList: ace2. ].\r\t\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 2/11/2021 20:58',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b.\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 8; cr. ^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t\r\tace1 := sorted1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := sorted2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ sorted1 := sorted1 inject: 0 into: [:a :c | ( (a copyFrom: 1 to: (a size-1) ) asNumber > ( c copyFrom: 1 to: (a size-1) ) asNumber ) \r\t\tifTrue: [a] ifFalse: [c]]. \r\t  sorted2 := sorted2 inject: 0 into: [:a :c | ( (a copyFrom: 1 to: (a size-1) ) asNumber > ( c copyFrom: 1 to: (a size-1) ) asNumber ) \r\t\tifTrue: [a] ifFalse: [c]]. \r\t  sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2. ] \r\tifFalse: [ sorted := self sizeCheck: 1 firstList: ace1 secondList: ace2. ].\r\t\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 2/11/2021 20:58',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T21:00:03.600875-05:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b.\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 8; cr. ^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t\r\tace1 := sorted1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := sorted2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ sorted1 := sorted1 inject: 0 into: [:a :c | ( (a copyFrom: 1 to: (a size-1) ) asNumber > ( c copyFrom: 1 to: (a size-1) ) asNumber ) \r\t\tifTrue: [a] ifFalse: [c]]. \r\t  sorted2 := sorted2 inject: 0 into: [:a :c | ( (a copyFrom: 1 to: (a size-1) ) asNumber > ( c copyFrom: 1 to: (a size-1) ) asNumber ) \r\t\tifTrue: [a] ifFalse: [c]]. \r\t  sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2. ] \r\tifFalse: [ sorted := self sizeCheck: 1 firstList: ace1 secondList: ace2. ].\r\t\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 2/11/2021 20:58',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b.\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 8; cr. ^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\tTranscript show:  sorted; cr.\r\tace1 := sorted1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := sorted2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ sorted1 := sorted1 inject: 0 into: [:a :c | ( (a copyFrom: 1 to: (a size-1) ) asNumber > ( c copyFrom: 1 to: (a size-1) ) asNumber ) \r\t\tifTrue: [a] ifFalse: [c]]. \r\t  sorted2 := sorted2 inject: 0 into: [:a :c | ( (a copyFrom: 1 to: (a size-1) ) asNumber > ( c copyFrom: 1 to: (a size-1) ) asNumber ) \r\t\tifTrue: [a] ifFalse: [c]]. \r\t  sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2. ] \r\tifFalse: [ sorted := self sizeCheck: 1 firstList: ace1 secondList: ace2. ].\r\t\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 2/11/2021 21:00',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T21:01:28.437875-05:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b.\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 8; cr. ^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\tTranscript show:  sorted; cr.\r\tace1 := sorted1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := sorted2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ sorted1 := sorted1 inject: 0 into: [:a :c | ( (a copyFrom: 1 to: (a size-1) ) asNumber > ( c copyFrom: 1 to: (a size-1) ) asNumber ) \r\t\tifTrue: [a] ifFalse: [c]]. \r\t  sorted2 := sorted2 inject: 0 into: [:a :c | ( (a copyFrom: 1 to: (a size-1) ) asNumber > ( c copyFrom: 1 to: (a size-1) ) asNumber ) \r\t\tifTrue: [a] ifFalse: [c]]. \r\t  sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2. ] \r\tifFalse: [ sorted := self sizeCheck: 1 firstList: ace1 secondList: ace2. ].\r\t\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 2/11/2021 21:00',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b.\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 8; cr. ^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\tTranscript show:  sorted; cr.\r\tTranscript show:  \'h\'; cr.\r\tace1 := sorted1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := sorted2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ sorted1 := sorted1 inject: 0 into: [:a :c | ( (a copyFrom: 1 to: (a size-1) ) asNumber > ( c copyFrom: 1 to: (a size-1) ) asNumber ) \r\t\tifTrue: [a] ifFalse: [c]]. \r\t  sorted2 := sorted2 inject: 0 into: [:a :c | ( (a copyFrom: 1 to: (a size-1) ) asNumber > ( c copyFrom: 1 to: (a size-1) ) asNumber ) \r\t\tifTrue: [a] ifFalse: [c]]. \r\t  sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2. ] \r\tifFalse: [ sorted := self sizeCheck: 1 firstList: ace1 secondList: ace2. ].\r\t\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 2/11/2021 21:01',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T21:03:35.214875-05:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b.\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 8; cr. ^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\tTranscript show:  sorted; cr.\r\tTranscript show:  \'h\'; cr.\r\tace1 := sorted1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := sorted2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ sorted1 := sorted1 inject: 0 into: [:a :c | ( (a copyFrom: 1 to: (a size-1) ) asNumber > ( c copyFrom: 1 to: (a size-1) ) asNumber ) \r\t\tifTrue: [a] ifFalse: [c]]. \r\t  sorted2 := sorted2 inject: 0 into: [:a :c | ( (a copyFrom: 1 to: (a size-1) ) asNumber > ( c copyFrom: 1 to: (a size-1) ) asNumber ) \r\t\tifTrue: [a] ifFalse: [c]]. \r\t  sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2. ] \r\tifFalse: [ sorted := self sizeCheck: 1 firstList: ace1 secondList: ace2. ].\r\t\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 2/11/2021 21:01',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b.\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 8; cr. ^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\tTranscript show:  sorted; cr.\r\tTranscript show:  \'h\'; cr.\r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ sorted1 := hand1 inject: 0 into: [:a :c | ( (a copyFrom: 1 to: (a size-1) ) asNumber > ( c copyFrom: 1 to: (a size-1) ) asNumber ) \r\t\tifTrue: [a] ifFalse: [c]]. \r\t  sorted2 := hand2 inject: 0 into: [:a :c | ( (a copyFrom: 1 to: (a size-1) ) asNumber > ( c copyFrom: 1 to: (a size-1) ) asNumber ) \r\t\tifTrue: [a] ifFalse: [c]]. \r\t  sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2. ] \r\tifFalse: [ sorted := self sizeCheck: 1 firstList: ace1 secondList: ace2. ].\r\t\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 2/11/2021 21:03',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T21:04:59.895875-05:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b.\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 8; cr. ^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\tTranscript show:  sorted; cr.\r\tTranscript show:  \'h\'; cr.\r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ sorted1 := hand1 inject: 0 into: [:a :c | ( (a copyFrom: 1 to: (a size-1) ) asNumber > ( c copyFrom: 1 to: (a size-1) ) asNumber ) \r\t\tifTrue: [a] ifFalse: [c]]. \r\t  sorted2 := hand2 inject: 0 into: [:a :c | ( (a copyFrom: 1 to: (a size-1) ) asNumber > ( c copyFrom: 1 to: (a size-1) ) asNumber ) \r\t\tifTrue: [a] ifFalse: [c]]. \r\t  sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2. ] \r\tifFalse: [ sorted := self sizeCheck: 1 firstList: ace1 secondList: ace2. ].\r\t\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 2/11/2021 21:03',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b.\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 8; cr. ^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\tTranscript show:  sorted; cr.\r\tTranscript show:  \'h\'; cr.\r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ sorted1 := hand1 inject: 0 into: [:a :c | ( (a copyFrom: 1 to: (a size-1) ) asNumber > ( c copyFrom: 1 to: (a size-1) ) asNumber ) \r\t\tifTrue: [a asNumber] ifFalse: [c asNumber]]. \r\t  sorted2 := hand2 inject: 0 into: [:a :c | ( (a copyFrom: 1 to: (a size-1) ) asNumber > ( c copyFrom: 1 to: (a size-1) ) asNumber ) \r\t\tifTrue: [a asNumber] ifFalse: [c asNumber]]. \r\t  sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2. ] \r\tifFalse: [ sorted := self sizeCheck: 1 firstList: ace1 secondList: ace2. ].\r\t\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 2/11/2021 21:04',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T21:06:35.156875-05:00' ],		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b.\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 8; cr. ^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\tTranscript show:  sorted; cr.\r\tTranscript show:  \'h\'; cr.\r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ sorted1 := hand1 inject: 0 into: [:a :c | ( (a copyFrom: 1 to: (a size-1) ) asNumber > ( c copyFrom: 1 to: (a size-1) ) asNumber ) \r\t\tifTrue: [a asNumber] ifFalse: [c asNumber]]. \r\t  sorted2 := hand2 inject: 0 into: [:a :c | ( (a copyFrom: 1 to: (a size-1) ) asNumber > ( c copyFrom: 1 to: (a size-1) ) asNumber ) \r\t\tifTrue: [a asNumber] ifFalse: [c asNumber]]. \r\t  sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2. ] \r\tifFalse: [ sorted := self sizeCheck: 1 firstList: ace1 secondList: ace2. ].\r\t\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 2/11/2021 21:04',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b.\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 8; cr. ^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\tTranscript show:  sorted; cr.\r\tTranscript show:  \'h\'; cr.\r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ sorted1 := hand1 inject: 0 into: [:a :c |  ( a > ( c copyFrom: 1 to: (a size-1) ) asNumber ) \r\t\tifTrue: [a ] ifFalse: [c asNumber]]. \r\t  sorted2 := hand2 inject: 0 into: [:a :c |  ( a > ( c copyFrom: 1 to: (a size-1) ) asNumber ) \r\t\tifTrue: [a ] ifFalse: [c asNumber]]. \r\t  sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2. ] \r\tifFalse: [ sorted := self sizeCheck: 1 firstList: ace1 secondList: ace2. ].\r\t\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 2/11/2021 21:06',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T21:09:31.993875-05:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b.\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 8; cr. ^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\tTranscript show:  sorted; cr.\r\tTranscript show:  \'h\'; cr.\r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ sorted1 := hand1 inject: 0 into: [:a :c |  ( a > ( c copyFrom: 1 to: (a size-1) ) asNumber ) \r\t\tifTrue: [a ] ifFalse: [c asNumber]]. \r\t  sorted2 := hand2 inject: 0 into: [:a :c |  ( a > ( c copyFrom: 1 to: (a size-1) ) asNumber ) \r\t\tifTrue: [a ] ifFalse: [c asNumber]]. \r\t  sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2. ] \r\tifFalse: [ sorted := self sizeCheck: 1 firstList: ace1 secondList: ace2. ].\r\t\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 2/11/2021 21:06',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b.\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 8; cr. ^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\tTranscript show:  sorted; cr.\r\tTranscript show:  \'h\'; cr.\r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ sorted1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] . \r\t  sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2. ] \r\tifFalse: [ sorted := self sizeCheck: 1 firstList: ace1 secondList: ace2. ].\r\t\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 2/11/2021 21:09',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T21:15:02.107875-05:00' ],		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b.\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 8; cr. ^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\tTranscript show:  sorted; cr.\r\tTranscript show:  \'h\'; cr.\r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ sorted1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] . \r\t  sorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2. ] \r\tifFalse: [ sorted := self sizeCheck: 1 firstList: ace1 secondList: ace2. ].\r\t\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 2/11/2021 21:09',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b.\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 8; cr. ^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\tTranscript show:  sorted; cr.\r\tTranscript show:  \'h\'; cr.\r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ sorted1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] . \r\t  sorted := sorted1 > sorted2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: (hand1 at: ace1)] ifFalse: [sorted add: (hand1 at: ace2)] ].\r\t\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 2/11/2021 21:15',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T21:21:24.085875-05:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b.\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 8; cr. ^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\tTranscript show:  sorted; cr.\r\tTranscript show:  \'h\'; cr.\r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ sorted1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] . \r\t  sorted := sorted1 > sorted2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: (hand1 at: ace1)] ifFalse: [sorted add: (hand1 at: ace2)] ].\r\t\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 2/11/2021 21:15',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b.\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 8; cr. ^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\tTranscript show:  sorted; cr.\r\tTranscript show:  \'h\'; cr.\r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ Transcript show:  ace1; show:  ace2;cr.\r\t  sorted1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] . \r\t  sorted := sorted1 > sorted2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: (hand1 at: ace1)] ifFalse: [sorted add: (hand1 at: ace2)] ].\r\t\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 2/11/2021 21:21',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T21:21:47.855875-05:00' ],		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b.\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 8; cr. ^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\tTranscript show:  sorted; cr.\r\tTranscript show:  \'h\'; cr.\r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ Transcript show:  ace1; show:  ace2;cr.\r\t  sorted1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] . \r\t  sorted := sorted1 > sorted2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: (hand1 at: ace1)] ifFalse: [sorted add: (hand1 at: ace2)] ].\r\t\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 2/11/2021 21:21',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b.\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 8; cr. ^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\tTranscript show:  sorted; cr.\r\tTranscript show:  \'h\'; cr.\r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  sorted1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] . \r\t  sorted := sorted1 > sorted2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ] \r\tifFalse: [ Transcript show:  ace1; show:  ace2;cr. (ace1 ~= 0) ifTrue: [sorted add: (hand1 at: ace1)] ifFalse: [sorted add: (hand1 at: ace2)] ].\r\t\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 2/11/2021 21:21',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T21:23:49.984875-05:00' ],		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b.\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 8; cr. ^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\tTranscript show:  sorted; cr.\r\tTranscript show:  \'h\'; cr.\r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  sorted1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] . \r\t  sorted := sorted1 > sorted2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ] \r\tifFalse: [ Transcript show:  ace1; show:  ace2;cr. (ace1 ~= 0) ifTrue: [sorted add: (hand1 at: ace1)] ifFalse: [sorted add: (hand1 at: ace2)] ].\r\t\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 2/11/2021 21:21',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b.\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 8; cr. ^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\tTranscript show:  sorted; cr.\r\tTranscript show:  \'h\'; cr.\r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  sorted1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] . \r\t  sorted := sorted1 > sorted2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ] \r\tifFalse: [ sorted := OrderedCollection new. (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 2/11/2021 21:23',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T21:27:46.554875-05:00' ],		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b.\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 8; cr. ^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\tTranscript show:  sorted; cr.\r\tTranscript show:  \'h\'; cr.\r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  sorted1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] . \r\t  sorted := sorted1 > sorted2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ] \r\tifFalse: [ sorted := OrderedCollection new. (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 2/11/2021 21:23',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b.\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 8; cr. ^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\tTranscript show:  sorted; cr.\r\tTranscript show:  \'h\'; cr.\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  sorted1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] . \r\t  Transcript show: sorted1; show: sorted2; cr.\r\t  sorted := sorted1 > sorted2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 2/11/2021 21:27',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T21:34:06.134875-05:00' ],		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b.\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 8; cr. ^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\tTranscript show:  sorted; cr.\r\tTranscript show:  \'h\'; cr.\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  sorted1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] . \r\t  Transcript show: sorted1; show: sorted2; cr.\r\t  sorted := sorted1 > sorted2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 2/11/2021 21:27',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b.\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 8; cr. ^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\tTranscript show:  sorted; cr.\r\tTranscript show:  \'h\'; cr.\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  Transcript show: ace1; show: ace2; cr.\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 2/11/2021 21:34',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T21:34:30.831875-05:00' ],		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b.\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 8; cr. ^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\tTranscript show:  sorted; cr.\r\tTranscript show:  \'h\'; cr.\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  Transcript show: ace1; show: ace2; cr.\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 2/11/2021 21:34',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b.\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 8; cr. ^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\tTranscript show:  sorted; cr.\r\tTranscript show:  \'h\'; cr.\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 2/11/2021 21:34',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T21:36:52.111875-05:00' ],		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b.\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 8; cr. ^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\tTranscript show:  sorted; cr.\r\tTranscript show:  \'h\'; cr.\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 2/11/2021 21:34',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b.\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 8; cr. ^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tTranscript show:  sorted; cr.\r\tTranscript show:  \'h\'; cr.\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 2/11/2021 21:36',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T21:41:52.586875-05:00' ],		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) ) | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r] ]].\r\rTranscript show: \'here\';cr.\rTranscript show: streaks; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r\r^highestStreak',			#stamp : 'MagdalenaDhima 1/31/2021 15:27',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) ) | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r] ]].\r\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r\r^highestStreak',			#stamp : 'MagdalenaDhima 2/11/2021 21:41',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T21:42:12.709875-05:00' ],		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , \' \' )]. \r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\t\r\tTranscript show: dataInHand; cr.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tword := \'\'.\r\t\ttemp := OrderedCollection new.\r\t\taValue do: [:a | (a asString ~= \' \') ifTrue: [word := word , a asString] ifFalse: [ temp add: word. word := \'\' ] ].\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\r\thighestSuitStreak := suitStreak.\r\t"\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak]."\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/31/2021 15:23',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , \' \' )]. \r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\t\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tword := \'\'.\r\t\ttemp := OrderedCollection new.\r\t\taValue do: [:a | (a asString ~= \' \') ifTrue: [word := word , a asString] ifFalse: [ temp add: word. word := \'\' ] ].\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\r\thighestSuitStreak := suitStreak.\r\t"\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak]."\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 2/11/2021 21:42',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T21:42:35.643875-05:00' ],		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #accessing,			#sourceCode : 'sizeCheck: givenSize firstList: l1 secondList: l2\r\t"comment stating purpose of instance-side message"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| result l1_max l2_max aceInl1 aceInl2 |\r\tl1_max := 0.\r\tl2_max := 0.\r\tl1 isNotEmpty\r\t\tifTrue: [ l1_max := l1\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].\r\tl2 isEmpty\r\t\tifFalse: [ l2_max := l2\r\t\t\t\tinject: 0\r\t\t\t\tinto:\r\t\t\t\t\t[ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].\r\r\taceInl1 := l1 detect: [:a | (a copyFrom: 1 to: a size - 1) asNumber == 1 ] ifNone: [0].\r\taceInl2 := l2 detect: [:a | (a copyFrom: 1 to: a size - 1) asNumber == 1 ] ifNone: [0].\r\t\t\r\tresult := OrderedCollection new.\r\tl1 size == givenSize & (l2 size == givenSize)\r\t\tifTrue: [ result := ( aceInl1 ~= 0 | (l1_max > l2_max))\r\t\t\t\t& (aceInl2 == 0)\r\t\t\t\tifTrue: [ l1 ]\r\t\t\t\tifFalse: [ l2 ] ]\r\t\tifFalse: [ l1 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ].\r\t\t\tl2 size == givenSize\r\t\t\t\tifTrue: [ result := l2 ] ].\r\tTranscript show: \'result\'; show: result;\r\t\tcr.\r\t^ result',			#stamp : 'MagdalenaDhima 1/31/2021 15:31',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #accessing,			#sourceCode : 'sizeCheck: givenSize firstList: l1 secondList: l2\r\t"comment stating purpose of instance-side message"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| result l1_max l2_max aceInl1 aceInl2 |\r\tl1_max := 0.\r\tl2_max := 0.\r\tl1 isNotEmpty\r\t\tifTrue: [ l1_max := l1\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].\r\tl2 isEmpty\r\t\tifFalse: [ l2_max := l2\r\t\t\t\tinject: 0\r\t\t\t\tinto:\r\t\t\t\t\t[ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].\r\r\taceInl1 := l1 detect: [:a | (a copyFrom: 1 to: a size - 1) asNumber == 1 ] ifNone: [0].\r\taceInl2 := l2 detect: [:a | (a copyFrom: 1 to: a size - 1) asNumber == 1 ] ifNone: [0].\r\t\t\r\tresult := OrderedCollection new.\r\tl1 size == givenSize & (l2 size == givenSize)\r\t\tifTrue: [ result := ( aceInl1 ~= 0 | (l1_max > l2_max))\r\t\t\t\t& (aceInl2 == 0)\r\t\t\t\tifTrue: [ l1 ]\r\t\t\t\tifFalse: [ l2 ] ]\r\t\tifFalse: [ l1 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ].\r\t\t\tl2 size == givenSize\r\t\t\t\tifTrue: [ result := l2 ] ].\r\t\t\t\r\t^ result',			#stamp : 'MagdalenaDhima 2/11/2021 21:42',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T21:42:48.802875-05:00' ],		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sort:',			#protocol : #sorting,			#sourceCode : 'sort: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| threeDigits twoDigits sorted aces |\r\r\t\rthreeDigits := SortedCollection new. \rtwoDigits := SortedCollection new.\r\r1 to: (shuf size) do: [ :i | ((shuf at: i) size == 3) ifTrue: [threeDigits add: (shuf at: i)] ifFalse: [twoDigits add: (shuf at: i)]. ].\r\rsorted := (twoDigits asArray) , (threeDigits asArray).\races := sorted select: [:a |  (a copyFrom: 1 to: (a size-1)) asNumber == 1 ].\rsorted := sorted reject: [:a |  (a copyFrom: 1 to: (a size-1)) asNumber == 1 ].\rsorted := sorted , aces.\rTranscript show: sorted; cr.\r^sorted',			#stamp : 'MagdalenaDhima 1/31/2021 13:32',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sort:',			#protocol : #sorting,			#sourceCode : 'sort: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| threeDigits twoDigits sorted aces |\r\r\t\rthreeDigits := SortedCollection new. \rtwoDigits := SortedCollection new.\r\r1 to: (shuf size) do: [ :i | ((shuf at: i) size == 3) ifTrue: [threeDigits add: (shuf at: i)] ifFalse: [twoDigits add: (shuf at: i)]. ].\r\rsorted := (twoDigits asArray) , (threeDigits asArray).\races := sorted select: [:a |  (a copyFrom: 1 to: (a size-1)) asNumber == 1 ].\rsorted := sorted reject: [:a |  (a copyFrom: 1 to: (a size-1)) asNumber == 1 ].\rsorted := sorted , aces.\r^sorted',			#stamp : 'MagdalenaDhima 2/11/2021 21:42',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T21:45:03.024875-05:00' ],		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b.\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 8; cr. ^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tTranscript show:  sorted; cr.\r\tTranscript show:  \'h\'; cr.\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 2/11/2021 21:36',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b.\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 21:45',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T21:45:42.067875-05:00' ],		#prior : OmReference [ '22' ],		#self : OmReference [ '23' ]	},	#content : EpSessionSnapshot {		#imageName : 'C:\\Users\\Administrator\\Documents\\Pharo\\images\\Pharo 8.0 - 64bit (stable)\\game1.image'	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T22:06:40.928875-05:00' ],		#prior : OmReference [ '23' ],		#self : OmReference [ '24' ]	},	#content : EpSessionSnapshot {		#imageName : 'C:\\Users\\Administrator\\Documents\\Pharo\\images\\Pharo 8.0 - 64bit (stable)\\game1.image'	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T22:12:46.820875-05:00' ],		#prior : OmReference [ '24' ],		#self : OmReference [ '25' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b.\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 21:45',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\tTranscript show: valueStreak1b; show: valueStreak2b; cr. \r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b.\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 22:12',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T22:14:00.667875-05:00' ],		#prior : OmReference [ '25' ],		#self : OmReference [ '26' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\tTranscript show: valueStreak1b; show: valueStreak2b; cr. \r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b.\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 22:12',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r   Transcript show: valueStreakA; show: valueStreakB; cr. \r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b.\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 22:14',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T22:15:22.377875-05:00' ],		#prior : OmReference [ '26' ],		#self : OmReference [ '27' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r   Transcript show: valueStreakA; show: valueStreakB; cr. \r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b.\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 22:14',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b.\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tTranscript show: valueStreakA; show: valueStreakB; cr. \r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 22:15',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T22:15:41.962875-05:00' ],		#prior : OmReference [ '27' ],		#self : OmReference [ '28' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b.\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tTranscript show: valueStreakA; show: valueStreakB; cr. \r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 22:15',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t\r\tTranscript show: valueStreakA; show: valueStreakB; cr. \r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 22:15',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T22:16:14.592875-05:00' ],		#prior : OmReference [ '28' ],		#self : OmReference [ '29' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t\r\tTranscript show: valueStreakA; show: valueStreakB; cr. \r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 22:15',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 22:16',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T22:16:24.350875-05:00' ],		#prior : OmReference [ '29' ],		#self : OmReference [ '30' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 22:16',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b.\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 22:16',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T22:16:49.385875-05:00' ],		#prior : OmReference [ '30' ],		#self : OmReference [ '31' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b.\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 22:16',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b.\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.\r\tTranscript show: valueStreak; show: valueStreakB; cr. \r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 22:16',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T22:19:12.003875-05:00' ],		#prior : OmReference [ '31' ],		#self : OmReference [ '32' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #accessing,			#sourceCode : 'sizeCheck: givenSize firstList: l1 secondList: l2\r\t"comment stating purpose of instance-side message"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| result l1_max l2_max aceInl1 aceInl2 |\r\tl1_max := 0.\r\tl2_max := 0.\r\tl1 isNotEmpty\r\t\tifTrue: [ l1_max := l1\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].\r\tl2 isEmpty\r\t\tifFalse: [ l2_max := l2\r\t\t\t\tinject: 0\r\t\t\t\tinto:\r\t\t\t\t\t[ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].\r\r\taceInl1 := l1 detect: [:a | (a copyFrom: 1 to: a size - 1) asNumber == 1 ] ifNone: [0].\r\taceInl2 := l2 detect: [:a | (a copyFrom: 1 to: a size - 1) asNumber == 1 ] ifNone: [0].\r\t\t\r\tresult := OrderedCollection new.\r\tl1 size == givenSize & (l2 size == givenSize)\r\t\tifTrue: [ result := ( aceInl1 ~= 0 | (l1_max > l2_max))\r\t\t\t\t& (aceInl2 == 0)\r\t\t\t\tifTrue: [ l1 ]\r\t\t\t\tifFalse: [ l2 ] ]\r\t\tifFalse: [ l1 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ].\r\t\t\tl2 size == givenSize\r\t\t\t\tifTrue: [ result := l2 ] ].\r\t\t\t\r\t^ result',			#stamp : 'MagdalenaDhima 2/11/2021 21:42',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #accessing,			#sourceCode : 'sizeCheck: givenSize firstList: l1 secondList: l2\r\t"comment stating purpose of instance-side message"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| result l1_max l2_max aceInl1 aceInl2 |\r\tl1_max := 0.\r\tl2_max := 0.\r\tl1 isNotEmpty\r\t\tifTrue: [ l1_max := l1\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].\r\tl2 isEmpty\r\t\tifFalse: [ l2_max := l2\r\t\t\t\tinject: 0\r\t\t\t\tinto:\r\t\t\t\t\t[ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].\r\r\taceInl1 := l1 detect: [:a | (a copyFrom: 1 to: a size - 1) asNumber == 1 ] ifNone: [0].\r\taceInl2 := l2 detect: [:a | (a copyFrom: 1 to: a size - 1) asNumber == 1 ] ifNone: [0].\r\t\r\tTranscript show: l1_max; show: l2_max ; cr.\r\t\t\r\tresult := OrderedCollection new.\r\tl1 size == givenSize & (l2 size == givenSize)\r\t\tifTrue: [ result := ( aceInl1 ~= 0 | (l1_max > l2_max))\r\t\t\t\t& (aceInl2 == 0)\r\t\t\t\tifTrue: [ l1 ]\r\t\t\t\tifFalse: [ l2 ] ]\r\t\tifFalse: [ l1 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ].\r\t\t\tl2 size == givenSize\r\t\t\t\tifTrue: [ result := l2 ] ].\r\t\t\t\r\t^ result',			#stamp : 'MagdalenaDhima 2/11/2021 22:19',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T22:37:03.428875-05:00' ],		#prior : OmReference [ '32' ],		#self : OmReference [ '33' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b.\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.\r\tTranscript show: valueStreak; show: valueStreakB; cr. \r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 22:16',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\t(valueStreak1 at: 1) = (valueStreak2 at: 1) \r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 4 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t\r\t\r\tTranscript show: valueStreak; show: valueStreakB; cr. \r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 22:37',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T22:37:20.402875-05:00' ],		#prior : OmReference [ '33' ],		#self : OmReference [ '34' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\t(valueStreak1 at: 1) = (valueStreak2 at: 1) \r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 4 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t\r\t\r\tTranscript show: valueStreak; show: valueStreakB; cr. \r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 22:37',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\t(valueStreak1 at: 1) = (valueStreak2 at: 1) \r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 4 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 22:37',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T22:38:17.144875-05:00' ],		#prior : OmReference [ '34' ],		#self : OmReference [ '35' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\t(valueStreak1 at: 1) = (valueStreak2 at: 1) \r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 4 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 22:37',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\t(valueStreak1 at: 1) == (valueStreak2 at: 1) \r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 4 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 22:38',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T22:38:32.944875-05:00' ],		#prior : OmReference [ '35' ],		#self : OmReference [ '36' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\t(valueStreak1 at: 1) == (valueStreak2 at: 1) \r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 4 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 22:38',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\t(valueStreak1 at: 1) ~= (valueStreak2 at: 1) \r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 4 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 22:38',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T22:39:05.494875-05:00' ],		#prior : OmReference [ '36' ],		#self : OmReference [ '37' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\t(valueStreak1 at: 1) ~= (valueStreak2 at: 1) \r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 4 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 22:38',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\t(valueStreak1 at: 1) ~= (valueStreak2 at: 1) \r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 22:39',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T22:43:58.747875-05:00' ],		#prior : OmReference [ '37' ],		#self : OmReference [ '38' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\t(valueStreak1 at: 1) ~= (valueStreak2 at: 1) \r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 22:39',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\t(valueStreak1 at: 1) ~= (valueStreak2 at: 1) \r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 22:43',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T22:47:33.337875-05:00' ],		#prior : OmReference [ '38' ],		#self : OmReference [ '39' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\t(valueStreak1 at: 1) ~= (valueStreak2 at: 1) \r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 22:46',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\t(valueStreak1 at: 1) ~= (valueStreak2 at: 1) \r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := (self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2), (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 22:47',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T22:48:08.508875-05:00' ],		#prior : OmReference [ '39' ],		#self : OmReference [ '40' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\t(valueStreak1 at: 1) ~= (valueStreak2 at: 1) \r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := (self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2), (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 22:47',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\t(valueStreak1 at: 1) ~= (valueStreak2 at: 1) \r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := (self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2), (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\tTranscript show: valueStreak; cr.\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 22:48',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T22:49:41.175875-05:00' ],		#prior : OmReference [ '40' ],		#self : OmReference [ '41' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\t(valueStreak1 at: 1) ~= (valueStreak2 at: 1) \r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := (self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2), (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\tTranscript show: valueStreak; cr.\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 22:48',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\t(valueStreak1 at: 1) ~= (valueStreak2 at: 1) \r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := (self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2), (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\tTranscript show: valueStreak; cr.\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\tTranscript show: valueStreak; cr.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 22:49',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T22:51:00.572875-05:00' ],		#prior : OmReference [ '41' ],		#self : OmReference [ '42' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\t(valueStreak1 at: 1) ~= (valueStreak2 at: 1) \r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := (self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2), (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\tTranscript show: valueStreak; cr.\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\tTranscript show: valueStreak; cr.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 22:49',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\t(valueStreak1 at: 1) ~= (valueStreak2 at: 1) \r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := (self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2), (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\tTranscript show: valueStreak; cr.\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\t\r\r\tTranscript show: valueStreak; cr.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 22:51',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T22:51:23.848875-05:00' ],		#prior : OmReference [ '42' ],		#self : OmReference [ '43' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\t(valueStreak1 at: 1) ~= (valueStreak2 at: 1) \r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := (self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2), (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\tTranscript show: valueStreak; cr.\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\t\r\r\tTranscript show: valueStreak; cr.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 22:51',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\t(valueStreak1 at: 1) ~= (valueStreak2 at: 1) \r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := (self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2), (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\t\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 22:51',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T22:54:11.243875-05:00' ],		#prior : OmReference [ '43' ],		#self : OmReference [ '44' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\t(valueStreak1 at: 1) ~= (valueStreak2 at: 1) \r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := (self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2), (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\t\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 22:51',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\t(valueStreak1 at: 1) ~= (valueStreak2 at: 1) \r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := (self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2), (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tTranscript show: \'here \', valueStreak.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 22:54',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T22:56:53.546875-05:00' ],		#prior : OmReference [ '44' ],		#self : OmReference [ '45' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\t(valueStreak1 at: 1) ~= (valueStreak2 at: 1) \r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := (self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2), (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tTranscript show: \'here \', valueStreak.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 22:54',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\t(valueStreak1 at: 1) ~= (valueStreak2 at: 1) \r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tTranscript show: \'here \', valueStreak.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 22:56',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T22:58:09.997875-05:00' ],		#prior : OmReference [ '45' ],		#self : OmReference [ '46' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\t(valueStreak1 at: 1) ~= (valueStreak2 at: 1) \r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tTranscript show: \'here \', valueStreak.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 22:56',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\t(valueStreak1 at: 1) ~= (valueStreak2 at: 1) \r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tTranscript show: \'here \', valueStreak.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 22:58',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T23:00:21.045875-05:00' ],		#prior : OmReference [ '46' ],		#self : OmReference [ '47' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\t(valueStreak1 at: 1) ~= (valueStreak2 at: 1) \r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tTranscript show: \'here \', valueStreak.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 22:58',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\t(valueStreak1 at: 1) ~= (valueStreak2 at: 1) \r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\tTranscript show: \'here \', valueStreak.\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tTranscript show: \'here \', valueStreak.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 23:00',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T23:02:56.280875-05:00' ],		#prior : OmReference [ '47' ],		#self : OmReference [ '48' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\t(valueStreak1 at: 1) ~= (valueStreak2 at: 1) \r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\tTranscript show: \'here \', valueStreak.\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tTranscript show: \'here \', valueStreak.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 23:00',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\t(valueStreak1 at: 1) ~= (valueStreak2 at: 1) \r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 23:02',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T23:05:26.315875-05:00' ],		#prior : OmReference [ '48' ],		#self : OmReference [ '49' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\t(valueStreak1 at: 1) ~= (valueStreak2 at: 1) \r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 23:02',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\tvalueStreak1 notEmpty & ( (valueStreak1 at: 1) ~= (valueStreak2 at: 1) )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 23:05',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T23:05:56.825875-05:00' ],		#prior : OmReference [ '49' ],		#self : OmReference [ '50' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\tvalueStreak1 notEmpty & ( (valueStreak1 at: 1) ~= (valueStreak2 at: 1) )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 23:05',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\t(valueStreak1 notEmpty & valueStreak2 notEmpty ) & ( (valueStreak1 at: 1) ~= (valueStreak2 at: 1) )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 23:05',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T23:06:21.392875-05:00' ],		#prior : OmReference [ '50' ],		#self : OmReference [ '51' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\t(valueStreak1 notEmpty & valueStreak2 notEmpty ) & ( (valueStreak1 at: 1) ~= (valueStreak2 at: 1) )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 23:05',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\t(valueStreak1 isEmpty not & valueStreak2 isEmpty not ) & ( (valueStreak1 at: 1) ~= (valueStreak2 at: 1) )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 23:06',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T23:07:57.965875-05:00' ],		#prior : OmReference [ '51' ],		#self : OmReference [ '52' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\t(valueStreak1 isEmpty not & valueStreak2 isEmpty not ) & ( (valueStreak1 at: 1) ~= (valueStreak2 at: 1) )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 23:06',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\t( (valueStreak1 isEmpty not) & (valueStreak2 isEmpty not) ) & ( (valueStreak1 at: 1) ~= (valueStreak2 at: 1) )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 23:07',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T23:08:37.307875-05:00' ],		#prior : OmReference [ '52' ],		#self : OmReference [ '53' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\t( (valueStreak1 isEmpty not) & (valueStreak2 isEmpty not) ) & ( (valueStreak1 at: 1) ~= (valueStreak2 at: 1) )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 23:07',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\tTranscript show: \'here \'; show: valueStreak class; cr.\r\t( (valueStreak1 isEmpty not) & (valueStreak2 isEmpty not) ) & ( (valueStreak1 at: 1) ~= (valueStreak2 at: 1) )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 23:08',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T23:08:57.876875-05:00' ],		#prior : OmReference [ '53' ],		#self : OmReference [ '54' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\tTranscript show: \'here \'; show: valueStreak class; cr.\r\t( (valueStreak1 isEmpty not) & (valueStreak2 isEmpty not) ) & ( (valueStreak1 at: 1) ~= (valueStreak2 at: 1) )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 23:08',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\tTranscript show: \'here \'; show: valueStreak length; cr.\r\t( (valueStreak1 isEmpty not) & (valueStreak2 isEmpty not) ) & ( (valueStreak1 at: 1) ~= (valueStreak2 at: 1) )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 23:08',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T23:09:26.601875-05:00' ],		#prior : OmReference [ '54' ],		#self : OmReference [ '55' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\tTranscript show: \'here \'; show: valueStreak length; cr.\r\t( (valueStreak1 isEmpty not) & (valueStreak2 isEmpty not) ) & ( (valueStreak1 at: 1) ~= (valueStreak2 at: 1) )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 23:08',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\tTranscript show: \'here \'; show: valueStreak size; cr.\r\t( (valueStreak1 isEmpty not) & (valueStreak2 isEmpty not) ) & ( (valueStreak1 at: 1) ~= (valueStreak2 at: 1) )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 23:09',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T23:09:56.656875-05:00' ],		#prior : OmReference [ '55' ],		#self : OmReference [ '56' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\tTranscript show: \'here \'; show: valueStreak size; cr.\r\t( (valueStreak1 isEmpty not) & (valueStreak2 isEmpty not) ) & ( (valueStreak1 at: 1) ~= (valueStreak2 at: 1) )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 23:09',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\tTranscript show: \'here \'; show: valueStreak size; cr.\r\t( (valueStreak1 size ~= 0) & (valueStreak2 size ~= 0) ) & ( (valueStreak1 at: 1) ~= (valueStreak2 at: 1) )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 23:09',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T23:11:02.948875-05:00' ],		#prior : OmReference [ '56' ],		#self : OmReference [ '57' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\tTranscript show: \'here \'; show: valueStreak size; cr.\r\t( (valueStreak1 size ~= 0) & (valueStreak2 size ~= 0) ) & ( (valueStreak1 at: 1) ~= (valueStreak2 at: 1) )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 23:09',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\tTranscript show: \'here \'; show: (valueStreak1 size ~= 0) ; cr.\r\t( (valueStreak1 size ~= 0) & (valueStreak2 size ~= 0) ) & ( (valueStreak1 at: 1) ~= (valueStreak2 at: 1) )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 23:11',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T23:11:22.195875-05:00' ],		#prior : OmReference [ '57' ],		#self : OmReference [ '58' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\tTranscript show: \'here \'; show: (valueStreak1 size ~= 0) ; cr.\r\t( (valueStreak1 size ~= 0) & (valueStreak2 size ~= 0) ) & ( (valueStreak1 at: 1) ~= (valueStreak2 at: 1) )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 23:11',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\tTranscript show: \'here \'; show: (valueStreak1 size ~= 0) ; cr.\r\t( (valueStreak1 size == 0) & (valueStreak2 size == 0) ) & ( (valueStreak1 at: 1) ~= (valueStreak2 at: 1) )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 23:11',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T23:11:56.447875-05:00' ],		#prior : OmReference [ '58' ],		#self : OmReference [ '59' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\tTranscript show: \'here \'; show: (valueStreak1 size ~= 0) ; cr.\r\t( (valueStreak1 size == 0) & (valueStreak2 size == 0) ) & ( (valueStreak1 at: 1) ~= (valueStreak2 at: 1) )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 23:11',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\tTranscript show: \'here \'; show: (valueStreak2 size ~= 0) ; cr.\r\t( (valueStreak1 size == 0) & (valueStreak2 size == 0) ) & ( (valueStreak1 at: 1) ~= (valueStreak2 at: 1) )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 23:11',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T23:12:13.913875-05:00' ],		#prior : OmReference [ '59' ],		#self : OmReference [ '60' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\tTranscript show: \'here \'; show: (valueStreak2 size ~= 0) ; cr.\r\t( (valueStreak1 size == 0) & (valueStreak2 size == 0) ) & ( (valueStreak1 at: 1) ~= (valueStreak2 at: 1) )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 23:11',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\tTranscript show: \'here \'; show: (valueStreak2 size ~= 0) ; cr.\r\t( (valueStreak1 size ~= 0) & (valueStreak2 size ~= 0) ) & ( (valueStreak1 at: 1) ~= (valueStreak2 at: 1) )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 23:12',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T23:13:06.388875-05:00' ],		#prior : OmReference [ '60' ],		#self : OmReference [ '61' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\tTranscript show: \'here \'; show: (valueStreak2 size ~= 0) ; cr.\r\t( (valueStreak1 size ~= 0) & (valueStreak2 size ~= 0) ) & ( (valueStreak1 at: 1) ~= (valueStreak2 at: 1) )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 23:12',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\tTranscript show: \'here \'; show: (valueStreak2 size ~= 0) ; cr.\r\t( (valueStreak1 size ~= 0) & (valueStreak2 size ~= 0) ) \r\tifTrue: [( (valueStreak1 at: 1) ~= (valueStreak2 at: 1) )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].].\r\t\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 23:13',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T23:21:46.485875-05:00' ],		#prior : OmReference [ '61' ],		#self : OmReference [ '62' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\tTranscript show: \'here \'; show: (valueStreak2 size ~= 0) ; cr.\r\t( (valueStreak1 size ~= 0) & (valueStreak2 size ~= 0) ) \r\tifTrue: [( (valueStreak1 at: 1) ~= (valueStreak2 at: 1) )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].].\r\t\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 23:13',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 size > 0) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 size > 0) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 23:21',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T23:22:12.717875-05:00' ],		#prior : OmReference [ '62' ],		#self : OmReference [ '63' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 size > 0) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 size > 0) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 23:21',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 isEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 isEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 23:22',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T23:22:40.768875-05:00' ],		#prior : OmReference [ '63' ],		#self : OmReference [ '64' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 isEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 isEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 23:22',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 23:22',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T23:30:14.191875-05:00' ],		#prior : OmReference [ '64' ],		#self : OmReference [ '65' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tTranscript show: \'here \'; show: valueStreak.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 23:22',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 23:30',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T23:30:21.633875-05:00' ],		#prior : OmReference [ '65' ],		#self : OmReference [ '66' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #accessing,			#sourceCode : 'sizeCheck: givenSize firstList: l1 secondList: l2\r\t"comment stating purpose of instance-side message"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| result l1_max l2_max aceInl1 aceInl2 |\r\tl1_max := 0.\r\tl2_max := 0.\r\tl1 isNotEmpty\r\t\tifTrue: [ l1_max := l1\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].\r\tl2 isEmpty\r\t\tifFalse: [ l2_max := l2\r\t\t\t\tinject: 0\r\t\t\t\tinto:\r\t\t\t\t\t[ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].\r\r\taceInl1 := l1 detect: [:a | (a copyFrom: 1 to: a size - 1) asNumber == 1 ] ifNone: [0].\r\taceInl2 := l2 detect: [:a | (a copyFrom: 1 to: a size - 1) asNumber == 1 ] ifNone: [0].\r\t\r\tTranscript show: l1_max; show: l2_max ; cr.\r\t\t\r\tresult := OrderedCollection new.\r\tl1 size == givenSize & (l2 size == givenSize)\r\t\tifTrue: [ result := ( aceInl1 ~= 0 | (l1_max > l2_max))\r\t\t\t\t& (aceInl2 == 0)\r\t\t\t\tifTrue: [ l1 ]\r\t\t\t\tifFalse: [ l2 ] ]\r\t\tifFalse: [ l1 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ].\r\t\t\tl2 size == givenSize\r\t\t\t\tifTrue: [ result := l2 ] ].\r\t\t\t\r\t^ result',			#stamp : 'MagdalenaDhima 2/11/2021 22:19',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #accessing,			#sourceCode : 'sizeCheck: givenSize firstList: l1 secondList: l2\r\t"comment stating purpose of instance-side message"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| result l1_max l2_max aceInl1 aceInl2 |\r\tl1_max := 0.\r\tl2_max := 0.\r\tl1 isNotEmpty\r\t\tifTrue: [ l1_max := l1\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].\r\tl2 isEmpty\r\t\tifFalse: [ l2_max := l2\r\t\t\t\tinject: 0\r\t\t\t\tinto:\r\t\t\t\t\t[ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].\r\r\taceInl1 := l1 detect: [:a | (a copyFrom: 1 to: a size - 1) asNumber == 1 ] ifNone: [0].\r\taceInl2 := l2 detect: [:a | (a copyFrom: 1 to: a size - 1) asNumber == 1 ] ifNone: [0].\r\t\r\t\t\r\tresult := OrderedCollection new.\r\tl1 size == givenSize & (l2 size == givenSize)\r\t\tifTrue: [ result := ( aceInl1 ~= 0 | (l1_max > l2_max))\r\t\t\t\t& (aceInl2 == 0)\r\t\t\t\tifTrue: [ l1 ]\r\t\t\t\tifFalse: [ l2 ] ]\r\t\tifFalse: [ l1 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ].\r\t\t\tl2 size == givenSize\r\t\t\t\tifTrue: [ result := l2 ] ].\r\t\t\t\r\t^ result',			#stamp : 'MagdalenaDhima 2/11/2021 23:30',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T23:34:20.861875-05:00' ],		#prior : OmReference [ '66' ],		#self : OmReference [ '67' ]	},	#content : EpSessionSnapshot {		#imageName : 'C:\\Users\\Administrator\\Documents\\Pharo\\images\\Pharo 8.0 - 64bit (stable)\\game1.image'	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T23:40:39.613875-05:00' ],		#prior : OmReference [ '67' ],		#self : OmReference [ '68' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 23:30',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB ]\r\tifFalse: [ valueStreak := (self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2) , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 23:40',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T23:53:55.903875-05:00' ],		#prior : OmReference [ '68' ],		#self : OmReference [ '69' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB ]\r\tifFalse: [ valueStreak := (self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2) , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 23:40',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 ) & ( (self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2) size == 3)\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t"\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 23:53',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T23:55:02.817875-05:00' ],		#prior : OmReference [ '69' ],		#self : OmReference [ '70' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 ) & ( (self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2) size == 3)\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t"\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 23:53',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 ) & ( (self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2) size == 3)\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t"\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak; cr.\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 23:55',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T23:55:28.599875-05:00' ],		#prior : OmReference [ '70' ],		#self : OmReference [ '71' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 ) & ( (self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2) size == 3)\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t"\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak; cr.\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 23:55',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 ) & ( (self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2) size == 3)\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t"\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: (temp1==temp2); cr.\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 23:55',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T23:56:04.231875-05:00' ],		#prior : OmReference [ '71' ],		#self : OmReference [ '72' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 ) & ( (self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2) size == 3)\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t"\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: (temp1==temp2); cr.\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 23:55',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 ) & ( (self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2) size == 3)\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t"\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: (temp1==temp2); cr.\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 23:56',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T23:57:05.758875-05:00' ],		#prior : OmReference [ '72' ],		#self : OmReference [ '73' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 ) & ( (self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2) size == 3)\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t"\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: (temp1==temp2); cr.\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 23:56',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 ) & ( (self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2) size == 3)\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t"\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak1; cr.\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 23:57',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-11T23:57:17.260875-05:00' ],		#prior : OmReference [ '73' ],		#self : OmReference [ '74' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 ) & ( (self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2) size == 3)\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t"\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak1; cr.\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 23:57',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 ) & ( (self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2) size == 3)\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t"\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak2; cr.\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 23:57',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T00:01:12.187875-05:00' ],		#prior : OmReference [ '74' ],		#self : OmReference [ '75' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 ) & ( (self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2) size == 3)\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t"\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak2; cr.\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/11/2021 23:57',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 ) & ( (self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2) size == 3)\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := ( temp1 > temp2 ) ifTrue: [ valueStreakA  ] ifFalse: [ valueStreakB ] ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t"\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak2; cr.\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/12/2021 00:01',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T00:02:34.202875-05:00' ],		#prior : OmReference [ '75' ],		#self : OmReference [ '76' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 ) & ( (self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2) size == 3)\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := ( temp1 > temp2 ) ifTrue: [ valueStreakA  ] ifFalse: [ valueStreakB ] ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t"\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak2; cr.\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/12/2021 00:01',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 ) & ( (self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2) size == 3)\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := ( temp1 > temp2 ) ifTrue: [ valueStreakA  ] ifFalse: [ valueStreakB ] ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t"\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak1; show: valueStreak; cr.\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/12/2021 00:02',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T00:05:17.457875-05:00' ],		#prior : OmReference [ '76' ],		#self : OmReference [ '77' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 ) & ( (self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2) size == 3)\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := ( temp1 > temp2 ) ifTrue: [ valueStreakA  ] ifFalse: [ valueStreakB ] ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t"\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak1; show: valueStreak; cr.\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/12/2021 00:02',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ (valueStreak1 at: 1) copyFrom: 1 to: ((valueStreak1 at: 1) size-1) ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ (valueStreak2 at: 1) copyFrom: 1 to: ((valueStreak2 at: 1) size-1)  ].\r\t( temp1 ~= temp2 ) & ( (self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2) size == 3)\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := ( temp1 > temp2 ) ifTrue: [ valueStreakA  ] ifFalse: [ valueStreakB ] ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t"\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak1; show: valueStreak; cr.\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/12/2021 00:05',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T00:05:58.233875-05:00' ],		#prior : OmReference [ '77' ],		#self : OmReference [ '78' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ (valueStreak1 at: 1) copyFrom: 1 to: ((valueStreak1 at: 1) size-1) ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ (valueStreak2 at: 1) copyFrom: 1 to: ((valueStreak2 at: 1) size-1)  ].\r\t( temp1 ~= temp2 ) & ( (self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2) size == 3)\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := ( temp1 > temp2 ) ifTrue: [ valueStreakA  ] ifFalse: [ valueStreakB ] ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t"\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak1; show: valueStreak; cr.\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/12/2021 00:05',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ ( (valueStreak1 at: 1) copyFrom: 1 to: ((valueStreak1 at: 1) size-1) ) asNumber ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ ( (valueStreak2 at: 1) copyFrom: 1 to: ((valueStreak2 at: 1) size-1) ) asNumber ].\r\t( temp1 ~= temp2 ) & ( (self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2) size == 3)\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := ( temp1 > temp2 ) ifTrue: [ valueStreakA  ] ifFalse: [ valueStreakB ] ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t"\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak1; show: valueStreak; cr.\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/12/2021 00:05',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T00:06:35.550875-05:00' ],		#prior : OmReference [ '78' ],		#self : OmReference [ '79' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ ( (valueStreak1 at: 1) copyFrom: 1 to: ((valueStreak1 at: 1) size-1) ) asNumber ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ ( (valueStreak2 at: 1) copyFrom: 1 to: ((valueStreak2 at: 1) size-1) ) asNumber ].\r\t( temp1 ~= temp2 ) & ( (self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2) size == 3)\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := ( temp1 > temp2 ) ifTrue: [ valueStreakA  ] ifFalse: [ valueStreakB ] ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t"\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak1; show: valueStreak; cr.\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/12/2021 00:05',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ ( (valueStreak1 at: 1) copyFrom: 1 to: ((valueStreak1 at: 1) size-1) ) asNumber ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ ( (valueStreak2 at: 1) copyFrom: 1 to: ((valueStreak2 at: 1) size-1) ) asNumber ].\r\t( temp1 ~= temp2 ) & ( (self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2) size == 3)\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := ( temp1 > temp2 ) ifTrue: [ valueStreakA  ] ifFalse: [ valueStreakB ] ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t"\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak1; show: valueStreak; cr.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/12/2021 00:06',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T00:09:35.656875-05:00' ],		#prior : OmReference [ '79' ],		#self : OmReference [ '80' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ ( (valueStreak1 at: 1) copyFrom: 1 to: ((valueStreak1 at: 1) size-1) ) asNumber ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ ( (valueStreak2 at: 1) copyFrom: 1 to: ((valueStreak2 at: 1) size-1) ) asNumber ].\r\t( temp1 ~= temp2 ) & ( (self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2) size == 3)\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := ( temp1 > temp2 ) ifTrue: [ valueStreakA  ] ifFalse: [ valueStreakB ] ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t"\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak1; show: valueStreak; cr.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/12/2021 00:06',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\ttemp1 = 0.\r\ttemp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ ( (valueStreak1 at: 1) copyFrom: 1 to: ((valueStreak1 at: 1) size-1) ) asNumber ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ ( (valueStreak2 at: 1) copyFrom: 1 to: ((valueStreak2 at: 1) size-1) ) asNumber ].\r\t( temp1 ~= temp2 ) & ( (self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2) size == 3)\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := ( temp1 > temp2 ) ifTrue: [ valueStreakA  ] ifFalse: [ valueStreakB ] ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t"\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak1; show: valueStreak; cr.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/12/2021 00:09',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T00:10:42.998875-05:00' ],		#prior : OmReference [ '80' ],		#self : OmReference [ '81' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\ttemp1 = 0.\r\ttemp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ ( (valueStreak1 at: 1) copyFrom: 1 to: ((valueStreak1 at: 1) size-1) ) asNumber ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ ( (valueStreak2 at: 1) copyFrom: 1 to: ((valueStreak2 at: 1) size-1) ) asNumber ].\r\t( temp1 ~= temp2 ) & ( (self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2) size == 3)\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := ( temp1 > temp2 ) ifTrue: [ valueStreakA  ] ifFalse: [ valueStreakB ] ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t"\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak1; show: valueStreak; cr.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1, temp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/12/2021 00:09',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\ttemp1 = 0.\r\ttemp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ ( (valueStreak1 at: 1) copyFrom: 1 to: ((valueStreak1 at: 1) size-1) ) asNumber ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ ( (valueStreak2 at: 1) copyFrom: 1 to: ((valueStreak2 at: 1) size-1) ) asNumber ].\r\t( temp1 ~= temp2 ) & ( (self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2) size == 3)\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := ( temp1 > temp2 ) ifTrue: [ valueStreakA  ] ifFalse: [ valueStreakB ] ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t"\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak1; show: valueStreak; cr.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1 = 0.\r\ttemp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/12/2021 00:10',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T00:20:57.928875-05:00' ],		#prior : OmReference [ '81' ],		#self : OmReference [ '82' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\ttemp1 = 0.\r\ttemp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ ( (valueStreak1 at: 1) copyFrom: 1 to: ((valueStreak1 at: 1) size-1) ) asNumber ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ ( (valueStreak2 at: 1) copyFrom: 1 to: ((valueStreak2 at: 1) size-1) ) asNumber ].\r\t( temp1 ~= temp2 ) & ( (self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2) size == 3)\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := ( temp1 > temp2 ) ifTrue: [ valueStreakA  ] ifFalse: [ valueStreakB ] ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t"\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak1; show: valueStreak; cr.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1 = 0.\r\ttemp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/12/2021 00:10',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\ttemp1 = 0.\r\ttemp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ ( (valueStreak1 at: 1) copyFrom: 1 to: ((valueStreak1 at: 1) size-1) ) asNumber ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ ( (valueStreak2 at: 1) copyFrom: 1 to: ((valueStreak2 at: 1) size-1) ) asNumber ].\r\t( temp1 ~= temp2 ) & ( (self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2) size == 3)\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := ( temp1 > temp2 ) ifTrue: [ valueStreakA  ] ifFalse: [ valueStreakB ] ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t"\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak2; show: valueStreak; cr.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1 = 0.\r\ttemp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/12/2021 00:20',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T00:25:03.661875-05:00' ],		#prior : OmReference [ '82' ],		#self : OmReference [ '83' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\ttemp1 = 0.\r\ttemp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ ( (valueStreak1 at: 1) copyFrom: 1 to: ((valueStreak1 at: 1) size-1) ) asNumber ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ ( (valueStreak2 at: 1) copyFrom: 1 to: ((valueStreak2 at: 1) size-1) ) asNumber ].\r\t( temp1 ~= temp2 ) & ( (self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2) size == 3)\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := ( temp1 > temp2 ) ifTrue: [ valueStreakA  ] ifFalse: [ valueStreakB ] ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t"\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak2; show: valueStreak; cr.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1 = 0.\r\ttemp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/12/2021 00:20',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\ttemp1 = 0.\r\ttemp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ ( (valueStreak1 at: 1) copyFrom: 1 to: ((valueStreak1 at: 1) size-1) ) asNumber ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ ( (valueStreak2 at: 1) copyFrom: 1 to: ((valueStreak2 at: 1) size-1) ) asNumber ].\r\t( temp1 ~= temp2 ) \r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := ( temp1 > temp2 ) ifTrue: [ valueStreakA  ] ifFalse: [ valueStreakB ] ]\r\tifFalse: [ (valueStreak1 size == 3) \r\t\tifTrue: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ]\r\t\tifFalse: [ valueStreak := valueStreak2 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ]  ].\r\t\r\t"\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak2; show: valueStreak; cr.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1 = 0.\r\ttemp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/12/2021 00:25',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T00:25:33.316875-05:00' ],		#prior : OmReference [ '83' ],		#self : OmReference [ '84' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\ttemp1 = 0.\r\ttemp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ ( (valueStreak1 at: 1) copyFrom: 1 to: ((valueStreak1 at: 1) size-1) ) asNumber ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ ( (valueStreak2 at: 1) copyFrom: 1 to: ((valueStreak2 at: 1) size-1) ) asNumber ].\r\t( temp1 ~= temp2 ) \r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := ( temp1 > temp2 ) ifTrue: [ valueStreakA  ] ifFalse: [ valueStreakB ] ]\r\tifFalse: [ (valueStreak1 size == 3) \r\t\tifTrue: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ]\r\t\tifFalse: [ valueStreak := valueStreak2 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ]  ].\r\t\r\t"\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak2; show: valueStreak; cr.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1 = 0.\r\ttemp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/12/2021 00:25',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\ttemp1 = 0.\r\ttemp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ ( (valueStreak1 at: 1) copyFrom: 1 to: ((valueStreak1 at: 1) size-1) ) asNumber ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ ( (valueStreak2 at: 1) copyFrom: 1 to: ((valueStreak2 at: 1) size-1) ) asNumber ].\r\t( temp1 ~= temp2 ) \r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := ( temp1 > temp2 ) ifTrue: [ valueStreakA  ] ifFalse: [ valueStreakB ] ]\r\tifFalse: [ (valueStreak1 size == 3) \r\t\tifTrue: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ]\r\t\tifFalse: [ valueStreak := valueStreak2 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ]  ].\r\t\r\t"\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak1; show: valueStreak; cr.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1 = 0.\r\ttemp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/12/2021 00:25',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-02-12T00:26:12.328875-05:00' ],		#prior : OmReference [ '84' ],		#self : OmReference [ '85' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\ttemp1 = 0.\r\ttemp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ ( (valueStreak1 at: 1) copyFrom: 1 to: ((valueStreak1 at: 1) size-1) ) asNumber ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ ( (valueStreak2 at: 1) copyFrom: 1 to: ((valueStreak2 at: 1) size-1) ) asNumber ].\r\t( temp1 ~= temp2 ) \r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := ( temp1 > temp2 ) ifTrue: [ valueStreakA  ] ifFalse: [ valueStreakB ] ]\r\tifFalse: [ (valueStreak1 size == 3) \r\t\tifTrue: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ]\r\t\tifFalse: [ valueStreak := valueStreak2 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ]  ].\r\t\r\t"\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak1; show: valueStreak; cr.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1 = 0.\r\ttemp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/12/2021 00:25',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreak1b valueStreak2b remaining1 remaining2 flush ace1 ace2 |\r\thand := self convert: shuf.\r\t\r\tself divideHands: hand.\r\tTranscript show: hand; cr.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.].\r\t\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.].\r\t\r\t\r\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\r\t\r\t"----------------------"\r\t\r\ttemp1 = 0.\r\ttemp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ ( (valueStreak1 at: 1) copyFrom: 1 to: ((valueStreak1 at: 1) size-1) ) asNumber ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ ( (valueStreak2 at: 1) copyFrom: 1 to: ((valueStreak2 at: 1) size-1) ) asNumber ].\r\t( temp1 ~= temp2 ) \r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := ( temp1 > temp2 ) ifTrue: [ valueStreakA  ] ifFalse: [ valueStreakB ] ]\r\tifFalse: [ (valueStreak1 size == 3) \r\t\tifTrue: [ valueStreak := valueStreak1 , valueStreak1b ]\r\t\tifFalse: [ valueStreak := valueStreak2 , valueStreak2b ]  ].\r\t\r\t"\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t]."\r\tTranscript show: valueStreak1; show: valueStreak; cr.\r\t(valueStreak size == 5 ) ifTrue: [^valueStreak].\r\t\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [^valueStreak].\r\t\r\ttemp1 = 0.\r\ttemp2 = 0.\r\ttemp1 := (valueStreak1 notEmpty) ifTrue: [ valueStreak1 at: 1 ].\r\ttemp2 := (valueStreak2 notEmpty) ifTrue: [ valueStreak2 at: 1 ].\r\t( temp1 ~= temp2 )\r\tifTrue: [  \r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b. \r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB. ]\r\tifFalse: [ valueStreak := valueStreak1 , (self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b) ].\r\t\r\t(valueStreak size == 4) ifTrue: [^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 2) ifTrue: [^valueStreak].\r\t\r\t\r\tsorted := OrderedCollection new. \r\tace1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == 1] ifNone: [0].\r\tace1 == 0 & ( ace2 == 0 ) ifTrue: \r\t[ \r\t  ace1 := hand1 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted1 := hand1 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace1] ifNone: [0].\r\t  ace2 := hand2 inject: 0 into: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] .\r\t  sorted2 := hand2 detect: [:a | ( a copyFrom: 1 to: (a size-1) ) asNumber == ace2] ifNone: [0].\r\t  sorted add: (ace1 > ace2 ifTrue: [ sorted1 ] ifFalse: [ sorted2 ] ) ] \r\tifFalse: [ (ace1 ~= 0) ifTrue: [sorted add: ace1] ifFalse: [sorted add: ace2] ].\r\t^sorted. ',			#stamp : 'MagdalenaDhima 2/12/2021 00:26',			#package : #CPS506		}	}}