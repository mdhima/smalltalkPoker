OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T12:20:56.048003-05:00' ],		#prior : OmReference [ 'Pharo8.0-SNAPSHOT-32bit-0932da8.3v4uf68stycy1rhoutjv6p70z', '23' ],		#self : OmReference [ '1' ]	},	#content : EpSessionSnapshot {		#imageName : 'C:\\Users\\Administrator\\Documents\\Pharo\\images\\Pharo 8.0 - 64bit (stable)\\game1.image'	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T12:21:00.881003-05:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpSessionSnapshot {		#imageName : 'C:\\Users\\Administrator\\Documents\\Pharo\\images\\Pharo 8.0 - 64bit (stable)\\game1.image'	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T12:23:15.469003-05:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'divideHands:',			#protocol : #'as yet unclassified',			#sourceCode : 'divideHands: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\thand := SortedCollection new. \r\thand2 := SortedCollection new. \r\r\t1 to: 4 do: [ :i | (i \\\\ 2 == 1) ifTrue: [ hand add: (shuf at: i) ] ifFalse: [ hand2 add: (shuf at: i) ] ].\r\t5 to: 9 do: [ :i | hand add: (shuf at: i). hand2 add: (shuf at: i) ].',			#stamp : 'MagdalenaDhima 1/31/2021 12:20',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'divideHands:',			#protocol : #actions,			#sourceCode : 'divideHands: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\thand := SortedCollection new. \r\thand2 := SortedCollection new. \r\r\t1 to: 4 do: [ :i | (i \\\\ 2 == 1) ifTrue: [ hand add: (shuf at: i) ] ifFalse: [ hand2 add: (shuf at: i) ] ].\r\t5 to: 9 do: [ :i | hand add: (shuf at: i). hand2 add: (shuf at: i) ].',			#stamp : 'MagdalenaDhima 1/31/2021 12:20',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T12:26:00.541003-05:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\tTranscript show: \'input\'; cr.\r\tTranscript show: streaks; cr.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\t(previous asNumber == current asNumber)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmaxCount := 0.\r\tmaxVal := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t( ( ( aKey asNumber ~= 1 & (aKey asNumber > maxVal asNumber) ) | (aKey asNumber == 1) ) & (aValue size >= maxCount) ) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue] ].\r\t\r\thighestValueStreak := valueStreak.\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/31/2021 12:03',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\t(previous asNumber == current asNumber)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmaxCount := 0.\r\tmaxVal := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t( ( ( aKey asNumber ~= 1 & (aKey asNumber > maxVal asNumber) ) | (aKey asNumber == 1) ) & (aValue size >= maxCount) ) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue] ].\r\t\r\thighestValueStreak := valueStreak.\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/31/2021 12:26',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T12:28:47.847003-05:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#definitionSource : 'Object subclass: #Poker\r\tinstanceVariableNames: \'hand hand2\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'CPS506\'',				#superclassName : 'Object',				#traitCompositionSource : '{}'			},			#name : #Poker,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Poker,						#isMetaSide : false					},					#name : #hand,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Poker,						#isMetaSide : false					},					#name : #hand2,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#definitionSource : 'Poker class\r\tinstanceVariableNames: \'\'',					#traitCompositionSource : '{}'				},				#name : #'Poker class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Poker,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #CPS506,			#package : #CPS506,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#definitionSource : 'Object subclass: #Poker\r\tinstanceVariableNames: \'hand1 hand2\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'CPS506\'',				#superclassName : 'Object',				#traitCompositionSource : '{}'			},			#name : #Poker,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Poker,						#isMetaSide : false					},					#name : #hand1,					#parent : @25				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Poker,						#isMetaSide : false					},					#name : #hand2,					#parent : @25				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#definitionSource : 'Poker class\r\tinstanceVariableNames: \'\'',					#traitCompositionSource : '{}'				},				#name : #'Poker class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @25			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Poker,					#isMetaSide : false				},				#parent : @25,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #CPS506,			#package : #CPS506,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T12:29:31.121003-05:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'divideHands:',			#protocol : #actions,			#sourceCode : 'divideHands: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\thand := SortedCollection new. \r\thand2 := SortedCollection new. \r\r\t1 to: 4 do: [ :i | (i \\\\ 2 == 1) ifTrue: [ hand add: (shuf at: i) ] ifFalse: [ hand2 add: (shuf at: i) ] ].\r\t5 to: 9 do: [ :i | hand add: (shuf at: i). hand2 add: (shuf at: i) ].',			#stamp : 'MagdalenaDhima 1/31/2021 12:20',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'divideHands:',			#protocol : #actions,			#sourceCode : 'divideHands: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\thand1 := SortedCollection new. \r\thand2 := SortedCollection new. \r\r\t1 to: 4 do: [ :i | (i \\\\ 2 == 1) ifTrue: [ hand1 add: (shuf at: i) ] ifFalse: [ hand2 add: (shuf at: i) ] ].\r\t5 to: 9 do: [ :i | hand1 add: (shuf at: i). hand2 add: (shuf at: i) ].',			#stamp : 'MagdalenaDhima 1/31/2021 12:29',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T12:31:53.422003-05:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #getData,			#protocol : #accessing,			#sourceCode : 'getData\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| dataInHand card temp temp2 |\r\t\rdataInHand := Dictionary new. \r1 to: 13 do: [ :i | dataInHand at: i put: 0].\rdataInHand at: \'C\' put: 0. dataInHand at: \'D\' put: 0. dataInHand at: \'H\' put: 0. dataInHand at: \'S\' put: 0.\r\r\r1 to: (hand size) do: [ :i |\r\tcard := hand at: i.\r\ttemp := (card copyFrom: 1 to: (card size-1)).\r\ttemp2 := card at: (card size).\r\tdataInHand at: temp asNumber put: ((dataInHand at: temp asNumber) +1 ).\r\tdataInHand at: temp2 asString put: ((dataInHand at: temp2 asString) +1 ).\r ].\r^dataInHand',			#stamp : 'MagdalenaDhima 1/30/2021 13:05',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #getData,			#protocol : #'as yet unclassified',			#sourceCode : 'getData\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| dataInHand card temp temp2 |\r\t\rdataInHand := Dictionary new. \r1 to: 13 do: [ :i | dataInHand at: i put: 0].\rdataInHand at: \'C\' put: 0. dataInHand at: \'D\' put: 0. dataInHand at: \'H\' put: 0. dataInHand at: \'S\' put: 0.\r\r\r1 to: (hand size) do: [ :i |\r\tcard := hand at: i.\r\ttemp := (card copyFrom: 1 to: (card size-1)).\r\ttemp2 := card at: (card size).\r\tdataInHand at: temp asNumber put: ((dataInHand at: temp asNumber) +1 ).\r\tdataInHand at: temp2 asString put: ((dataInHand at: temp2 asString) +1 ).\r ].\r^dataInHand',			#stamp : 'MagdalenaDhima 1/30/2021 13:05',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T12:31:53.480003-05:00' ],		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #getData,			#protocol : #accessing,			#sourceCode : 'getData\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| dataInHand card temp temp2 |\r\t\rdataInHand := Dictionary new. \r1 to: 13 do: [ :i | dataInHand at: i put: 0].\rdataInHand at: \'C\' put: 0. dataInHand at: \'D\' put: 0. dataInHand at: \'H\' put: 0. dataInHand at: \'S\' put: 0.\r\r\r1 to: (hand size) do: [ :i |\r\tcard := hand at: i.\r\ttemp := (card copyFrom: 1 to: (card size-1)).\r\ttemp2 := card at: (card size).\r\tdataInHand at: temp asNumber put: ((dataInHand at: temp asNumber) +1 ).\r\tdataInHand at: temp2 asString put: ((dataInHand at: temp2 asString) +1 ).\r ].\r^dataInHand',			#stamp : 'MagdalenaDhima 1/30/2021 13:05',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T12:32:31.472003-05:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'returnSuitCards:',			#protocol : #accessing,			#sourceCode : 'returnSuitCards: suit\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| cardsOfAKind card temp |\r\r\tcardsOfAKind := OrderedCollection new.\r\r\t1 to: (hand size) do: [ :i | \r\t\tcard := hand at: i.\r\t\ttemp := card at: (card size).\r\t\t(temp asSymbol == suit asSymbol) ifTrue: [cardsOfAKind add: card].\r].\r^cardsOfAKind',			#stamp : 'MagdalenaDhima 1/30/2021 15:03',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'returnSuitCards:',			#protocol : #'as yet unclassified',			#sourceCode : 'returnSuitCards: suit\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| cardsOfAKind card temp |\r\r\tcardsOfAKind := OrderedCollection new.\r\r\t1 to: (hand size) do: [ :i | \r\t\tcard := hand at: i.\r\t\ttemp := card at: (card size).\r\t\t(temp asSymbol == suit asSymbol) ifTrue: [cardsOfAKind add: card].\r].\r^cardsOfAKind',			#stamp : 'MagdalenaDhima 1/30/2021 15:03',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T12:32:31.476003-05:00' ],		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'returnSuitCards:',			#protocol : #accessing,			#sourceCode : 'returnSuitCards: suit\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| cardsOfAKind card temp |\r\r\tcardsOfAKind := OrderedCollection new.\r\r\t1 to: (hand size) do: [ :i | \r\t\tcard := hand at: i.\r\t\ttemp := card at: (card size).\r\t\t(temp asSymbol == suit asSymbol) ifTrue: [cardsOfAKind add: card].\r].\r^cardsOfAKind',			#stamp : 'MagdalenaDhima 1/30/2021 15:03',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T12:33:27.229003-05:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'convert:',			#protocol : #actions,			#sourceCode : 'convert: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp values suits output val |\r\thand := Array new: 9.\r\tvalues := #(\'1\' \'2\' \'3\' \'4\' \'5\' \'6\' \'7\' \'8\' \'9\' \'10\' \'11\' \'12\' \'13\').\r\tsuits := #(\'C\' \'D\' \'H\' \'S\').\r\t1 to: 9 do: [ :i | \r\t\tval := shuf at: i.\r\t\ttemp := val % 13.\r\t\toutput := (temp == 0) \r\t\t\tifFalse: [values at: temp]\r\t\t\tifTrue: [values at: 13]\r\t\t. \r\t\ttemp := val-1 // 13 +1 floor. \r\t\toutput := output , (suits at: temp). \r\t\thand at: i put: output.\r\t].',			#stamp : 'MagdalenaDhima 1/30/2021 22:28',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'convert:',			#protocol : #actions,			#sourceCode : 'convert: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| hand temp values suits output val |\r\thand := Array new: 9.\r\tvalues := #(\'1\' \'2\' \'3\' \'4\' \'5\' \'6\' \'7\' \'8\' \'9\' \'10\' \'11\' \'12\' \'13\').\r\tsuits := #(\'C\' \'D\' \'H\' \'S\').\r\t1 to: 9 do: [ :i | \r\t\tval := shuf at: i.\r\t\ttemp := val % 13.\r\t\toutput := (temp == 0) \r\t\t\tifFalse: [values at: temp]\r\t\t\tifTrue: [values at: 13]\r\t\t. \r\t\ttemp := val-1 // 13 +1 floor. \r\t\toutput := output , (suits at: temp). \r\t\thand at: i put: output.\r\t].\r^hand',			#stamp : 'MagdalenaDhima 1/31/2021 12:33',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T13:15:05.398003-05:00' ],		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #'as yet unclassified',			#sourceCode : 'sizeCheck: givenSize firstList: l1  secondList: l2\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| result |\r\t(l1 size == givenSize & (l2 size == givenSize)) ifTrue: [ \r\t\t( (l1 includes: 1 | (l1 max asNumber > l2 max asNumber)) & (l2 includes: 1) not ) \r\t\t\t\tifTrue: [ result := l1 ]\r\t\t \t\tifFalse: [ result := l2 ]  ]\r\t\tifFalse: [(l1 size == givenSize) ifTrue: [result := l1]. (l2 size == givenSize) ifTrue: [ result := l1 ] ].\r\t\r\t^result',			#stamp : 'MagdalenaDhima 1/31/2021 13:15',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T13:24:36.782003-05:00' ],		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #'as yet unclassified',			#sourceCode : 'sizeCheck: givenSize firstList: l1  secondList: l2\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| result |\r\t(l1 size == givenSize & (l2 size == givenSize)) ifTrue: [ \r\t\t( (l1 includes: 1 | (l1 max asNumber > l2 max asNumber)) & (l2 includes: 1) not ) \r\t\t\t\tifTrue: [ result := l1 ]\r\t\t \t\tifFalse: [ result := l2 ]  ]\r\t\tifFalse: [(l1 size == givenSize) ifTrue: [result := l1]. (l2 size == givenSize) ifTrue: [ result := l1 ] ].\r\t\r\t^result',			#stamp : 'MagdalenaDhima 1/31/2021 13:15',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #'as yet unclassified',			#sourceCode : 'sizeCheck: givenSize firstList: l1  secondList: l2\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| result |\r\tresult := OrderedCollection new.\r\t(l1 size == givenSize & (l2 size == givenSize)) ifTrue: [ \r\t\t( (l1 includes: 1 | (l1 max asNumber > l2 max asNumber)) & (l2 includes: 1) not ) \r\t\t\t\tifTrue: [ result := l1 ]\r\t\t \t\tifFalse: [ result := l2 ]  ]\r\t\tifFalse: [(l1 size == givenSize) ifTrue: [result := l1]. (l2 size == givenSize) ifTrue: [ result := l1 ] ].\r\t\r\t^result',			#stamp : 'MagdalenaDhima 1/31/2021 13:24',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T13:31:26.245003-05:00' ],		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data remaining temp straight flushOrSuitStreak straightFlush valueStreak valueStreak2 maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tvalueStreak := self getHighestValueStreak: sorted.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak; cr.\r\t\r\tTranscript show: \'-----\'; cr.\r\tflushOrSuitStreak := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak; cr.\r\t\r\tstraightFlush := OrderedCollection new.\r\t(flushOrSuitStreak size > 4) ifTrue: [  \r\t\tstraightFlush := self getHighestStreak: flushOrSuitStreak.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush; cr.].\r\t\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t\r\tremaining := sorted reject: [:a | valueStreak includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining; cr.\r\ttemp := self getHighestValueStreak: remaining.\r\tvalueStreak2 := OrderedCollection new.\r\t(temp size >= 2) ifTrue: [ (temp size -1) to: (temp size) do: [ :i | valueStreak2 add: (temp at: i ) ] ].\r\t\r\t(valueStreak size == 3 & (valueStreak2 size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreak2 )].\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t(valueStreak size == 2 & (valueStreak2 size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreak2 )].\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t^sorted\r\t\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 11:07',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted1.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak1b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp1 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 13:31',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T13:32:39.984003-05:00' ],		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sort:',			#protocol : #sorting,			#sourceCode : 'sort: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| threeDigits twoDigits sorted aces |\r\r\t\rthreeDigits := SortedCollection new. \rtwoDigits := SortedCollection new.\r\r1 to: 9 do: [ :i | ((shuf at: i) size == 3) ifTrue: [threeDigits add: (shuf at: i)] ifFalse: [twoDigits add: (shuf at: i)]. ].\r\rsorted := (twoDigits asArray) , (threeDigits asArray).\races := sorted select: [:a |  (a copyFrom: 1 to: (a size-1)) asNumber == 1 ].\rsorted := sorted reject: [:a |  (a copyFrom: 1 to: (a size-1)) asNumber == 1 ].\rsorted := sorted , aces.\rTranscript show: sorted; cr.\r^sorted',			#stamp : 'MagdalenaDhima 1/31/2021 12:13',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sort:',			#protocol : #sorting,			#sourceCode : 'sort: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| threeDigits twoDigits sorted aces |\r\r\t\rthreeDigits := SortedCollection new. \rtwoDigits := SortedCollection new.\r\r1 to: (shuf size) do: [ :i | ((shuf at: i) size == 3) ifTrue: [threeDigits add: (shuf at: i)] ifFalse: [twoDigits add: (shuf at: i)]. ].\r\rsorted := (twoDigits asArray) , (threeDigits asArray).\races := sorted select: [:a |  (a copyFrom: 1 to: (a size-1)) asNumber == 1 ].\rsorted := sorted reject: [:a |  (a copyFrom: 1 to: (a size-1)) asNumber == 1 ].\rsorted := sorted , aces.\rTranscript show: sorted; cr.\r^sorted',			#stamp : 'MagdalenaDhima 1/31/2021 13:32',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T13:40:48.109003-05:00' ],		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted1.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak1b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp1 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 13:31',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted1.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak1b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 13:40',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T13:42:17.368003-05:00' ],		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted1.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak1b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 13:40',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted1.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 13:42',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T13:43:43.320003-05:00' ],		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted1.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 13:42',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted1.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tTranscript show: valueStreak2b; cr.\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 13:43',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T13:44:22.249003-05:00' ],		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted1.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tTranscript show: valueStreak2b; cr.\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 13:43',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted1.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\tTranscript show: valueStreak2b; cr.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 13:44',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T13:46:04.543003-05:00' ],		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted1.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\tTranscript show: valueStreak2b; cr.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 13:44',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted1.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\tTranscript show: valueStreak2b; cr.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 13:46',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T13:46:27.708003-05:00' ],		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted1.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\tTranscript show: valueStreak2b; cr.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 13:46',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted1.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\tTranscript show: valueStreak; cr.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 13:46',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T13:46:46.689003-05:00' ],		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted1.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t\tTranscript show: valueStreak; cr.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 13:46',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted1.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\tTranscript show: valueStreakb; cr.\r\t\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 13:46',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T13:49:05.292003-05:00' ],		#prior : OmReference [ '22' ],		#self : OmReference [ '23' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted1.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\tTranscript show: valueStreakb; cr.\r\t\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 13:46',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted1.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tTranscript show: valueStreakb; cr.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 13:49',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T13:52:13.818003-05:00' ],		#prior : OmReference [ '23' ],		#self : OmReference [ '24' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted1.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tTranscript show: valueStreakb; cr.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 13:49',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted1.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tTranscript show: temp2 ; cr.\r\tTranscript show: valueStreakb; cr.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 13:52',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T13:56:31.141003-05:00' ],		#prior : OmReference [ '24' ],		#self : OmReference [ '25' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted1.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tTranscript show: temp2 ; cr.\r\tTranscript show: valueStreakb; cr.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 13:52',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted1.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tTranscript show: temp2 ; cr.\r\tTranscript show: valueStreakb; cr.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 13:56',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T13:57:01.775003-05:00' ],		#prior : OmReference [ '25' ],		#self : OmReference [ '26' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted1.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tTranscript show: temp2 ; cr.\r\tTranscript show: valueStreakb; cr.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 13:56',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted1.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tTranscript show: temp2 ; cr.\r\tTranscript show: valueStreak2b; cr.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 13:56',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T14:00:47.224003-05:00' ],		#prior : OmReference [ '26' ],		#self : OmReference [ '27' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #'as yet unclassified',			#sourceCode : 'sizeCheck: givenSize firstList: l1  secondList: l2\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| result |\r\tresult := OrderedCollection new.\r\t(l1 size == givenSize & (l2 size == givenSize)) ifTrue: [ \r\t\t( (l1 includes: 1 | (l1 max asNumber > l2 max asNumber)) & (l2 includes: 1) not ) \r\t\t\t\tifTrue: [ result := l1 ]\r\t\t \t\tifFalse: [ result := l2 ]  ]\r\t\tifFalse: [(l1 size == givenSize) ifTrue: [result := l1]. (l2 size == givenSize) ifTrue: [ result := l1 ] ].\r\t\r\t^result',			#stamp : 'MagdalenaDhima 1/31/2021 13:24',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #'as yet unclassified',			#sourceCode : 'sizeCheck: givenSize firstList: l1  secondList: l2\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| result |\r\tresult := OrderedCollection new.\r\t(l1 size == givenSize & (l2 size == givenSize)) ifTrue: [ \r\t\t( (l1 includes: 1 | (l1 asArray max asNumber > l2 asArray max asNumber)) & (l2 includes: 1) not ) \r\t\t\t\tifTrue: [ result := l1 ]\r\t\t \t\tifFalse: [ result := l2 ]  ]\r\t\tifFalse: [(l1 size == givenSize) ifTrue: [result := l1]. (l2 size == givenSize) ifTrue: [ result := l1 ] ].\r\t\r\t^result',			#stamp : 'MagdalenaDhima 1/31/2021 14:00',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T14:07:11.182003-05:00' ],		#prior : OmReference [ '27' ],		#self : OmReference [ '28' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #'as yet unclassified',			#sourceCode : 'sizeCheck: givenSize firstList: l1  secondList: l2\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| result |\r\tresult := OrderedCollection new.\r\t(l1 size == givenSize & (l2 size == givenSize)) ifTrue: [ \r\t\t( (l1 includes: 1 | (l1 asArray max asNumber > l2 asArray max asNumber)) & (l2 includes: 1) not ) \r\t\t\t\tifTrue: [ result := l1 ]\r\t\t \t\tifFalse: [ result := l2 ]  ]\r\t\tifFalse: [(l1 size == givenSize) ifTrue: [result := l1]. (l2 size == givenSize) ifTrue: [ result := l1 ] ].\r\t\r\t^result',			#stamp : 'MagdalenaDhima 1/31/2021 14:00',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #'as yet unclassified',			#sourceCode : 'sizeCheck: givenSize firstList: l1  secondList: l2\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| result l1_max l2_max |\r\t\r\tl1_max := 0. l2_max := 0.\r\t(l1 isEmpty not) ifTrue: [ l1_max := l1 inject: 0 into: [:a :c | (a asNumber > c asNumber )] ].\r\t(l2 isEmpty not) ifTrue: [ l2_max := l2 inject: 0 into: [:a :c | (a asNumber > c asNumber )] ].\r\t\r\tresult := OrderedCollection new.\r\t(l1 size == givenSize & (l2 size == givenSize)) ifTrue: [ \r\t\t( (l1 includes: 1 | (l1_max > l2_max)) & (l2 includes: 1) not ) \r\t\t\t\tifTrue: [ result := l1 ]\r\t\t \t\tifFalse: [ result := l2 ]  ]\r\t\tifFalse: [(l1 size == givenSize) ifTrue: [result := l1]. (l2 size == givenSize) ifTrue: [ result := l1 ] ].\r\t\r\t^result',			#stamp : 'MagdalenaDhima 1/31/2021 14:07',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T14:08:29.758003-05:00' ],		#prior : OmReference [ '28' ],		#self : OmReference [ '29' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #'as yet unclassified',			#sourceCode : 'sizeCheck: givenSize firstList: l1  secondList: l2\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| result l1_max l2_max |\r\t\r\tl1_max := 0. l2_max := 0.\r\t(l1 isEmpty not) ifTrue: [ l1_max := l1 inject: 0 into: [:a :c | (a asNumber > c asNumber )] ].\r\t(l2 isEmpty not) ifTrue: [ l2_max := l2 inject: 0 into: [:a :c | (a asNumber > c asNumber )] ].\r\t\r\tresult := OrderedCollection new.\r\t(l1 size == givenSize & (l2 size == givenSize)) ifTrue: [ \r\t\t( (l1 includes: 1 | (l1_max > l2_max)) & (l2 includes: 1) not ) \r\t\t\t\tifTrue: [ result := l1 ]\r\t\t \t\tifFalse: [ result := l2 ]  ]\r\t\tifFalse: [(l1 size == givenSize) ifTrue: [result := l1]. (l2 size == givenSize) ifTrue: [ result := l1 ] ].\r\t\r\t^result',			#stamp : 'MagdalenaDhima 1/31/2021 14:07',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #'as yet unclassified',			#sourceCode : 'sizeCheck: givenSize firstList: l1  secondList: l2\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| result l1_max l2_max |\r\t\r\tl1_max := 0. l2_max := 0.\r\t(l1 isEmpty not) ifTrue: [ l1_max := l1 inject: 0 into: [:a :c | Transcript show: a class. (a > c )] ].\r\t(l2 isEmpty not) ifTrue: [ l2_max := l2 inject: 0 into: [:a :c | (a > c )] ].\r\t\r\tresult := OrderedCollection new.\r\t(l1 size == givenSize & (l2 size == givenSize)) ifTrue: [ \r\t\t( (l1 includes: 1 | (l1_max > l2_max)) & (l2 includes: 1) not ) \r\t\t\t\tifTrue: [ result := l1 ]\r\t\t \t\tifFalse: [ result := l2 ]  ]\r\t\tifFalse: [(l1 size == givenSize) ifTrue: [result := l1]. (l2 size == givenSize) ifTrue: [ result := l1 ] ].\r\t\r\t^result',			#stamp : 'MagdalenaDhima 1/31/2021 14:08',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T14:08:50.648003-05:00' ],		#prior : OmReference [ '29' ],		#self : OmReference [ '30' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #'as yet unclassified',			#sourceCode : 'sizeCheck: givenSize firstList: l1  secondList: l2\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| result l1_max l2_max |\r\t\r\tl1_max := 0. l2_max := 0.\r\t(l1 isEmpty not) ifTrue: [ l1_max := l1 inject: 0 into: [:a :c | Transcript show: a class. (a > c )] ].\r\t(l2 isEmpty not) ifTrue: [ l2_max := l2 inject: 0 into: [:a :c | (a > c )] ].\r\t\r\tresult := OrderedCollection new.\r\t(l1 size == givenSize & (l2 size == givenSize)) ifTrue: [ \r\t\t( (l1 includes: 1 | (l1_max > l2_max)) & (l2 includes: 1) not ) \r\t\t\t\tifTrue: [ result := l1 ]\r\t\t \t\tifFalse: [ result := l2 ]  ]\r\t\tifFalse: [(l1 size == givenSize) ifTrue: [result := l1]. (l2 size == givenSize) ifTrue: [ result := l1 ] ].\r\t\r\t^result',			#stamp : 'MagdalenaDhima 1/31/2021 14:08',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #'as yet unclassified',			#sourceCode : 'sizeCheck: givenSize firstList: l1  secondList: l2\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| result l1_max l2_max |\r\t\r\tl1_max := 0. l2_max := 0.\r\t(l1 isEmpty not) ifTrue: [ l1_max := l1 inject: 0 into: [:a :c | (a > c )] ].\r\t(l2 isEmpty not) ifTrue: [ l2_max := l2 inject: 0 into: [:a :c | (a > c )] ].\r\t\r\tresult := OrderedCollection new.\r\t(l1 size == givenSize & (l2 size == givenSize)) ifTrue: [ \r\t\t( (l1 includes: 1 | (l1_max > l2_max)) & (l2 includes: 1) not ) \r\t\t\t\tifTrue: [ result := l1 ]\r\t\t \t\tifFalse: [ result := l2 ]  ]\r\t\tifFalse: [(l1 size == givenSize) ifTrue: [result := l1]. (l2 size == givenSize) ifTrue: [ result := l1 ] ].\r\t\r\t^result',			#stamp : 'MagdalenaDhima 1/31/2021 14:08',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T14:10:29.968003-05:00' ],		#prior : OmReference [ '30' ],		#self : OmReference [ '31' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #'as yet unclassified',			#sourceCode : 'sizeCheck: givenSize firstList: l1  secondList: l2\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| result l1_max l2_max |\r\t\r\tl1_max := 0. l2_max := 0.\r\t(l1 isEmpty not) ifTrue: [ l1_max := l1 inject: 0 into: [:a :c | (a > c )] ].\r\t(l2 isEmpty not) ifTrue: [ l2_max := l2 inject: 0 into: [:a :c | (a > c )] ].\r\t\r\tresult := OrderedCollection new.\r\t(l1 size == givenSize & (l2 size == givenSize)) ifTrue: [ \r\t\t( (l1 includes: 1 | (l1_max > l2_max)) & (l2 includes: 1) not ) \r\t\t\t\tifTrue: [ result := l1 ]\r\t\t \t\tifFalse: [ result := l2 ]  ]\r\t\tifFalse: [(l1 size == givenSize) ifTrue: [result := l1]. (l2 size == givenSize) ifTrue: [ result := l1 ] ].\r\t\r\t^result',			#stamp : 'MagdalenaDhima 1/31/2021 14:08',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #'as yet unclassified',			#sourceCode : 'sizeCheck: givenSize firstList: l1  secondList: l2\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| result l1_max l2_max |\r\t\r\tl1_max := 0. l2_max := 0.\r\t(l1 isEmpty not) ifTrue: [ l1_max := l1 inject: 0 into: [:a :c | (a asNumber > c asNumber) ifTrue: [a]\r   ifFalse: [c]]].\r\t(l2 isEmpty not) ifTrue: [ l2_max := l2 inject: 0 into: [:a :c | (a asNumber > c asNumber) ifTrue: [a]\r   ifFalse: [c]]].\r\tresult := OrderedCollection new.\r\t(l1 size == givenSize & (l2 size == givenSize)) ifTrue: [ \r\t\t( (l1 includes: 1 | (l1_max > l2_max)) & (l2 includes: 1) not ) \r\t\t\t\tifTrue: [ result := l1 ]\r\t\t \t\tifFalse: [ result := l2 ]  ]\r\t\tifFalse: [(l1 size == givenSize) ifTrue: [result := l1]. (l2 size == givenSize) ifTrue: [ result := l1 ] ].\r\t\r\t^result',			#stamp : 'MagdalenaDhima 1/31/2021 14:10',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T14:11:42.846003-05:00' ],		#prior : OmReference [ '31' ],		#self : OmReference [ '32' ]	},	#content : EpCompositeRefactoring {		#childrenRefactorings : [ ]	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#prior : OmReference [ '32' ],		#self : OmReference [ '33' ],		#time : DateAndTime [ '2021-01-31T14:11:42.957003-05:00' ],		#trigger : @3	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #'as yet unclassified',			#sourceCode : 'sizeCheck: givenSize firstList: l1 secondList: l2\r\t"comment stating purpose of instance-side message"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| result l1_max l2_max |\r\tl1_max := 0.\r\tl2_max := 0.\r\tl1 isNotEmpty\r\t\tifTrue: [ l1_max := l1\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\ta asNumber > c asNumber\r\t\t\t\t\t\tifTrue: [ a ]\r\t\t\t\t\t\tifFalse: [ c ] ] ].\r\tl2 isEmpty not\r\t\tifTrue: [ l2_max := l2\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\ta asNumber > c asNumber\r\t\t\t\t\t\tifTrue: [ a ]\r\t\t\t\t\t\tifFalse: [ c ] ] ].\r\tresult := OrderedCollection new.\r\tl1 size == givenSize & (l2 size == givenSize)\r\t\tifTrue: [ (l1 includes: 1 | (l1_max > l2_max)) & (l2 includes: 1) not\r\t\t\t\tifTrue: [ result := l1 ]\r\t\t\t\tifFalse: [ result := l2 ] ]\r\t\tifFalse: [ l1 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ].\r\t\t\tl2 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ] ].\r\t^ result',			#stamp : 'MagdalenaDhima 1/31/2021 14:11',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #accessing,			#sourceCode : 'sizeCheck: givenSize firstList: l1 secondList: l2\r\t"comment stating purpose of instance-side message"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| result l1_max l2_max |\r\tl1_max := 0.\r\tl2_max := 0.\r\tl1 isNotEmpty\r\t\tifTrue: [ l1_max := l1\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\ta asNumber > c asNumber\r\t\t\t\t\t\tifTrue: [ a ]\r\t\t\t\t\t\tifFalse: [ c ] ] ].\r\tl2 isEmpty not\r\t\tifTrue: [ l2_max := l2\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\ta asNumber > c asNumber\r\t\t\t\t\t\tifTrue: [ a ]\r\t\t\t\t\t\tifFalse: [ c ] ] ].\r\tresult := OrderedCollection new.\r\tl1 size == givenSize & (l2 size == givenSize)\r\t\tifTrue: [ (l1 includes: 1 | (l1_max > l2_max)) & (l2 includes: 1) not\r\t\t\t\tifTrue: [ result := l1 ]\r\t\t\t\tifFalse: [ result := l2 ] ]\r\t\tifFalse: [ l1 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ].\r\t\t\tl2 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ] ].\r\t^ result',			#stamp : 'MagdalenaDhima 1/31/2021 14:11',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#prior : OmReference [ '33' ],		#self : OmReference [ '34' ],		#time : DateAndTime [ '2021-01-31T14:11:42.995003-05:00' ],		#trigger : OmReference [ '32' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #accessing,			#sourceCode : 'sizeCheck: givenSize firstList: l1  secondList: l2\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| result l1_max l2_max |\r\t\r\tl1_max := 0. l2_max := 0.\r\t(l1 isEmpty not) ifTrue: [ l1_max := l1 inject: 0 into: [:a :c | (a asNumber > c asNumber) ifTrue: [a]\r   ifFalse: [c]]].\r\t(l2 isEmpty not) ifTrue: [ l2_max := l2 inject: 0 into: [:a :c | (a asNumber > c asNumber) ifTrue: [a]\r   ifFalse: [c]]].\r\tresult := OrderedCollection new.\r\t(l1 size == givenSize & (l2 size == givenSize)) ifTrue: [ \r\t\t( (l1 includes: 1 | (l1_max > l2_max)) & (l2 includes: 1) not ) \r\t\t\t\tifTrue: [ result := l1 ]\r\t\t \t\tifFalse: [ result := l2 ]  ]\r\t\tifFalse: [(l1 size == givenSize) ifTrue: [result := l1]. (l2 size == givenSize) ifTrue: [ result := l1 ] ].\r\t\r\t^result',			#stamp : 'MagdalenaDhima 1/31/2021 14:10',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #accessing,			#sourceCode : 'sizeCheck: givenSize firstList: l1 secondList: l2\r\t"comment stating purpose of instance-side message"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| result l1_max l2_max |\r\tl1_max := 0.\r\tl2_max := 0.\r\tl1 isNotEmpty\r\t\tifTrue: [ l1_max := l1\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\ta asNumber > c asNumber\r\t\t\t\t\t\tifTrue: [ a ]\r\t\t\t\t\t\tifFalse: [ c ] ] ].\r\tl2 isEmpty not\r\t\tifTrue: [ l2_max := l2\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\ta asNumber > c asNumber\r\t\t\t\t\t\tifTrue: [ a ]\r\t\t\t\t\t\tifFalse: [ c ] ] ].\r\tresult := OrderedCollection new.\r\tl1 size == givenSize & (l2 size == givenSize)\r\t\tifTrue: [ (l1 includes: 1 | (l1_max > l2_max)) & (l2 includes: 1) not\r\t\t\t\tifTrue: [ result := l1 ]\r\t\t\t\tifFalse: [ result := l2 ] ]\r\t\tifFalse: [ l1 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ].\r\t\t\tl2 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ] ].\r\t^ result',			#stamp : 'MagdalenaDhima 1/31/2021 14:11',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T14:12:05.957003-05:00' ],		#prior : OmReference [ '34' ],		#self : OmReference [ '35' ]	},	#content : EpCompositeRefactoring {		#childrenRefactorings : [ ]	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#prior : OmReference [ '35' ],		#self : OmReference [ '36' ],		#time : DateAndTime [ '2021-01-31T14:12:06.065003-05:00' ],		#trigger : @3	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #accessing,			#sourceCode : 'sizeCheck: givenSize firstList: l1 secondList: l2\r\t"comment stating purpose of instance-side message"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| result l1_max l2_max |\r\tl1_max := 0.\r\tl2_max := 0.\r\tl1 isNotEmpty\r\t\tifTrue: [ l1_max := l1\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\ta asNumber > c asNumber\r\t\t\t\t\t\tifTrue: [ a ]\r\t\t\t\t\t\tifFalse: [ c ] ] ].\r\tl2 isEmpty not\r\t\tifTrue: [ l2_max := l2\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\ta asNumber > c asNumber\r\t\t\t\t\t\tifTrue: [ a ]\r\t\t\t\t\t\tifFalse: [ c ] ] ].\r\tresult := OrderedCollection new.\r\tl1 size == givenSize & (l2 size == givenSize)\r\t\tifTrue: [ (l1 includes: 1 | (l1_max > l2_max)) & (l2 includes: 1) not\r\t\t\t\tifTrue: [ result := l1 ]\r\t\t\t\tifFalse: [ result := l2 ] ]\r\t\tifFalse: [ l1 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ].\r\t\t\tl2 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ] ].\r\t^ result',			#stamp : 'MagdalenaDhima 1/31/2021 14:11',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #accessing,			#sourceCode : 'sizeCheck: givenSize firstList: l1 secondList: l2\r\t"comment stating purpose of instance-side message"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| result l1_max l2_max |\r\tl1_max := 0.\r\tl2_max := 0.\r\tl1 isNotEmpty\r\t\tifTrue: [ l1_max := l1\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\ta asNumber > c asNumber\r\t\t\t\t\t\tifTrue: [ a ]\r\t\t\t\t\t\tifFalse: [ c ] ] ].\r\tl2 isEmpty\r\t\tifFalse: [ l2_max := l2\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\ta asNumber > c asNumber\r\t\t\t\t\t\tifTrue: [ a ]\r\t\t\t\t\t\tifFalse: [ c ] ] ].\r\tresult := OrderedCollection new.\r\tl1 size == givenSize & (l2 size == givenSize)\r\t\tifTrue: [ (l1 includes: 1 | (l1_max > l2_max)) & (l2 includes: 1) not\r\t\t\t\tifTrue: [ result := l1 ]\r\t\t\t\tifFalse: [ result := l2 ] ]\r\t\tifFalse: [ l1 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ].\r\t\t\tl2 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ] ].\r\t^ result',			#stamp : 'MagdalenaDhima 1/31/2021 14:12',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T14:12:23.398003-05:00' ],		#prior : OmReference [ '36' ],		#self : OmReference [ '37' ]	},	#content : EpCompositeRefactoring {		#childrenRefactorings : [ ]	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#prior : OmReference [ '37' ],		#self : OmReference [ '38' ],		#time : DateAndTime [ '2021-01-31T14:12:23.506003-05:00' ],		#trigger : @3	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #accessing,			#sourceCode : 'sizeCheck: givenSize firstList: l1 secondList: l2\r\t"comment stating purpose of instance-side message"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| result l1_max l2_max |\r\tl1_max := 0.\r\tl2_max := 0.\r\tl1 isNotEmpty\r\t\tifTrue: [ l1_max := l1\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\ta asNumber > c asNumber\r\t\t\t\t\t\tifTrue: [ a ]\r\t\t\t\t\t\tifFalse: [ c ] ] ].\r\tl2 isEmpty\r\t\tifFalse: [ l2_max := l2\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\ta asNumber > c asNumber\r\t\t\t\t\t\tifTrue: [ a ]\r\t\t\t\t\t\tifFalse: [ c ] ] ].\r\tresult := OrderedCollection new.\r\tl1 size == givenSize & (l2 size == givenSize)\r\t\tifTrue: [ (l1 includes: 1 | (l1_max > l2_max)) & (l2 includes: 1) not\r\t\t\t\tifTrue: [ result := l1 ]\r\t\t\t\tifFalse: [ result := l2 ] ]\r\t\tifFalse: [ l1 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ].\r\t\t\tl2 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ] ].\r\t^ result',			#stamp : 'MagdalenaDhima 1/31/2021 14:12',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #accessing,			#sourceCode : 'sizeCheck: givenSize firstList: l1 secondList: l2\r\t"comment stating purpose of instance-side message"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| result l1_max l2_max |\r\tl1_max := 0.\r\tl2_max := 0.\r\tl1 isNotEmpty\r\t\tifTrue: [ l1_max := l1\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\ta asNumber > c asNumber\r\t\t\t\t\t\tifTrue: [ a ]\r\t\t\t\t\t\tifFalse: [ c ] ] ].\r\tl2 isEmpty\r\t\tifFalse: [ l2_max := l2\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\ta asNumber > c asNumber\r\t\t\t\t\t\tifTrue: [ a ]\r\t\t\t\t\t\tifFalse: [ c ] ] ].\r\tresult := OrderedCollection new.\r\tl1 size == givenSize & (l2 size == givenSize)\r\t\tifTrue: [ result := (l1 includes: 1 | (l1_max > l2_max))\r\t\t\t\t& (l2 includes: 1) not\r\t\t\t\tifTrue: [ l1 ]\r\t\t\t\tifFalse: [ l2 ] ]\r\t\tifFalse: [ l1 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ].\r\t\t\tl2 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ] ].\r\t^ result',			#stamp : 'MagdalenaDhima 1/31/2021 14:12',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T14:12:59.211003-05:00' ],		#prior : OmReference [ '38' ],		#self : OmReference [ '39' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #accessing,			#sourceCode : 'sizeCheck: givenSize firstList: l1 secondList: l2\r\t"comment stating purpose of instance-side message"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| result l1_max l2_max |\r\tl1_max := 0.\r\tl2_max := 0.\r\tl1 isNotEmpty\r\t\tifTrue: [ l1_max := l1\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\ta asNumber > c asNumber\r\t\t\t\t\t\tifTrue: [ a ]\r\t\t\t\t\t\tifFalse: [ c ] ] ].\r\tl2 isEmpty\r\t\tifFalse: [ l2_max := l2\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\ta asNumber > c asNumber\r\t\t\t\t\t\tifTrue: [ a ]\r\t\t\t\t\t\tifFalse: [ c ] ] ].\r\tresult := OrderedCollection new.\r\tl1 size == givenSize & (l2 size == givenSize)\r\t\tifTrue: [ result := (l1 includes: 1 | (l1_max > l2_max))\r\t\t\t\t& (l2 includes: 1) not\r\t\t\t\tifTrue: [ l1 ]\r\t\t\t\tifFalse: [ l2 ] ]\r\t\tifFalse: [ l1 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ].\r\t\t\tl2 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ] ].\r\t^ result',			#stamp : 'MagdalenaDhima 1/31/2021 14:12',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #accessing,			#sourceCode : 'sizeCheck: givenSize firstList: l1 secondList: l2\r\t"comment stating purpose of instance-side message"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| result l1_max l2_max |\r\tl1_max := 0.\r\tl2_max := 0.\r\tl1 isNotEmpty\r\t\tifTrue: [ l1_max := l1\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\ta asNumber > c asNumber\r\t\t\t\t\t\tifTrue: [ a ]\r\t\t\t\t\t\tifFalse: [ c ] ] ].\r\tl2 isEmpty\r\t\tifFalse: [ l2_max := l2\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\ta asNumber > c asNumber\r\t\t\t\t\t\tifTrue: [ a ]\r\t\t\t\t\t\tifFalse: [ c ] ] ].\r\t\t\t\t\r\tresult := OrderedCollection new.\r\tl1 size == givenSize & (l2 size == givenSize)\r\t\tifTrue: [ (l1 includes: 1 | (l1_max > l2_max)) & ( (l2 includes: 1) not )\r\t\t\t\tifTrue: [ result := l1 ]\r\t\t\t\tifFalse: [ result := l2 ] ]\r\t\tifFalse: [ l1 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ].\r\t\t\tl2 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ] ].\r\t^ result',			#stamp : 'MagdalenaDhima 1/31/2021 14:12',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T14:13:08.601003-05:00' ],		#prior : OmReference [ '39' ],		#self : OmReference [ '40' ]	},	#content : EpCompositeRefactoring {		#childrenRefactorings : [ ]	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#prior : OmReference [ '40' ],		#self : OmReference [ '41' ],		#time : DateAndTime [ '2021-01-31T14:13:08.713003-05:00' ],		#trigger : @3	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #accessing,			#sourceCode : 'sizeCheck: givenSize firstList: l1 secondList: l2\r\t"comment stating purpose of instance-side message"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| result l1_max l2_max |\r\tl1_max := 0.\r\tl2_max := 0.\r\tl1 isNotEmpty\r\t\tifTrue: [ l1_max := l1\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\ta asNumber > c asNumber\r\t\t\t\t\t\tifTrue: [ a ]\r\t\t\t\t\t\tifFalse: [ c ] ] ].\r\tl2 isEmpty\r\t\tifFalse: [ l2_max := l2\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\ta asNumber > c asNumber\r\t\t\t\t\t\tifTrue: [ a ]\r\t\t\t\t\t\tifFalse: [ c ] ] ].\r\t\t\t\t\r\tresult := OrderedCollection new.\r\tl1 size == givenSize & (l2 size == givenSize)\r\t\tifTrue: [ (l1 includes: 1 | (l1_max > l2_max)) & ( (l2 includes: 1) not )\r\t\t\t\tifTrue: [ result := l1 ]\r\t\t\t\tifFalse: [ result := l2 ] ]\r\t\tifFalse: [ l1 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ].\r\t\t\tl2 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ] ].\r\t^ result',			#stamp : 'MagdalenaDhima 1/31/2021 14:12',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #accessing,			#sourceCode : 'sizeCheck: givenSize firstList: l1 secondList: l2\r\t"comment stating purpose of instance-side message"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| result l1_max l2_max |\r\tl1_max := 0.\r\tl2_max := 0.\r\tl1 isNotEmpty\r\t\tifTrue: [ l1_max := l1\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\ta asNumber > c asNumber\r\t\t\t\t\t\tifTrue: [ a ]\r\t\t\t\t\t\tifFalse: [ c ] ] ].\r\tl2 isEmpty\r\t\tifFalse: [ l2_max := l2\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\ta asNumber > c asNumber\r\t\t\t\t\t\tifTrue: [ a ]\r\t\t\t\t\t\tifFalse: [ c ] ] ].\r\tresult := OrderedCollection new.\r\tl1 size == givenSize & (l2 size == givenSize)\r\t\tifTrue: [ result := (l1 includes: 1 | (l1_max > l2_max))\r\t\t\t\t& (l2 includes: 1) not\r\t\t\t\tifTrue: [ l1 ]\r\t\t\t\tifFalse: [ l2 ] ]\r\t\tifFalse: [ l1 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ].\r\t\t\tl2 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ] ].\r\t^ result',			#stamp : 'MagdalenaDhima 1/31/2021 14:13',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T14:14:25.675003-05:00' ],		#prior : OmReference [ '41' ],		#self : OmReference [ '42' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #accessing,			#sourceCode : 'sizeCheck: givenSize firstList: l1 secondList: l2\r\t"comment stating purpose of instance-side message"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| result l1_max l2_max |\r\tl1_max := 0.\r\tl2_max := 0.\r\tl1 isNotEmpty\r\t\tifTrue: [ l1_max := l1\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\ta asNumber > c asNumber\r\t\t\t\t\t\tifTrue: [ a ]\r\t\t\t\t\t\tifFalse: [ c ] ] ].\r\tl2 isEmpty\r\t\tifFalse: [ l2_max := l2\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\ta asNumber > c asNumber\r\t\t\t\t\t\tifTrue: [ a ]\r\t\t\t\t\t\tifFalse: [ c ] ] ].\r\tresult := OrderedCollection new.\r\tl1 size == givenSize & (l2 size == givenSize)\r\t\tifTrue: [ result := (l1 includes: 1 | (l1_max > l2_max))\r\t\t\t\t& (l2 includes: 1) not\r\t\t\t\tifTrue: [ l1 ]\r\t\t\t\tifFalse: [ l2 ] ]\r\t\tifFalse: [ l1 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ].\r\t\t\tl2 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ] ].\r\t^ result',			#stamp : 'MagdalenaDhima 1/31/2021 14:13',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #accessing,			#sourceCode : 'sizeCheck: givenSize firstList: l1 secondList: l2\r\t"comment stating purpose of instance-side message"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| result l1_max l2_max |\r\tl1_max := 0.\r\tl2_max := 0.\r\tl1 isNotEmpty\r\t\tifTrue: [ l1_max := l1\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\ta asNumber > c asNumber\r\t\t\t\t\t\tifTrue: [ a ]\r\t\t\t\t\t\tifFalse: [ c ] ] ].\r\tl2 isEmpty\r\t\tifFalse: [ l2_max := l2\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\ta asNumber > c asNumber\r\t\t\t\t\t\tifTrue: [ a ]\r\t\t\t\t\t\tifFalse: [ c ] ] ].\r\tresult := OrderedCollection new.\r\tl1 size == givenSize & (l2 size == givenSize)\r\t\tifTrue: [ result := (l1 includes: 1 | (l1_max > l2_max))\r\t\t\t\t& (l2 includes: 1) not\r\t\t\t\tifTrue: [ l1 ]\r\t\t\t\tifFalse: [ l2 ] ]\r\t\tifFalse: [ l1 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ].\r\t\t\tl2 size == givenSize\r\t\t\t\tifTrue: [ result := l2 ] ].\r\t^ result',			#stamp : 'MagdalenaDhima 1/31/2021 14:14',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T14:16:06.621003-05:00' ],		#prior : OmReference [ '42' ],		#self : OmReference [ '43' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #accessing,			#sourceCode : 'sizeCheck: givenSize firstList: l1 secondList: l2\r\t"comment stating purpose of instance-side message"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| result l1_max l2_max |\r\tl1_max := 0.\r\tl2_max := 0.\r\tl1 isNotEmpty\r\t\tifTrue: [ l1_max := l1\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\ta asNumber > c asNumber\r\t\t\t\t\t\tifTrue: [ a ]\r\t\t\t\t\t\tifFalse: [ c ] ] ].\r\tl2 isEmpty\r\t\tifFalse: [ l2_max := l2\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\ta asNumber > c asNumber\r\t\t\t\t\t\tifTrue: [ a ]\r\t\t\t\t\t\tifFalse: [ c ] ] ].\r\tresult := OrderedCollection new.\r\tl1 size == givenSize & (l2 size == givenSize)\r\t\tifTrue: [ result := (l1 includes: 1 | (l1_max > l2_max))\r\t\t\t\t& (l2 includes: 1) not\r\t\t\t\tifTrue: [ l1 ]\r\t\t\t\tifFalse: [ l2 ] ]\r\t\tifFalse: [ l1 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ].\r\t\t\tl2 size == givenSize\r\t\t\t\tifTrue: [ result := l2 ] ].\r\t^ result',			#stamp : 'MagdalenaDhima 1/31/2021 14:14',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #accessing,			#sourceCode : 'sizeCheck: givenSize firstList: l1 secondList: l2\r\t"comment stating purpose of instance-side message"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| result l1_max l2_max |\r\tl1_max := 0.\r\tl2_max := 0.\r\tl1 isNotEmpty\r\t\tifTrue: [ l1_max := l1\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\ta asNumber > c asNumber\r\t\t\t\t\t\tifTrue: [ a ]\r\t\t\t\t\t\tifFalse: [ c ] ] ].\r\tl2 isEmpty\r\t\tifFalse: [ l2_max := l2\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\ta asNumber > c asNumber\r\t\t\t\t\t\tifTrue: [ a ]\r\t\t\t\t\t\tifFalse: [ c ] ] ].\r\t\t\t\t\r\tTranscript show: l1_max; show: l2_max; cr.\r\tresult := OrderedCollection new.\r\tl1 size == givenSize & (l2 size == givenSize)\r\t\tifTrue: [ result := (l1 includes: 1 | (l1_max > l2_max))\r\t\t\t\t& (l2 includes: 1) not\r\t\t\t\tifTrue: [ l1 ]\r\t\t\t\tifFalse: [ l2 ] ]\r\t\tifFalse: [ l1 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ].\r\t\t\tl2 size == givenSize\r\t\t\t\tifTrue: [ result := l2 ] ].\r\t^ result',			#stamp : 'MagdalenaDhima 1/31/2021 14:16',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T14:20:16.603003-05:00' ],		#prior : OmReference [ '43' ],		#self : OmReference [ '44' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #accessing,			#sourceCode : 'sizeCheck: givenSize firstList: l1 secondList: l2\r\t"comment stating purpose of instance-side message"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| result l1_max l2_max |\r\tl1_max := 0.\r\tl2_max := 0.\r\tl1 isNotEmpty\r\t\tifTrue: [ l1_max := l1\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\ta asNumber > c asNumber\r\t\t\t\t\t\tifTrue: [ a ]\r\t\t\t\t\t\tifFalse: [ c ] ] ].\r\tl2 isEmpty\r\t\tifFalse: [ l2_max := l2\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\ta asNumber > c asNumber\r\t\t\t\t\t\tifTrue: [ a ]\r\t\t\t\t\t\tifFalse: [ c ] ] ].\r\t\t\t\t\r\tTranscript show: l1_max; show: l2_max; cr.\r\tresult := OrderedCollection new.\r\tl1 size == givenSize & (l2 size == givenSize)\r\t\tifTrue: [ result := (l1 includes: 1 | (l1_max > l2_max))\r\t\t\t\t& (l2 includes: 1) not\r\t\t\t\tifTrue: [ l1 ]\r\t\t\t\tifFalse: [ l2 ] ]\r\t\tifFalse: [ l1 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ].\r\t\t\tl2 size == givenSize\r\t\t\t\tifTrue: [ result := l2 ] ].\r\t^ result',			#stamp : 'MagdalenaDhima 1/31/2021 14:16',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #accessing,			#sourceCode : 'sizeCheck: givenSize firstList: l1 secondList: l2\r\t"comment stating purpose of instance-side message"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| result l1_max l2_max |\r\tl1_max := 0.\r\tl2_max := 0.\r\tl1 isNotEmpty\r\t\tifTrue: [ l1_max := l1\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\t(a copyFrom: 1 to: (a size-1) ) asNumber > (c copyFrom: 1 to: (c size-1) ) asNumber\r\t\t\t\t\t\tifTrue: [ (a copyFrom: 1 to: (a size-1) asNumber) ]\r\t\t\t\t\t\tifFalse: [ (c copyFrom: 1 to: (c size-1) ) asNumber ] ] ].\r\tl2 isEmpty\r\t\tifFalse: [ l2_max := l2\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\t(a copyFrom: 1 to: (a size-1) ) asNumber > (c copyFrom: 1 to: (c size-1) ) asNumber\r\t\t\t\t\t\tifTrue: [ (a copyFrom: 1 to: (a size-1) asNumber) ]\r\t\t\t\t\t\tifFalse: [ (c copyFrom: 1 to: (c size-1) ) asNumber ] ] ].\r\t\t\t\t\r\tTranscript show: l1_max; show: l2_max; cr.\r\tresult := OrderedCollection new.\r\tl1 size == givenSize & (l2 size == givenSize)\r\t\tifTrue: [ result := (l1 includes: 1 | (l1_max > l2_max))\r\t\t\t\t& (l2 includes: 1) not\r\t\t\t\tifTrue: [ l1 ]\r\t\t\t\tifFalse: [ l2 ] ]\r\t\tifFalse: [ l1 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ].\r\t\t\tl2 size == givenSize\r\t\t\t\tifTrue: [ result := l2 ] ].\r\t^ result',			#stamp : 'MagdalenaDhima 1/31/2021 14:20',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T14:22:27.824003-05:00' ],		#prior : OmReference [ '44' ],		#self : OmReference [ '45' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #accessing,			#sourceCode : 'sizeCheck: givenSize firstList: l1 secondList: l2\r\t"comment stating purpose of instance-side message"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| result l1_max l2_max |\r\tl1_max := 0.\r\tl2_max := 0.\r\tl1 isNotEmpty\r\t\tifTrue: [ l1_max := l1\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\t(a copyFrom: 1 to: (a size-1) ) asNumber > (c copyFrom: 1 to: (c size-1) ) asNumber\r\t\t\t\t\t\tifTrue: [ (a copyFrom: 1 to: (a size-1) asNumber) ]\r\t\t\t\t\t\tifFalse: [ (c copyFrom: 1 to: (c size-1) ) asNumber ] ] ].\r\tl2 isEmpty\r\t\tifFalse: [ l2_max := l2\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\t(a copyFrom: 1 to: (a size-1) ) asNumber > (c copyFrom: 1 to: (c size-1) ) asNumber\r\t\t\t\t\t\tifTrue: [ (a copyFrom: 1 to: (a size-1) asNumber) ]\r\t\t\t\t\t\tifFalse: [ (c copyFrom: 1 to: (c size-1) ) asNumber ] ] ].\r\t\t\t\t\r\tTranscript show: l1_max; show: l2_max; cr.\r\tresult := OrderedCollection new.\r\tl1 size == givenSize & (l2 size == givenSize)\r\t\tifTrue: [ result := (l1 includes: 1 | (l1_max > l2_max))\r\t\t\t\t& (l2 includes: 1) not\r\t\t\t\tifTrue: [ l1 ]\r\t\t\t\tifFalse: [ l2 ] ]\r\t\tifFalse: [ l1 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ].\r\t\t\tl2 size == givenSize\r\t\t\t\tifTrue: [ result := l2 ] ].\r\t^ result',			#stamp : 'MagdalenaDhima 1/31/2021 14:20',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #accessing,			#sourceCode : 'sizeCheck: givenSize firstList: l1 secondList: l2\r\t"comment stating purpose of instance-side message"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| result l1_max l2_max |\r\tl1_max := 0.\r\tl2_max := 0.\r\tl1 isNotEmpty\r\t\tifTrue: [ l1_max := l1\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\tTranscript show: a; cr.\r\t\t\t\t\t(a copyFrom: 1 to: (a size-1) ) asNumber > (c copyFrom: 1 to: (c size-1) ) asNumber\r\t\t\t\t\t\tifTrue: [ (a copyFrom: 1 to: (a size-1) asNumber) ]\r\t\t\t\t\t\tifFalse: [ (c copyFrom: 1 to: (c size-1) ) asNumber ] ] ].\r\tl2 isEmpty\r\t\tifFalse: [ l2_max := l2\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\t(a copyFrom: 1 to: (a size-1) ) asNumber > (c copyFrom: 1 to: (c size-1) ) asNumber\r\t\t\t\t\t\tifTrue: [ (a copyFrom: 1 to: (a size-1) asNumber) ]\r\t\t\t\t\t\tifFalse: [ (c copyFrom: 1 to: (c size-1) ) asNumber ] ] ].\r\t\t\t\t\r\tTranscript show: l1_max; show: l2_max; cr.\r\tresult := OrderedCollection new.\r\tl1 size == givenSize & (l2 size == givenSize)\r\t\tifTrue: [ result := (l1 includes: 1 | (l1_max > l2_max))\r\t\t\t\t& (l2 includes: 1) not\r\t\t\t\tifTrue: [ l1 ]\r\t\t\t\tifFalse: [ l2 ] ]\r\t\tifFalse: [ l1 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ].\r\t\t\tl2 size == givenSize\r\t\t\t\tifTrue: [ result := l2 ] ].\r\t^ result',			#stamp : 'MagdalenaDhima 1/31/2021 14:22',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T14:22:48.618003-05:00' ],		#prior : OmReference [ '45' ],		#self : OmReference [ '46' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #accessing,			#sourceCode : 'sizeCheck: givenSize firstList: l1 secondList: l2\r\t"comment stating purpose of instance-side message"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| result l1_max l2_max |\r\tl1_max := 0.\r\tl2_max := 0.\r\tl1 isNotEmpty\r\t\tifTrue: [ l1_max := l1\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\tTranscript show: a; cr.\r\t\t\t\t\t(a copyFrom: 1 to: (a size-1) ) asNumber > (c copyFrom: 1 to: (c size-1) ) asNumber\r\t\t\t\t\t\tifTrue: [ (a copyFrom: 1 to: (a size-1) asNumber) ]\r\t\t\t\t\t\tifFalse: [ (c copyFrom: 1 to: (c size-1) ) asNumber ] ] ].\r\tl2 isEmpty\r\t\tifFalse: [ l2_max := l2\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\t(a copyFrom: 1 to: (a size-1) ) asNumber > (c copyFrom: 1 to: (c size-1) ) asNumber\r\t\t\t\t\t\tifTrue: [ (a copyFrom: 1 to: (a size-1) asNumber) ]\r\t\t\t\t\t\tifFalse: [ (c copyFrom: 1 to: (c size-1) ) asNumber ] ] ].\r\t\t\t\t\r\tTranscript show: l1_max; show: l2_max; cr.\r\tresult := OrderedCollection new.\r\tl1 size == givenSize & (l2 size == givenSize)\r\t\tifTrue: [ result := (l1 includes: 1 | (l1_max > l2_max))\r\t\t\t\t& (l2 includes: 1) not\r\t\t\t\tifTrue: [ l1 ]\r\t\t\t\tifFalse: [ l2 ] ]\r\t\tifFalse: [ l1 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ].\r\t\t\tl2 size == givenSize\r\t\t\t\tifTrue: [ result := l2 ] ].\r\t^ result',			#stamp : 'MagdalenaDhima 1/31/2021 14:22',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #accessing,			#sourceCode : 'sizeCheck: givenSize firstList: l1 secondList: l2\r\t"comment stating purpose of instance-side message"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| result l1_max l2_max |\r\tl1_max := 0.\r\tl2_max := 0.\r\tl1 isNotEmpty\r\t\tifTrue: [ l1_max := l1\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\tTranscript show: c; cr.\r\t\t\t\t\t(a copyFrom: 1 to: (a size-1) ) asNumber > (c copyFrom: 1 to: (c size-1) ) asNumber\r\t\t\t\t\t\tifTrue: [ (a copyFrom: 1 to: (a size-1) asNumber) ]\r\t\t\t\t\t\tifFalse: [ (c copyFrom: 1 to: (c size-1) ) asNumber ] ] ].\r\tl2 isEmpty\r\t\tifFalse: [ l2_max := l2\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\t(a copyFrom: 1 to: (a size-1) ) asNumber > (c copyFrom: 1 to: (c size-1) ) asNumber\r\t\t\t\t\t\tifTrue: [ (a copyFrom: 1 to: (a size-1) asNumber) ]\r\t\t\t\t\t\tifFalse: [ (c copyFrom: 1 to: (c size-1) ) asNumber ] ] ].\r\t\t\t\t\r\tTranscript show: l1_max; show: l2_max; cr.\r\tresult := OrderedCollection new.\r\tl1 size == givenSize & (l2 size == givenSize)\r\t\tifTrue: [ result := (l1 includes: 1 | (l1_max > l2_max))\r\t\t\t\t& (l2 includes: 1) not\r\t\t\t\tifTrue: [ l1 ]\r\t\t\t\tifFalse: [ l2 ] ]\r\t\tifFalse: [ l1 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ].\r\t\t\tl2 size == givenSize\r\t\t\t\tifTrue: [ result := l2 ] ].\r\t^ result',			#stamp : 'MagdalenaDhima 1/31/2021 14:22',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T14:23:13.533003-05:00' ],		#prior : OmReference [ '46' ],		#self : OmReference [ '47' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #accessing,			#sourceCode : 'sizeCheck: givenSize firstList: l1 secondList: l2\r\t"comment stating purpose of instance-side message"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| result l1_max l2_max |\r\tl1_max := 0.\r\tl2_max := 0.\r\tl1 isNotEmpty\r\t\tifTrue: [ l1_max := l1\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\tTranscript show: c; cr.\r\t\t\t\t\t(a copyFrom: 1 to: (a size-1) ) asNumber > (c copyFrom: 1 to: (c size-1) ) asNumber\r\t\t\t\t\t\tifTrue: [ (a copyFrom: 1 to: (a size-1) asNumber) ]\r\t\t\t\t\t\tifFalse: [ (c copyFrom: 1 to: (c size-1) ) asNumber ] ] ].\r\tl2 isEmpty\r\t\tifFalse: [ l2_max := l2\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\t(a copyFrom: 1 to: (a size-1) ) asNumber > (c copyFrom: 1 to: (c size-1) ) asNumber\r\t\t\t\t\t\tifTrue: [ (a copyFrom: 1 to: (a size-1) asNumber) ]\r\t\t\t\t\t\tifFalse: [ (c copyFrom: 1 to: (c size-1) ) asNumber ] ] ].\r\t\t\t\t\r\tTranscript show: l1_max; show: l2_max; cr.\r\tresult := OrderedCollection new.\r\tl1 size == givenSize & (l2 size == givenSize)\r\t\tifTrue: [ result := (l1 includes: 1 | (l1_max > l2_max))\r\t\t\t\t& (l2 includes: 1) not\r\t\t\t\tifTrue: [ l1 ]\r\t\t\t\tifFalse: [ l2 ] ]\r\t\tifFalse: [ l1 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ].\r\t\t\tl2 size == givenSize\r\t\t\t\tifTrue: [ result := l2 ] ].\r\t^ result',			#stamp : 'MagdalenaDhima 1/31/2021 14:22',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #accessing,			#sourceCode : 'sizeCheck: givenSize firstList: l1 secondList: l2\r\t"comment stating purpose of instance-side message"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| result l1_max l2_max |\r\tl1_max := 0.\r\tl2_max := 0.\r\tl1 isNotEmpty\r\t\tifTrue: [ l1_max := l1\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\tTranscript show: \'h\', c; cr.\r\t\t\t\t\t(a copyFrom: 1 to: (a size-1) ) asNumber > (c copyFrom: 1 to: (c size-1) ) asNumber\r\t\t\t\t\t\tifTrue: [ (a copyFrom: 1 to: (a size-1) asNumber) ]\r\t\t\t\t\t\tifFalse: [ (c copyFrom: 1 to: (c size-1) ) asNumber ] ] ].\r\tl2 isEmpty\r\t\tifFalse: [ l2_max := l2\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\t(a copyFrom: 1 to: (a size-1) ) asNumber > (c copyFrom: 1 to: (c size-1) ) asNumber\r\t\t\t\t\t\tifTrue: [ (a copyFrom: 1 to: (a size-1) asNumber) ]\r\t\t\t\t\t\tifFalse: [ (c copyFrom: 1 to: (c size-1) ) asNumber ] ] ].\r\t\t\t\t\r\tTranscript show: l1_max; show: l2_max; cr.\r\tresult := OrderedCollection new.\r\tl1 size == givenSize & (l2 size == givenSize)\r\t\tifTrue: [ result := (l1 includes: 1 | (l1_max > l2_max))\r\t\t\t\t& (l2 includes: 1) not\r\t\t\t\tifTrue: [ l1 ]\r\t\t\t\tifFalse: [ l2 ] ]\r\t\tifFalse: [ l1 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ].\r\t\t\tl2 size == givenSize\r\t\t\t\tifTrue: [ result := l2 ] ].\r\t^ result',			#stamp : 'MagdalenaDhima 1/31/2021 14:23',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T14:23:23.676003-05:00' ],		#prior : OmReference [ '47' ],		#self : OmReference [ '48' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #accessing,			#sourceCode : 'sizeCheck: givenSize firstList: l1 secondList: l2\r\t"comment stating purpose of instance-side message"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| result l1_max l2_max |\r\tl1_max := 0.\r\tl2_max := 0.\r\tl1 isNotEmpty\r\t\tifTrue: [ l1_max := l1\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\tTranscript show: \'h\', c; cr.\r\t\t\t\t\t(a copyFrom: 1 to: (a size-1) ) asNumber > (c copyFrom: 1 to: (c size-1) ) asNumber\r\t\t\t\t\t\tifTrue: [ (a copyFrom: 1 to: (a size-1) asNumber) ]\r\t\t\t\t\t\tifFalse: [ (c copyFrom: 1 to: (c size-1) ) asNumber ] ] ].\r\tl2 isEmpty\r\t\tifFalse: [ l2_max := l2\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\t(a copyFrom: 1 to: (a size-1) ) asNumber > (c copyFrom: 1 to: (c size-1) ) asNumber\r\t\t\t\t\t\tifTrue: [ (a copyFrom: 1 to: (a size-1) asNumber) ]\r\t\t\t\t\t\tifFalse: [ (c copyFrom: 1 to: (c size-1) ) asNumber ] ] ].\r\t\t\t\t\r\tTranscript show: l1_max; show: l2_max; cr.\r\tresult := OrderedCollection new.\r\tl1 size == givenSize & (l2 size == givenSize)\r\t\tifTrue: [ result := (l1 includes: 1 | (l1_max > l2_max))\r\t\t\t\t& (l2 includes: 1) not\r\t\t\t\tifTrue: [ l1 ]\r\t\t\t\tifFalse: [ l2 ] ]\r\t\tifFalse: [ l1 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ].\r\t\t\tl2 size == givenSize\r\t\t\t\tifTrue: [ result := l2 ] ].\r\t^ result',			#stamp : 'MagdalenaDhima 1/31/2021 14:23',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #accessing,			#sourceCode : 'sizeCheck: givenSize firstList: l1 secondList: l2\r\t"comment stating purpose of instance-side message"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| result l1_max l2_max |\r\tl1_max := 0.\r\tl2_max := 0.\r\tl1 isNotEmpty\r\t\tifTrue: [ l1_max := l1\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\tTranscript show: \'h\', a; cr.\r\t\t\t\t\t(a copyFrom: 1 to: (a size-1) ) asNumber > (c copyFrom: 1 to: (c size-1) ) asNumber\r\t\t\t\t\t\tifTrue: [ (a copyFrom: 1 to: (a size-1) asNumber) ]\r\t\t\t\t\t\tifFalse: [ (c copyFrom: 1 to: (c size-1) ) asNumber ] ] ].\r\tl2 isEmpty\r\t\tifFalse: [ l2_max := l2\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\t(a copyFrom: 1 to: (a size-1) ) asNumber > (c copyFrom: 1 to: (c size-1) ) asNumber\r\t\t\t\t\t\tifTrue: [ (a copyFrom: 1 to: (a size-1) asNumber) ]\r\t\t\t\t\t\tifFalse: [ (c copyFrom: 1 to: (c size-1) ) asNumber ] ] ].\r\t\t\t\t\r\tTranscript show: l1_max; show: l2_max; cr.\r\tresult := OrderedCollection new.\r\tl1 size == givenSize & (l2 size == givenSize)\r\t\tifTrue: [ result := (l1 includes: 1 | (l1_max > l2_max))\r\t\t\t\t& (l2 includes: 1) not\r\t\t\t\tifTrue: [ l1 ]\r\t\t\t\tifFalse: [ l2 ] ]\r\t\tifFalse: [ l1 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ].\r\t\t\tl2 size == givenSize\r\t\t\t\tifTrue: [ result := l2 ] ].\r\t^ result',			#stamp : 'MagdalenaDhima 1/31/2021 14:23',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T14:26:00.724003-05:00' ],		#prior : OmReference [ '48' ],		#self : OmReference [ '49' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #accessing,			#sourceCode : 'sizeCheck: givenSize firstList: l1 secondList: l2\r\t"comment stating purpose of instance-side message"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| result l1_max l2_max |\r\tl1_max := 0.\r\tl2_max := 0.\r\tl1 isNotEmpty\r\t\tifTrue: [ l1_max := l1\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\tTranscript show: \'h\', a; cr.\r\t\t\t\t\t(a copyFrom: 1 to: (a size-1) ) asNumber > (c copyFrom: 1 to: (c size-1) ) asNumber\r\t\t\t\t\t\tifTrue: [ (a copyFrom: 1 to: (a size-1) asNumber) ]\r\t\t\t\t\t\tifFalse: [ (c copyFrom: 1 to: (c size-1) ) asNumber ] ] ].\r\tl2 isEmpty\r\t\tifFalse: [ l2_max := l2\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\t(a copyFrom: 1 to: (a size-1) ) asNumber > (c copyFrom: 1 to: (c size-1) ) asNumber\r\t\t\t\t\t\tifTrue: [ (a copyFrom: 1 to: (a size-1) asNumber) ]\r\t\t\t\t\t\tifFalse: [ (c copyFrom: 1 to: (c size-1) ) asNumber ] ] ].\r\t\t\t\t\r\tTranscript show: l1_max; show: l2_max; cr.\r\tresult := OrderedCollection new.\r\tl1 size == givenSize & (l2 size == givenSize)\r\t\tifTrue: [ result := (l1 includes: 1 | (l1_max > l2_max))\r\t\t\t\t& (l2 includes: 1) not\r\t\t\t\tifTrue: [ l1 ]\r\t\t\t\tifFalse: [ l2 ] ]\r\t\tifFalse: [ l1 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ].\r\t\t\tl2 size == givenSize\r\t\t\t\tifTrue: [ result := l2 ] ].\r\t^ result',			#stamp : 'MagdalenaDhima 1/31/2021 14:23',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #accessing,			#sourceCode : 'sizeCheck: givenSize firstList: l1 secondList: l2\r\t"comment stating purpose of instance-side message"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| result l1_max l2_max |\r\tl1_max := 0.\r\tl2_max := 0.\r\tl1 isNotEmpty\r\t\tifTrue: [ l1_max := l1\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\ta > (c copyFrom: 1 to: (c size-1) ) asNumber\r\t\t\t\t\t\tifTrue: [ a ]\r\t\t\t\t\t\tifFalse: [ (c copyFrom: 1 to: (c size-1) ) asNumber ] ] ].\r\tl2 isEmpty\r\t\tifFalse: [ l2_max := l2\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\t a > (c copyFrom: 1 to: (c size-1) ) asNumber\r\t\t\t\t\t\tifTrue: [ a ]\r\t\t\t\t\t\tifFalse: [ (c copyFrom: 1 to: (c size-1) ) asNumber ] ] ].\r\t\t\t\t\r\tTranscript show: l1_max; show: l2_max; cr.\r\tresult := OrderedCollection new.\r\tl1 size == givenSize & (l2 size == givenSize)\r\t\tifTrue: [ result := (l1 includes: 1 | (l1_max > l2_max))\r\t\t\t\t& (l2 includes: 1) not\r\t\t\t\tifTrue: [ l1 ]\r\t\t\t\tifFalse: [ l2 ] ]\r\t\tifFalse: [ l1 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ].\r\t\t\tl2 size == givenSize\r\t\t\t\tifTrue: [ result := l2 ] ].\r\t^ result',			#stamp : 'MagdalenaDhima 1/31/2021 14:26',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T14:27:05.667003-05:00' ],		#prior : OmReference [ '49' ],		#self : OmReference [ '50' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #accessing,			#sourceCode : 'sizeCheck: givenSize firstList: l1 secondList: l2\r\t"comment stating purpose of instance-side message"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| result l1_max l2_max |\r\tl1_max := 0.\r\tl2_max := 0.\r\tl1 isNotEmpty\r\t\tifTrue: [ l1_max := l1\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\ta > (c copyFrom: 1 to: (c size-1) ) asNumber\r\t\t\t\t\t\tifTrue: [ a ]\r\t\t\t\t\t\tifFalse: [ (c copyFrom: 1 to: (c size-1) ) asNumber ] ] ].\r\tl2 isEmpty\r\t\tifFalse: [ l2_max := l2\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\t a > (c copyFrom: 1 to: (c size-1) ) asNumber\r\t\t\t\t\t\tifTrue: [ a ]\r\t\t\t\t\t\tifFalse: [ (c copyFrom: 1 to: (c size-1) ) asNumber ] ] ].\r\t\t\t\t\r\tTranscript show: l1_max; show: l2_max; cr.\r\tresult := OrderedCollection new.\r\tl1 size == givenSize & (l2 size == givenSize)\r\t\tifTrue: [ result := (l1 includes: 1 | (l1_max > l2_max))\r\t\t\t\t& (l2 includes: 1) not\r\t\t\t\tifTrue: [ l1 ]\r\t\t\t\tifFalse: [ l2 ] ]\r\t\tifFalse: [ l1 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ].\r\t\t\tl2 size == givenSize\r\t\t\t\tifTrue: [ result := l2 ] ].\r\t^ result',			#stamp : 'MagdalenaDhima 1/31/2021 14:26',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #accessing,			#sourceCode : 'sizeCheck: givenSize firstList: l1 secondList: l2\r\t"comment stating purpose of instance-side message"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| result l1_max l2_max |\r\tl1_max := 0.\r\tl2_max := 0.\r\tl1 isNotEmpty\r\t\tifTrue: [ l1_max := l1\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\ta > (c copyFrom: 1 to: (c size-1) ) asNumber\r\t\t\t\t\t\tifTrue: [ a ]\r\t\t\t\t\t\tifFalse: [ (c copyFrom: 1 to: (c size-1) ) asNumber ] ] ].\r\tl2 isEmpty\r\t\tifFalse: [ l2_max := l2\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\t a > (c copyFrom: 1 to: (c size-1) ) asNumber\r\t\t\t\t\t\tifTrue: [ a ]\r\t\t\t\t\t\tifFalse: [ (c copyFrom: 1 to: (c size-1) ) asNumber ] ] ].\r\t\t\t\t\r\tTranscript show: l1_max class; show: l2_max; cr.\r\tresult := OrderedCollection new.\r\tl1 size == givenSize & (l2 size == givenSize)\r\t\tifTrue: [ result := (l1 includes: 1 | (l1_max > l2_max))\r\t\t\t\t& (l2 includes: 1) not\r\t\t\t\tifTrue: [ l1 ]\r\t\t\t\tifFalse: [ l2 ] ]\r\t\tifFalse: [ l1 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ].\r\t\t\tl2 size == givenSize\r\t\t\t\tifTrue: [ result := l2 ] ].\r\t^ result',			#stamp : 'MagdalenaDhima 1/31/2021 14:27',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T14:27:25.916003-05:00' ],		#prior : OmReference [ '50' ],		#self : OmReference [ '51' ]	},	#content : EpCompositeRefactoring {		#childrenRefactorings : [ ]	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#prior : OmReference [ '51' ],		#self : OmReference [ '52' ],		#time : DateAndTime [ '2021-01-31T14:27:26.025003-05:00' ],		#trigger : @3	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #accessing,			#sourceCode : 'sizeCheck: givenSize firstList: l1 secondList: l2\r\t"comment stating purpose of instance-side message"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| result l1_max l2_max |\r\tl1_max := 0.\r\tl2_max := 0.\r\tl1 isNotEmpty\r\t\tifTrue: [ l1_max := l1\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\ta > (c copyFrom: 1 to: (c size-1) ) asNumber\r\t\t\t\t\t\tifTrue: [ a ]\r\t\t\t\t\t\tifFalse: [ (c copyFrom: 1 to: (c size-1) ) asNumber ] ] ].\r\tl2 isEmpty\r\t\tifFalse: [ l2_max := l2\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\t a > (c copyFrom: 1 to: (c size-1) ) asNumber\r\t\t\t\t\t\tifTrue: [ a ]\r\t\t\t\t\t\tifFalse: [ (c copyFrom: 1 to: (c size-1) ) asNumber ] ] ].\r\t\t\t\t\r\tTranscript show: l1_max class; show: l2_max; cr.\r\tresult := OrderedCollection new.\r\tl1 size == givenSize & (l2 size == givenSize)\r\t\tifTrue: [ result := (l1 includes: 1 | (l1_max > l2_max))\r\t\t\t\t& (l2 includes: 1) not\r\t\t\t\tifTrue: [ l1 ]\r\t\t\t\tifFalse: [ l2 ] ]\r\t\tifFalse: [ l1 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ].\r\t\t\tl2 size == givenSize\r\t\t\t\tifTrue: [ result := l2 ] ].\r\t^ result',			#stamp : 'MagdalenaDhima 1/31/2021 14:27',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #accessing,			#sourceCode : 'sizeCheck: givenSize firstList: l1 secondList: l2\r\t"comment stating purpose of instance-side message"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| result l1_max l2_max |\r\tl1_max := 0.\r\tl2_max := 0.\r\tl1 isNotEmpty\r\t\tifTrue: [ l1_max := l1\r\t\t\t\tinject: 0\r\t\t\t\tinto:\r\t\t\t\t\t[ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].\r\tl2 isEmpty\r\t\tifFalse: [ l2_max := l2\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\ta > (c copyFrom: 1 to: c size - 1) asNumber\r\t\t\t\t\t\tifTrue: [ a ]\r\t\t\t\t\t\tifFalse: [ (c copyFrom: 1 to: c size - 1) asNumber ] ] ].\r\tTranscript\r\t\tshow: l1_max class;\r\t\tshow: l2_max;\r\t\tcr.\r\tresult := OrderedCollection new.\r\tl1 size == givenSize & (l2 size == givenSize)\r\t\tifTrue: [ result := (l1 includes: 1 | (l1_max > l2_max))\r\t\t\t\t& (l2 includes: 1) not\r\t\t\t\tifTrue: [ l1 ]\r\t\t\t\tifFalse: [ l2 ] ]\r\t\tifFalse: [ l1 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ].\r\t\t\tl2 size == givenSize\r\t\t\t\tifTrue: [ result := l2 ] ].\r\t^ result',			#stamp : 'MagdalenaDhima 1/31/2021 14:27',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T14:29:01.202003-05:00' ],		#prior : OmReference [ '52' ],		#self : OmReference [ '53' ]	},	#content : EpCompositeRefactoring {		#childrenRefactorings : [ ]	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#prior : OmReference [ '53' ],		#self : OmReference [ '54' ],		#time : DateAndTime [ '2021-01-31T14:29:01.309003-05:00' ],		#trigger : @3	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #accessing,			#sourceCode : 'sizeCheck: givenSize firstList: l1 secondList: l2\r\t"comment stating purpose of instance-side message"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| result l1_max l2_max |\r\tl1_max := 0.\r\tl2_max := 0.\r\tl1 isNotEmpty\r\t\tifTrue: [ l1_max := l1\r\t\t\t\tinject: 0\r\t\t\t\tinto:\r\t\t\t\t\t[ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].\r\tl2 isEmpty\r\t\tifFalse: [ l2_max := l2\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | \r\t\t\t\t\ta > (c copyFrom: 1 to: c size - 1) asNumber\r\t\t\t\t\t\tifTrue: [ a ]\r\t\t\t\t\t\tifFalse: [ (c copyFrom: 1 to: c size - 1) asNumber ] ] ].\r\tTranscript\r\t\tshow: l1_max class;\r\t\tshow: l2_max;\r\t\tcr.\r\tresult := OrderedCollection new.\r\tl1 size == givenSize & (l2 size == givenSize)\r\t\tifTrue: [ result := (l1 includes: 1 | (l1_max > l2_max))\r\t\t\t\t& (l2 includes: 1) not\r\t\t\t\tifTrue: [ l1 ]\r\t\t\t\tifFalse: [ l2 ] ]\r\t\tifFalse: [ l1 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ].\r\t\t\tl2 size == givenSize\r\t\t\t\tifTrue: [ result := l2 ] ].\r\t^ result',			#stamp : 'MagdalenaDhima 1/31/2021 14:27',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #accessing,			#sourceCode : 'sizeCheck: givenSize firstList: l1 secondList: l2\r\t"comment stating purpose of instance-side message"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| result l1_max l2_max |\r\tl1_max := 0.\r\tl2_max := 0.\r\tl1 isNotEmpty\r\t\tifTrue: [ l1_max := l1\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].\r\tl2 isEmpty\r\t\tifFalse: [ l2_max := l2\r\t\t\t\tinject: 0\r\t\t\t\tinto:\r\t\t\t\t\t[ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].\r\tTranscript\r\t\tshow: l1_max class;\r\t\tshow: l2_max;\r\t\tcr.\r\tresult := OrderedCollection new.\r\tl1 size == givenSize & (l2 size == givenSize)\r\t\tifTrue: [ result := (l1 includes: 1 | (l1_max > l2_max))\r\t\t\t\t& (l2 includes: 1) not\r\t\t\t\tifTrue: [ l1 ]\r\t\t\t\tifFalse: [ l2 ] ]\r\t\tifFalse: [ l1 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ].\r\t\t\tl2 size == givenSize\r\t\t\t\tifTrue: [ result := l2 ] ].\r\t^ result',			#stamp : 'MagdalenaDhima 1/31/2021 14:29',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T14:36:47.242003-05:00' ],		#prior : OmReference [ '54' ],		#self : OmReference [ '55' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #accessing,			#sourceCode : 'sizeCheck: givenSize firstList: l1 secondList: l2\r\t"comment stating purpose of instance-side message"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| result l1_max l2_max |\r\tl1_max := 0.\r\tl2_max := 0.\r\tl1 isNotEmpty\r\t\tifTrue: [ l1_max := l1\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].\r\tl2 isEmpty\r\t\tifFalse: [ l2_max := l2\r\t\t\t\tinject: 0\r\t\t\t\tinto:\r\t\t\t\t\t[ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].\r\tTranscript\r\t\tshow: l1_max class;\r\t\tshow: l2_max;\r\t\tcr.\r\tresult := OrderedCollection new.\r\tl1 size == givenSize & (l2 size == givenSize)\r\t\tifTrue: [ result := (l1 includes: 1 | (l1_max > l2_max))\r\t\t\t\t& (l2 includes: 1) not\r\t\t\t\tifTrue: [ l1 ]\r\t\t\t\tifFalse: [ l2 ] ]\r\t\tifFalse: [ l1 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ].\r\t\t\tl2 size == givenSize\r\t\t\t\tifTrue: [ result := l2 ] ].\r\t^ result',			#stamp : 'MagdalenaDhima 1/31/2021 14:29',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #accessing,			#sourceCode : 'sizeCheck: givenSize firstList: l1 secondList: l2\r\t"comment stating purpose of instance-side message"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| result l1_max l2_max ace1 ace2 |\r\tl1_max := 0.\r\tl2_max := 0.\r\tl1 isNotEmpty\r\t\tifTrue: [ l1_max := l1\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].\r\tl2 isEmpty\r\t\tifFalse: [ l2_max := l2\r\t\t\t\tinject: 0\r\t\t\t\tinto:\r\t\t\t\t\t[ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].\r\tTranscript\r\t\tshow: l1_max class;\r\t\tshow: l2_max;\r\t\tcr.\r\tace1 := l1 detect: [:a | (a copyFrom: 1 to: a size - 1) asNumber == 1 ] ifNone: [0].\r\tace2 := l2 detect: [:a | (a copyFrom: 1 to: a size - 1) asNumber == 1 ] ifNone: [0].\r\t\t\r\tTranscript\r\t\tshow: ace1 class;\r\t\tshow: ace2;\r\t\tcr.\r\t\t\r\tresult := OrderedCollection new.\r\tl1 size == givenSize & (l2 size == givenSize)\r\t\tifTrue: [ result := (l1 includes: 1 | (l1_max > l2_max))\r\t\t\t\t& (l2 includes: 1) not\r\t\t\t\tifTrue: [ l1 ]\r\t\t\t\tifFalse: [ l2 ] ]\r\t\tifFalse: [ l1 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ].\r\t\t\tl2 size == givenSize\r\t\t\t\tifTrue: [ result := l2 ] ].\r\t^ result',			#stamp : 'MagdalenaDhima 1/31/2021 14:36',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T14:40:05.126003-05:00' ],		#prior : OmReference [ '55' ],		#self : OmReference [ '56' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #accessing,			#sourceCode : 'sizeCheck: givenSize firstList: l1 secondList: l2\r\t"comment stating purpose of instance-side message"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| result l1_max l2_max ace1 ace2 |\r\tl1_max := 0.\r\tl2_max := 0.\r\tl1 isNotEmpty\r\t\tifTrue: [ l1_max := l1\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].\r\tl2 isEmpty\r\t\tifFalse: [ l2_max := l2\r\t\t\t\tinject: 0\r\t\t\t\tinto:\r\t\t\t\t\t[ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].\r\tTranscript\r\t\tshow: l1_max class;\r\t\tshow: l2_max;\r\t\tcr.\r\tace1 := l1 detect: [:a | (a copyFrom: 1 to: a size - 1) asNumber == 1 ] ifNone: [0].\r\tace2 := l2 detect: [:a | (a copyFrom: 1 to: a size - 1) asNumber == 1 ] ifNone: [0].\r\t\t\r\tTranscript\r\t\tshow: ace1 class;\r\t\tshow: ace2;\r\t\tcr.\r\t\t\r\tresult := OrderedCollection new.\r\tl1 size == givenSize & (l2 size == givenSize)\r\t\tifTrue: [ result := (l1 includes: 1 | (l1_max > l2_max))\r\t\t\t\t& (l2 includes: 1) not\r\t\t\t\tifTrue: [ l1 ]\r\t\t\t\tifFalse: [ l2 ] ]\r\t\tifFalse: [ l1 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ].\r\t\t\tl2 size == givenSize\r\t\t\t\tifTrue: [ result := l2 ] ].\r\t^ result',			#stamp : 'MagdalenaDhima 1/31/2021 14:36',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #accessing,			#sourceCode : 'sizeCheck: givenSize firstList: l1 secondList: l2\r\t"comment stating purpose of instance-side message"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| result l1_max l2_max aceInl1 aceInl2 |\r\tl1_max := 0.\r\tl2_max := 0.\r\tl1 isNotEmpty\r\t\tifTrue: [ l1_max := l1\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].\r\tl2 isEmpty\r\t\tifFalse: [ l2_max := l2\r\t\t\t\tinject: 0\r\t\t\t\tinto:\r\t\t\t\t\t[ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].\r\tTranscript\r\t\tshow: l1_max class;\r\t\tshow: l2_max;\r\t\tcr.\r\taceInl1 := l1 detect: [:a | (a copyFrom: 1 to: a size - 1) asNumber == 1 ] ifNone: [0].\r\taceInl2 := l2 detect: [:a | (a copyFrom: 1 to: a size - 1) asNumber == 1 ] ifNone: [0].\r\t\t\r\tresult := OrderedCollection new.\r\tl1 size == givenSize & (l2 size == givenSize)\r\t\tifTrue: [ result := ( aceInl1 == 1 | (l1_max > l2_max))\r\t\t\t\t& (aceInl2 == 0)\r\t\t\t\tifTrue: [ l1 ]\r\t\t\t\tifFalse: [ l2 ] ]\r\t\tifFalse: [ l1 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ].\r\t\t\tl2 size == givenSize\r\t\t\t\tifTrue: [ result := l2 ] ].\r\t^ result',			#stamp : 'MagdalenaDhima 1/31/2021 14:40',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T14:40:46.618003-05:00' ],		#prior : OmReference [ '56' ],		#self : OmReference [ '57' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #accessing,			#sourceCode : 'sizeCheck: givenSize firstList: l1 secondList: l2\r\t"comment stating purpose of instance-side message"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| result l1_max l2_max aceInl1 aceInl2 |\r\tl1_max := 0.\r\tl2_max := 0.\r\tl1 isNotEmpty\r\t\tifTrue: [ l1_max := l1\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].\r\tl2 isEmpty\r\t\tifFalse: [ l2_max := l2\r\t\t\t\tinject: 0\r\t\t\t\tinto:\r\t\t\t\t\t[ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].\r\tTranscript\r\t\tshow: l1_max class;\r\t\tshow: l2_max;\r\t\tcr.\r\taceInl1 := l1 detect: [:a | (a copyFrom: 1 to: a size - 1) asNumber == 1 ] ifNone: [0].\r\taceInl2 := l2 detect: [:a | (a copyFrom: 1 to: a size - 1) asNumber == 1 ] ifNone: [0].\r\t\t\r\tresult := OrderedCollection new.\r\tl1 size == givenSize & (l2 size == givenSize)\r\t\tifTrue: [ result := ( aceInl1 == 1 | (l1_max > l2_max))\r\t\t\t\t& (aceInl2 == 0)\r\t\t\t\tifTrue: [ l1 ]\r\t\t\t\tifFalse: [ l2 ] ]\r\t\tifFalse: [ l1 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ].\r\t\t\tl2 size == givenSize\r\t\t\t\tifTrue: [ result := l2 ] ].\r\t^ result',			#stamp : 'MagdalenaDhima 1/31/2021 14:40',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #accessing,			#sourceCode : 'sizeCheck: givenSize firstList: l1 secondList: l2\r\t"comment stating purpose of instance-side message"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| result l1_max l2_max aceInl1 aceInl2 |\r\tl1_max := 0.\r\tl2_max := 0.\r\tl1 isNotEmpty\r\t\tifTrue: [ l1_max := l1\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].\r\tl2 isEmpty\r\t\tifFalse: [ l2_max := l2\r\t\t\t\tinject: 0\r\t\t\t\tinto:\r\t\t\t\t\t[ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].\r\r\taceInl1 := l1 detect: [:a | (a copyFrom: 1 to: a size - 1) asNumber == 1 ] ifNone: [0].\r\taceInl2 := l2 detect: [:a | (a copyFrom: 1 to: a size - 1) asNumber == 1 ] ifNone: [0].\r\t\t\r\tresult := OrderedCollection new.\r\tl1 size == givenSize & (l2 size == givenSize)\r\t\tifTrue: [ result := ( aceInl1 == 1 | (l1_max > l2_max))\r\t\t\t\t& (aceInl2 == 0)\r\t\t\t\tifTrue: [ l1 ]\r\t\t\t\tifFalse: [ l2 ] ]\r\t\tifFalse: [ l1 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ].\r\t\t\tl2 size == givenSize\r\t\t\t\tifTrue: [ result := l2 ] ].\r\tTranscript show: result class; show: result;\r\t\tcr.\r\t^ result',			#stamp : 'MagdalenaDhima 1/31/2021 14:40',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T14:42:01.894003-05:00' ],		#prior : OmReference [ '57' ],		#self : OmReference [ '58' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #accessing,			#sourceCode : 'sizeCheck: givenSize firstList: l1 secondList: l2\r\t"comment stating purpose of instance-side message"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| result l1_max l2_max aceInl1 aceInl2 |\r\tl1_max := 0.\r\tl2_max := 0.\r\tl1 isNotEmpty\r\t\tifTrue: [ l1_max := l1\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].\r\tl2 isEmpty\r\t\tifFalse: [ l2_max := l2\r\t\t\t\tinject: 0\r\t\t\t\tinto:\r\t\t\t\t\t[ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].\r\r\taceInl1 := l1 detect: [:a | (a copyFrom: 1 to: a size - 1) asNumber == 1 ] ifNone: [0].\r\taceInl2 := l2 detect: [:a | (a copyFrom: 1 to: a size - 1) asNumber == 1 ] ifNone: [0].\r\t\t\r\tresult := OrderedCollection new.\r\tl1 size == givenSize & (l2 size == givenSize)\r\t\tifTrue: [ result := ( aceInl1 == 1 | (l1_max > l2_max))\r\t\t\t\t& (aceInl2 == 0)\r\t\t\t\tifTrue: [ l1 ]\r\t\t\t\tifFalse: [ l2 ] ]\r\t\tifFalse: [ l1 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ].\r\t\t\tl2 size == givenSize\r\t\t\t\tifTrue: [ result := l2 ] ].\r\tTranscript show: result class; show: result;\r\t\tcr.\r\t^ result',			#stamp : 'MagdalenaDhima 1/31/2021 14:40',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #accessing,			#sourceCode : 'sizeCheck: givenSize firstList: l1 secondList: l2\r\t"comment stating purpose of instance-side message"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| result l1_max l2_max aceInl1 aceInl2 |\r\tl1_max := 0.\r\tl2_max := 0.\r\tl1 isNotEmpty\r\t\tifTrue: [ l1_max := l1\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].\r\tl2 isEmpty\r\t\tifFalse: [ l2_max := l2\r\t\t\t\tinject: 0\r\t\t\t\tinto:\r\t\t\t\t\t[ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].\r\r\taceInl1 := l1 detect: [:a | (a copyFrom: 1 to: a size - 1) asNumber == 1 ] ifNone: [0].\r\taceInl2 := l2 detect: [:a | (a copyFrom: 1 to: a size - 1) asNumber == 1 ] ifNone: [0].\r\t\t\r\tresult := OrderedCollection new.\r\tl1 size == givenSize & (l2 size == givenSize)\r\t\tifTrue: [ result := ( aceInl1 == 1 | (l1_max > l2_max))\r\t\t\t\t& (aceInl2 == 0)\r\t\t\t\tifTrue: [ l1 ]\r\t\t\t\tifFalse: [ l2 ] ]\r\t\tifFalse: [ l1 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ].\r\t\t\tl2 size == givenSize\r\t\t\t\tifTrue: [ result := l2 ] ].\r\tTranscript show: \'result\'; show: result;\r\t\tcr.\r\t^ result',			#stamp : 'MagdalenaDhima 1/31/2021 14:42',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T14:44:00.526003-05:00' ],		#prior : OmReference [ '58' ],		#self : OmReference [ '59' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted1.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tTranscript show: temp2 ; cr.\r\tTranscript show: valueStreak2b; cr.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 13:56',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted1.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tTranscript show: \'valueStreak\'; show: valueStreak; cr.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\tTranscript show: \'valueStreakb\'; show: valueStreakb; cr.\r\t\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 14:44',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T14:48:35.307003-05:00' ],		#prior : OmReference [ '59' ],		#self : OmReference [ '60' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted1.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tTranscript show: \'valueStreak\'; show: valueStreak; cr.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\tTranscript show: \'valueStreakb\'; show: valueStreakb; cr.\r\t\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 14:44',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted1.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 14:48',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T14:49:31.796003-05:00' ],		#prior : OmReference [ '60' ],		#self : OmReference [ '61' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted1.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 14:48',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted1.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 14:49',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T14:54:44.269003-05:00' ],		#prior : OmReference [ '61' ],		#self : OmReference [ '62' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted1.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 14:49',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted1.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\tTranscript show: flushOrSuitStreak.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 14:54',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T14:59:46.465003-05:00' ],		#prior : OmReference [ '62' ],		#self : OmReference [ '63' ]	},	#content : EpSessionSnapshot {		#imageName : 'C:\\Users\\Administrator\\Documents\\Pharo\\images\\Pharo 8.0 - 64bit (stable)\\game1.image'	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T15:03:23.052003-05:00' ],		#prior : OmReference [ '63' ],		#self : OmReference [ '64' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted1.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\tTranscript show: flushOrSuitStreak.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 14:54',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted1.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(flushOrSuitStreak size >= 5) ifTrue: [  \r\t(flushOrSuitStreak size -4) to: (flushOrSuitStreak size) do: [ :i | flush add: (flushOrSuitStreak at: i) ]. \r\tflushOrSuitStreak := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 15:03',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T15:04:18.278003-05:00' ],		#prior : OmReference [ '64' ],		#self : OmReference [ '65' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted1.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(flushOrSuitStreak size >= 5) ifTrue: [  \r\t(flushOrSuitStreak size -4) to: (flushOrSuitStreak size) do: [ :i | flush add: (flushOrSuitStreak at: i) ]. \r\tflushOrSuitStreak := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 15:03',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted1.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(flushOrSuitStreak size >= 5) ifTrue: [  \r\t(flushOrSuitStreak size -4) to: (flushOrSuitStreak size) do: [ :i | flush add: (flushOrSuitStreak at: i) ]. \r\tflushOrSuitStreak := flush ].\r\tTranscript show: flushOrSuitStreak; cr.\r\tTranscript show: \'\'; cr.\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 15:04',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T15:05:09.911003-05:00' ],		#prior : OmReference [ '65' ],		#self : OmReference [ '66' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted1.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(flushOrSuitStreak size >= 5) ifTrue: [  \r\t(flushOrSuitStreak size -4) to: (flushOrSuitStreak size) do: [ :i | flush add: (flushOrSuitStreak at: i) ]. \r\tflushOrSuitStreak := flush ].\r\tTranscript show: flushOrSuitStreak; cr.\r\tTranscript show: \'\'; cr.\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 15:04',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted1.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\tTranscript show: flushOrSuitStreak; cr.\r\t(flushOrSuitStreak size >= 5) ifTrue: [  \r\t(flushOrSuitStreak size -4) to: (flushOrSuitStreak size) do: [ :i | flush add: (flushOrSuitStreak at: i) ]. \r\tflushOrSuitStreak := flush ].\r\tTranscript show: flushOrSuitStreak; cr.\r\tTranscript show: \'\'; cr.\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 15:05',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T15:08:32.659003-05:00' ],		#prior : OmReference [ '66' ],		#self : OmReference [ '67' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted1.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\tTranscript show: flushOrSuitStreak; cr.\r\t(flushOrSuitStreak size >= 5) ifTrue: [  \r\t(flushOrSuitStreak size -4) to: (flushOrSuitStreak size) do: [ :i | flush add: (flushOrSuitStreak at: i) ]. \r\tflushOrSuitStreak := flush ].\r\tTranscript show: flushOrSuitStreak; cr.\r\tTranscript show: \'\'; cr.\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 15:05',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted1.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i) ]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: \'\'; cr.\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 15:08',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T15:11:37.787003-05:00' ],		#prior : OmReference [ '67' ],		#self : OmReference [ '68' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted1.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i) ]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: \'\'; cr.\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 15:08',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted1.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | Transcript show: (flushOrSuitStreak1 at: i); cr. flush add: (flushOrSuitStreak1 at: i) ]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: \'\'; cr.\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 15:11',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T15:13:06.589003-05:00' ],		#prior : OmReference [ '68' ],		#self : OmReference [ '69' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted1.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | Transcript show: (flushOrSuitStreak1 at: i); cr. flush add: (flushOrSuitStreak1 at: i) ]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: \'\'; cr.\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 15:11',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted1.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | Transcript show: (flushOrSuitStreak1 at: i); cr. flush add: (flushOrSuitStreak1 at: i). Transcript show: flush; cr.]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: \'\'; cr.\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 15:13',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T15:14:05.432003-05:00' ],		#prior : OmReference [ '69' ],		#self : OmReference [ '70' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted1.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | Transcript show: (flushOrSuitStreak1 at: i); cr. flush add: (flushOrSuitStreak1 at: i). Transcript show: flush; cr.]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: \'\'; cr.\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 15:13',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted1.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | Transcript show: flush; cr. flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: \'\'; cr.\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 15:14',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T15:14:25.602003-05:00' ],		#prior : OmReference [ '70' ],		#self : OmReference [ '71' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted1.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | Transcript show: flush; cr. flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: \'\'; cr.\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 15:14',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted1.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | Transcript show: flush; cr. flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: \'\'; cr.\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 15:14',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T15:14:36.082003-05:00' ],		#prior : OmReference [ '71' ],		#self : OmReference [ '72' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted1.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | Transcript show: flush; cr. flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: \'\'; cr.\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 15:14',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted1.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | Transcript show: flush; cr. flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: \'\'; cr.\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 15:14',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T15:15:09.907003-05:00' ],		#prior : OmReference [ '72' ],		#self : OmReference [ '73' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted1.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | Transcript show: flush; cr. flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: \'\'; cr.\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 15:14',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted1.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | Transcript show: flush; cr. flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'\'; cr.\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 15:15',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T15:15:33.808003-05:00' ],		#prior : OmReference [ '73' ],		#self : OmReference [ '74' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted1.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | Transcript show: flush; cr. flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'\'; cr.\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 15:15',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted1.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 15:15',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T15:23:33.504003-05:00' ],		#prior : OmReference [ '74' ],		#self : OmReference [ '75' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , \' \' )]. \r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\t\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tword := \'\'.\r\t\ttemp := OrderedCollection new.\r\t\taValue do: [:a | (a asString ~= \' \') ifTrue: [word := word , a asString] ifFalse: [ temp add: word. word := \'\' ] ].\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\r\thighestSuitStreak := suitStreak.\r\t"\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak]."\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/31/2021 11:49',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max temp word |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) , card , \' \' )]. \r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\t\r\tTranscript show: dataInHand; cr.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tword := \'\'.\r\t\ttemp := OrderedCollection new.\r\t\taValue do: [:a | (a asString ~= \' \') ifTrue: [word := word , a asString] ifFalse: [ temp add: word. word := \'\' ] ].\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\r\thighestSuitStreak := suitStreak.\r\t"\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak]."\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/31/2021 15:23',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T15:24:10.257003-05:00' ],		#prior : OmReference [ '75' ],		#self : OmReference [ '76' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted1.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 15:15',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 15:24',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T15:27:07.301003-05:00' ],		#prior : OmReference [ '76' ],		#self : OmReference [ '77' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous == 13 ) ) | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r] ]].\r\rTranscript show: \'here\';cr.\rTranscript show: streaks; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r\r^highestStreak',			#stamp : 'MagdalenaDhima 1/31/2021 11:37',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t( ( (current asNumber == 1 & ( previous asNumber == 13 ) ) | ( current asNumber ~= 1 & ( previous asNumber == (current asNumber -1) ) ) & notFound ) )\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r] ]].\r\rTranscript show: \'here\';cr.\rTranscript show: streaks; cr.\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r\r^highestStreak',			#stamp : 'MagdalenaDhima 1/31/2021 15:27',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T15:31:14.381003-05:00' ],		#prior : OmReference [ '77' ],		#self : OmReference [ '78' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #accessing,			#sourceCode : 'sizeCheck: givenSize firstList: l1 secondList: l2\r\t"comment stating purpose of instance-side message"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| result l1_max l2_max aceInl1 aceInl2 |\r\tl1_max := 0.\r\tl2_max := 0.\r\tl1 isNotEmpty\r\t\tifTrue: [ l1_max := l1\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].\r\tl2 isEmpty\r\t\tifFalse: [ l2_max := l2\r\t\t\t\tinject: 0\r\t\t\t\tinto:\r\t\t\t\t\t[ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].\r\r\taceInl1 := l1 detect: [:a | (a copyFrom: 1 to: a size - 1) asNumber == 1 ] ifNone: [0].\r\taceInl2 := l2 detect: [:a | (a copyFrom: 1 to: a size - 1) asNumber == 1 ] ifNone: [0].\r\t\t\r\tresult := OrderedCollection new.\r\tl1 size == givenSize & (l2 size == givenSize)\r\t\tifTrue: [ result := ( aceInl1 == 1 | (l1_max > l2_max))\r\t\t\t\t& (aceInl2 == 0)\r\t\t\t\tifTrue: [ l1 ]\r\t\t\t\tifFalse: [ l2 ] ]\r\t\tifFalse: [ l1 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ].\r\t\t\tl2 size == givenSize\r\t\t\t\tifTrue: [ result := l2 ] ].\r\tTranscript show: \'result\'; show: result;\r\t\tcr.\r\t^ result',			#stamp : 'MagdalenaDhima 1/31/2021 14:42',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sizeCheck:firstList:secondList:',			#protocol : #accessing,			#sourceCode : 'sizeCheck: givenSize firstList: l1 secondList: l2\r\t"comment stating purpose of instance-side message"\r\r\t"scope: class-variables  &  instance-variables"\r\r\t| result l1_max l2_max aceInl1 aceInl2 |\r\tl1_max := 0.\r\tl2_max := 0.\r\tl1 isNotEmpty\r\t\tifTrue: [ l1_max := l1\r\t\t\t\tinject: 0\r\t\t\t\tinto: [ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].\r\tl2 isEmpty\r\t\tifFalse: [ l2_max := l2\r\t\t\t\tinject: 0\r\t\t\t\tinto:\r\t\t\t\t\t[ :a :c | a max: (c copyFrom: 1 to: c size - 1) asNumber ] ].\r\r\taceInl1 := l1 detect: [:a | (a copyFrom: 1 to: a size - 1) asNumber == 1 ] ifNone: [0].\r\taceInl2 := l2 detect: [:a | (a copyFrom: 1 to: a size - 1) asNumber == 1 ] ifNone: [0].\r\t\t\r\tresult := OrderedCollection new.\r\tl1 size == givenSize & (l2 size == givenSize)\r\t\tifTrue: [ result := ( aceInl1 ~= 0 | (l1_max > l2_max))\r\t\t\t\t& (aceInl2 == 0)\r\t\t\t\tifTrue: [ l1 ]\r\t\t\t\tifFalse: [ l2 ] ]\r\t\tifFalse: [ l1 size == givenSize\r\t\t\t\tifTrue: [ result := l1 ].\r\t\t\tl2 size == givenSize\r\t\t\t\tifTrue: [ result := l2 ] ].\r\tTranscript show: \'result\'; show: result;\r\t\tcr.\r\t^ result',			#stamp : 'MagdalenaDhima 1/31/2021 15:31',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T15:36:53.004003-05:00' ],		#prior : OmReference [ '78' ],		#self : OmReference [ '79' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 15:24',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 15:36',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T15:56:13.156003-05:00' ],		#prior : OmReference [ '79' ],		#self : OmReference [ '80' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 15:36',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tflushOrSuitStreak := self sizeCheck: 3 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 3) ifTrue: [Transcript show: 7; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 15:56',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T16:00:02.237003-05:00' ],		#prior : OmReference [ '80' ],		#self : OmReference [ '81' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tflushOrSuitStreak := self sizeCheck: 3 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 3) ifTrue: [Transcript show: 7; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 15:56',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 2; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tflushOrSuitStreak := self sizeCheck: 3 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 3) ifTrue: [Transcript show: 6; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 16:00',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T16:02:37.561003-05:00' ],		#prior : OmReference [ '81' ],		#self : OmReference [ '82' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 2; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tflushOrSuitStreak := self sizeCheck: 3 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 3) ifTrue: [Transcript show: 6; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 16:00',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 2; cr. ^valueStreak].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 6; cr. ^valueStreak].\r\t\r\tflushOrSuitStreak := self sizeCheck: 3 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 3) ifTrue: [Transcript show: 7; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 16:02',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T16:21:40.422003-05:00' ],		#prior : OmReference [ '82' ],		#self : OmReference [ '83' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 2; cr. ^valueStreak].\r\t\r\tflushOrSuitStreak := self sizeCheck: 4 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 6; cr. ^valueStreak].\r\t\r\tflushOrSuitStreak := self sizeCheck: 3 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 3) ifTrue: [Transcript show: 7; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 16:02',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 5) ifTrue: [Transcript show: 6; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 16:21',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T16:35:25.451003-05:00' ],		#prior : OmReference [ '83' ],		#self : OmReference [ '84' ]	},	#content : EpSessionSnapshot {		#imageName : 'C:\\Users\\Administrator\\Documents\\Pharo\\images\\Pharo 8.0 - 64bit (stable)\\game1.image'	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T16:40:10.631003-05:00' ],		#prior : OmReference [ '84' ],		#self : OmReference [ '85' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 3 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 5) ifTrue: [Transcript show: 6; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 16:21',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreak1 := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreak2 := valueStreak2 , valueStreak2b.\r\t].\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 5) ifTrue: [Transcript show: 6; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 16:40',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T16:44:18.874003-05:00' ],		#prior : OmReference [ '85' ],		#self : OmReference [ '86' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreak1 := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreak2 := valueStreak2 , valueStreak2b.\r\t].\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 5) ifTrue: [Transcript show: 6; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 16:40',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreak1 := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreak2 := valueStreak2 , valueStreak2b.\r\t].\r\r\tTranscript show: valueStreak1; show: valueStreak2; cr.\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreak1 secondList: valueStreak2.\r\t\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 5) ifTrue: [Transcript show: 6; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 16:44',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T16:45:31.566003-05:00' ],		#prior : OmReference [ '86' ],		#self : OmReference [ '87' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreak1 := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreak2 := valueStreak2 , valueStreak2b.\r\t].\r\r\tTranscript show: valueStreak1; show: valueStreak2; cr.\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreak1 secondList: valueStreak2.\r\t\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 5) ifTrue: [Transcript show: 6; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 16:44',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreak1 := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreak2 := valueStreak2 , valueStreak2b.\r\t].\r\tTranscript show: valueStreak2b; show: valueStreak2; cr.\r\tTranscript show: valueStreak1; show: valueStreak2; cr.\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreak1 secondList: valueStreak2.\r\t\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 5) ifTrue: [Transcript show: 6; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 16:45',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T16:45:54.322003-05:00' ],		#prior : OmReference [ '87' ],		#self : OmReference [ '88' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreak1 := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreak2 := valueStreak2 , valueStreak2b.\r\t].\r\tTranscript show: valueStreak2b; show: valueStreak2; cr.\r\tTranscript show: valueStreak1; show: valueStreak2; cr.\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreak1 secondList: valueStreak2.\r\t\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 5) ifTrue: [Transcript show: 6; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 16:45',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreak1 := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreak2 := valueStreak2 , valueStreak2b.\r\t].\r\tTranscript show: valueStreak2b; show: temp2; cr.\r\tTranscript show: valueStreak1; show: valueStreak2; cr.\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreak1 secondList: valueStreak2.\r\t\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 5) ifTrue: [Transcript show: 6; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 16:45',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T16:47:59.355003-05:00' ],		#prior : OmReference [ '88' ],		#self : OmReference [ '89' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\t(previous asNumber == current asNumber)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmaxCount := 0.\r\tmaxVal := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t( ( ( aKey asNumber ~= 1 & (aKey asNumber > maxVal asNumber) ) | (aKey asNumber == 1) ) & (aValue size >= maxCount) ) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue] ].\r\t\r\thighestValueStreak := valueStreak.\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/31/2021 12:26',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\t(previous asNumber == current asNumber)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tTranscript show: dataInHand; cr.\r\r\tvalueStreak := OrderedCollection new.\r\tmaxCount := 0.\r\tmaxVal := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t( ( ( aKey asNumber ~= 1 & (aKey asNumber > maxVal asNumber) ) | (aKey asNumber == 1) ) & (aValue size >= maxCount) ) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue] ].\r\t\r\thighestValueStreak := valueStreak.\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/31/2021 16:47',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T16:48:37.725003-05:00' ],		#prior : OmReference [ '89' ],		#self : OmReference [ '90' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\t(previous asNumber == current asNumber)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tTranscript show: dataInHand; cr.\r\r\tvalueStreak := OrderedCollection new.\r\tmaxCount := 0.\r\tmaxVal := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t( ( ( aKey asNumber ~= 1 & (aKey asNumber > maxVal asNumber) ) | (aKey asNumber == 1) ) & (aValue size >= maxCount) ) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue] ].\r\t\r\thighestValueStreak := valueStreak.\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/31/2021 16:47',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\t(previous asNumber == current asNumber)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmaxCount := 0.\r\tmaxVal := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t( ( ( aKey asNumber ~= 1 & (aKey asNumber > maxVal asNumber) ) | (aKey asNumber == 1) ) & (aValue size >= maxCount) ) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue] ].\r\t\r\tTranscript show: valueStreak; cr.\r\t\r\thighestValueStreak := valueStreak.\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/31/2021 16:48',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T16:55:14.390003-05:00' ],		#prior : OmReference [ '90' ],		#self : OmReference [ '91' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\t(previous asNumber == current asNumber)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmaxCount := 0.\r\tmaxVal := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t( ( ( aKey asNumber ~= 1 & (aKey asNumber > maxVal asNumber) ) | (aKey asNumber == 1) ) & (aValue size >= maxCount) ) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue] ].\r\t\r\tTranscript show: valueStreak; cr.\r\t\r\thighestValueStreak := valueStreak.\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/31/2021 16:48',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\t(previous asNumber == current asNumber)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmaxCount := 0.\r\tmaxVal := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t( ( ( aKey asNumber ~= 1 & (aKey asNumber > maxVal asNumber) ) | (aKey asNumber == 1) ) & (aValue size == maxCount) ) | aValue size > maxCount \r\t\tifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue] ].\r\t\r\t\r\thighestValueStreak := valueStreak.\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/31/2021 16:55',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T16:55:50.475003-05:00' ],		#prior : OmReference [ '91' ],		#self : OmReference [ '92' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\t(previous asNumber == current asNumber)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmaxCount := 0.\r\tmaxVal := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t( ( ( aKey asNumber ~= 1 & (aKey asNumber > maxVal asNumber) ) | (aKey asNumber == 1) ) & (aValue size == maxCount) ) | aValue size > maxCount \r\t\tifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue] ].\r\t\r\t\r\thighestValueStreak := valueStreak.\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/31/2021 16:55',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\t(previous asNumber == current asNumber)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. valueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmaxCount := 0.\r\tmaxVal := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t( ( ( aKey asNumber ~= 1 & (aKey asNumber > maxVal asNumber) ) | (aKey asNumber == 1) ) & (aValue size == maxCount) ) | (aValue size > maxCount) \r\t\tifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue] ].\r\t\r\t\r\thighestValueStreak := valueStreak.\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/31/2021 16:55',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T16:57:59.487003-05:00' ],		#prior : OmReference [ '92' ],		#self : OmReference [ '93' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreak1 := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreak2 := valueStreak2 , valueStreak2b.\r\t].\r\tTranscript show: valueStreak2b; show: temp2; cr.\r\tTranscript show: valueStreak1; show: valueStreak2; cr.\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreak1 secondList: valueStreak2.\r\t\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^( valueStreak , valueStreakb )].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 5) ifTrue: [Transcript show: 6; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 16:45',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreak1 := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreak2 := valueStreak2 , valueStreak2b.\r\t].\r\tTranscript show: valueStreak2b; show: temp2; cr.\r\tTranscript show: valueStreak1; show: valueStreak2; cr.\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreak1 secondList: valueStreak2.\r\t\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 5) ifTrue: [Transcript show: 6; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 16:57',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T17:01:58.642003-05:00' ],		#prior : OmReference [ '93' ],		#self : OmReference [ '94' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreak1 := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreak2 := valueStreak2 , valueStreak2b.\r\t].\r\tTranscript show: valueStreak2b; show: temp2; cr.\r\tTranscript show: valueStreak1; show: valueStreak2; cr.\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreak1 secondList: valueStreak2.\r\t\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 5) ifTrue: [Transcript show: 6; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 16:57',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreak1 := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreak2 := valueStreak2 , valueStreak2b.\r\t].\r\tTranscript show: valueStreak2b; show: temp2; cr.\r\tTranscript show: valueStreak1; show: valueStreak2; cr.\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreak1 secondList: valueStreak2.\r\t\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tTranscript show: \'look\'; cr; show: valueStreak2; cr.\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 5) ifTrue: [Transcript show: 6; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 17:01',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T17:04:21.282003-05:00' ],		#prior : OmReference [ '94' ],		#self : OmReference [ '95' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreak1 := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreak2 := valueStreak2 , valueStreak2b.\r\t].\r\tTranscript show: valueStreak2b; show: temp2; cr.\r\tTranscript show: valueStreak1; show: valueStreak2; cr.\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreak1 secondList: valueStreak2.\r\t\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tTranscript show: \'look\'; cr; show: valueStreak2; cr.\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 5) ifTrue: [Transcript show: 6; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 17:01',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tTranscript show: \'look\'; cr; show: valueStreak2; cr.\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 5) ifTrue: [Transcript show: 6; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 17:04',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T17:05:30.144003-05:00' ],		#prior : OmReference [ '95' ],		#self : OmReference [ '96' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new.\r\tvalueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tTranscript show: \'look\'; cr; show: valueStreak2; cr.\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 5) ifTrue: [Transcript show: 6; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 17:04',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tTranscript show: \'look\'; cr; show: valueStreak2; cr.\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 5) ifTrue: [Transcript show: 6; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 17:05',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T17:10:04.876003-05:00' ],		#prior : OmReference [ '96' ],		#self : OmReference [ '97' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tTranscript show: \'look\'; cr; show: valueStreak2; cr.\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 5) ifTrue: [Transcript show: 6; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 17:05',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t\r\t(straight size == 5 ) ifTrue: [Transcript show: 4; cr. ^straight].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tTranscript show: \'look\'; cr; show: valueStreak2; cr.\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 5) ifTrue: [Transcript show: 6; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 17:10',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T17:16:33.464003-05:00' ],		#prior : OmReference [ '97' ],		#self : OmReference [ '98' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t\r\t(straight size == 5 ) ifTrue: [Transcript show: 4; cr. ^straight].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tTranscript show: \'look\'; cr; show: valueStreak2; cr.\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 5) ifTrue: [Transcript show: 6; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 17:10',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [Transcript show: 4; cr. ^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 17:16',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T17:17:52.618003-05:00' ],		#prior : OmReference [ '98' ],		#self : OmReference [ '99' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [Transcript show: 4; cr. ^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 17:16',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tTranscript show: \'look\'; cr; show: straight2; cr.\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 17:17',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T17:24:32.401003-05:00' ],		#prior : OmReference [ '99' ],		#self : OmReference [ '100' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tTranscript show: \'look\'; cr; show: straight2; cr.\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreak1 secondList: valueStreak2.\r\tvalueStreakb := self sizeCheck: 2 firstList: valueStreak1b secondList: valueStreak2b.\r\t(valueStreak size == 2 & (valueStreakb size == 2) ) ifTrue: [Transcript show: 8; cr. ^( valueStreak , valueStreakb )].\r\t\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 17:17',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| hand sorted sorted1 sorted2 data temp1 temp2 straight straight1 straight2 valueStreak valueStreakA valueStreakB valueStreak1 valueStreak2 flushOrSuitStreak flushOrSuitStreak1 flushOrSuitStreak2 straightFlush straightFlush1 straightFlush2 valueStreakb valueStreak1b valueStreak2b remaining1 remaining2 flush |\r\thand := self convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tself divideHands: hand.\r\t\r\t\r\tsorted1 := self sort: hand1.\r\tsorted2 := self sort: hand2.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted1; cr.\r\tTranscript show: sorted2; cr.\r\tTranscript show: \'-----\'; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight1 := self getHighestStreak: sorted1.\r\tstraight2 := self getHighestStreak: sorted2.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight1; cr.\r\tTranscript show: straight2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tvalueStreak1 := self getHighestValueStreak: sorted1.\r\tvalueStreak2 := self getHighestValueStreak: sorted2.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak1; cr.\r\tTranscript show: valueStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tflushOrSuitStreak1 := self getHighestSuitStreak: sorted1.\r\tflushOrSuitStreak2 := self getHighestSuitStreak: sorted2.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak1; cr.\r\tTranscript show: flushOrSuitStreak2; cr.\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush1 := OrderedCollection new.\r\t(flushOrSuitStreak1 size > 4) ifTrue: [  \r\t\tstraightFlush1 := self getHighestStreak: flushOrSuitStreak1.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush1; cr.].\r\t\r\tstraightFlush2 := OrderedCollection new.\r\t(flushOrSuitStreak2 size > 4) ifTrue: [  \r\t\tstraightFlush2 := self getHighestStreak: flushOrSuitStreak2.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush2; cr.].\r\t\r\tTranscript show: \'-----\'; cr.\r\t\r\tstraightFlush := self sizeCheck: 5 firstList: straightFlush1 secondList: straightFlush2.\r\t(straightFlush size == 5) ifTrue: [Transcript show: 2; cr. ^straightFlush].\r\t\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 3; cr. ^valueStreak].\r\t\r\t"----------------------"\r\t\r\tremaining1 := sorted1 reject: [:a | valueStreak1 includes: a ].\r\tremaining2 := sorted2 reject: [:a | valueStreak2  includes: a ].\r\t\r\tTranscript show: \'remaining\'; cr.\r\tTranscript show: remaining1; cr.\r\tTranscript show: remaining2; cr.\r\ttemp1:= OrderedCollection new.\r\ttemp2:= OrderedCollection new.\r\ttemp1 := self getHighestValueStreak: remaining1.\r\ttemp2 := self getHighestValueStreak: remaining2.\r\t\r\tvalueStreak1b := OrderedCollection new. valueStreak2b := OrderedCollection new.\r\t(temp1 size >= 2) ifTrue: [ (temp1 size -1) to: (temp1 size) do: [ :i | valueStreak1b add: (temp1 at: i ) ] ].\r\t(temp2 size >= 2) ifTrue: [ (temp2 size -1) to: (temp2 size) do: [ :i | valueStreak2b add: (temp2 at: i ) ] ].\r\t\r\t"----------------------"\r\t\r\tvalueStreakA := OrderedCollection new. valueStreakB := OrderedCollection new. \r\t(valueStreak1 size == 3 & (valueStreak1b size == 2) ) ifTrue: [  \r\t\tvalueStreakA := valueStreak1 , valueStreak1b.\r\t].\r\t(valueStreak2 size == 3 & (valueStreak2b size == 2) ) ifTrue: [ \r\t\tvalueStreakB := valueStreak2 , valueStreak2b.\r\t].\r\r\tvalueStreak := self sizeCheck: 5 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 5 ) ifTrue: [Transcript show: 4; cr. ^valueStreak].\r\t\r\t\r\tTranscript show: flushOrSuitStreak1; cr.\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak1 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak1 size -4) to: (flushOrSuitStreak1 size) do: [ :i | flush add: (flushOrSuitStreak1 at: i)]. \r\tflushOrSuitStreak1 := flush. ].\r\r\tflush := OrderedCollection new.\r\t(flushOrSuitStreak2 size >= 5) ifTrue: [  \r\t(flushOrSuitStreak2 size -4) to: (flushOrSuitStreak2 size) do: [ :i | flush add: (flushOrSuitStreak2 at: i) ]. \r\tflushOrSuitStreak2 := flush ].\r\t\r\tflushOrSuitStreak := self sizeCheck: 5 firstList: flushOrSuitStreak1 secondList: flushOrSuitStreak2.\r\t(flushOrSuitStreak size == 5) ifTrue: [Transcript show: 5; cr. ^flushOrSuitStreak].\r\t\r\tstraight := self sizeCheck: 5 firstList: straight1 secondList: straight2.\r\t(straight size == 5 ) ifTrue: [Transcript show: 6; cr. ^straight].\r\t\r\tvalueStreak := self sizeCheck: 3 firstList: valueStreak1 secondList: valueStreak2.\r\t(valueStreak size == 3) ifTrue: [Transcript show: 7; cr. ^valueStreak].\r\t\r\tvalueStreakA := valueStreak1 , valueStreak1b.\r\tvalueStreakB := valueStreak2 , valueStreak2b.\r\tvalueStreak := self sizeCheck: 4 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 4) ifTrue: [Transcript show: 8; cr. ^(valueStreak)].\r\t\r\tvalueStreak := self sizeCheck: 2 firstList: valueStreakA secondList: valueStreakB.\r\t(valueStreak size == 2) ifTrue: [Transcript show: 9; cr. ^valueStreak].\r\t\r\tsorted := self sizeCheck: 1 firstList: sorted1 secondList: sorted2.\r\t^sorted\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/31/2021 17:24',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T17:25:09.061003-05:00' ],		#prior : OmReference [ '100' ],		#self : OmReference [ '101' ]	},	#content : EpSessionSnapshot {		#imageName : 'C:\\Users\\Administrator\\Documents\\Pharo\\images\\Pharo 8.0 - 64bit (stable)\\game1.image'	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T17:33:28.350003-05:00' ],		#prior : OmReference [ '101' ],		#self : OmReference [ '102' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getStreak:',			#protocol : #accessing,			#sourceCode : 'getStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak |\rsuitStreak := OrderedCollection new.\r2 to: streaks size do: [ :i | \r\tpreviousCard := streaks at: (i-1).\r\tprevious := previousCard at: previousCard size.\r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\t(previous == current)\r\t\tifTrue: [(suitStreak isEmpty) ifTrue:[suitStreak add: previousCard]. suitStreak add: card]].\r\t^suitStreak\r\t',			#stamp : 'MagdalenaDhima 1/30/2021 15:45',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getStreak:',			#protocol : #'as yet unclassified',			#sourceCode : 'getStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak |\rsuitStreak := OrderedCollection new.\r2 to: streaks size do: [ :i | \r\tpreviousCard := streaks at: (i-1).\r\tprevious := previousCard at: previousCard size.\r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\t(previous == current)\r\t\tifTrue: [(suitStreak isEmpty) ifTrue:[suitStreak add: previousCard]. suitStreak add: card]].\r\t^suitStreak\r\t',			#stamp : 'MagdalenaDhima 1/30/2021 15:45',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T17:33:28.354003-05:00' ],		#prior : OmReference [ '102' ],		#self : OmReference [ '103' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getStreak:',			#protocol : #accessing,			#sourceCode : 'getStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak |\rsuitStreak := OrderedCollection new.\r2 to: streaks size do: [ :i | \r\tpreviousCard := streaks at: (i-1).\r\tprevious := previousCard at: previousCard size.\r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\t(previous == current)\r\t\tifTrue: [(suitStreak isEmpty) ifTrue:[suitStreak add: previousCard]. suitStreak add: card]].\r\t^suitStreak\r\t',			#stamp : 'MagdalenaDhima 1/30/2021 15:45',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-31T18:49:05.701003-05:00' ],		#prior : OmReference [ '103' ],		#self : OmReference [ '104' ]	},	#content : EpSessionSnapshot {		#imageName : 'C:\\Users\\Administrator\\Documents\\Pharo\\images\\Pharo 8.0 - 64bit (stable)\\game1.image'	}}