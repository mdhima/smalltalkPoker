OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T09:56:24.266794-05:00' ],		#prior : OmReference [ 'Pharo8.0-SNAPSHOT-32bit-0932da8.3q205gqmnddqp9uki89mw0001', '12' ],		#self : OmReference [ '1' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sort:',			#protocol : #'as yet unclassified',			#sourceCode : 'sort: newShuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| threeDigits twoDigits |\rthreeDigits := SortedCollection new. \rtwoDigits := SortedCollection new.\rTranscript show: newShuf; cr.\r1 to: 9 do: [ :i | ((newShuf at: i) size == 3) ifTrue: [threeDigits add: (newShuf at: i)] ifFalse: [twoDigits add: (newShuf at: i)]. ].',			#stamp : 'MagdalenaDhima 1/30/2021 09:56',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T09:56:24.274794-05:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sort:',			#protocol : #'as yet unclassified',			#sourceCode : 'sort: newShuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| threeDigits twoDigits |\rthreeDigits := SortedCollection new. \rtwoDigits := SortedCollection new.\rTranscript show: newShuf; cr.\r1 to: 9 do: [ :i | ((newShuf at: i) size == 3) ifTrue: [threeDigits add: (newShuf at: i)] ifFalse: [twoDigits add: (newShuf at: i)]. ].',			#stamp : 'MagdalenaDhima 1/30/2021 09:56',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sort:',			#protocol : #sorting,			#sourceCode : 'sort: newShuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| threeDigits twoDigits |\rthreeDigits := SortedCollection new. \rtwoDigits := SortedCollection new.\rTranscript show: newShuf; cr.\r1 to: 9 do: [ :i | ((newShuf at: i) size == 3) ifTrue: [threeDigits add: (newShuf at: i)] ifFalse: [twoDigits add: (newShuf at: i)]. ].',			#stamp : 'MagdalenaDhima 1/30/2021 09:56',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T09:57:05.894794-05:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sort:',			#protocol : #sorting,			#sourceCode : 'sort: newShuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| threeDigits twoDigits |\rthreeDigits := SortedCollection new. \rtwoDigits := SortedCollection new.\rTranscript show: newShuf; cr.\r1 to: 9 do: [ :i | ((newShuf at: i) size == 3) ifTrue: [threeDigits add: (newShuf at: i)] ifFalse: [twoDigits add: (newShuf at: i)]. ].',			#stamp : 'MagdalenaDhima 1/30/2021 09:56',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sort:',			#protocol : #sorting,			#sourceCode : 'sort: newShuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| threeDigits twoDigits nice |\rthreeDigits := SortedCollection new. \rtwoDigits := SortedCollection new.\rTranscript show: newShuf; cr.\r1 to: 9 do: [ :i | ((newShuf at: i) size == 3) ifTrue: [threeDigits add: (newShuf at: i)] ifFalse: [twoDigits add: (newShuf at: i)]. ].\rnice :=  (twoDigits asArray) , (threeDigits asArray).\r^nice',			#stamp : 'MagdalenaDhima 1/30/2021 09:57',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T09:57:40.744794-05:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sort:',			#protocol : #sorting,			#sourceCode : 'sort: newShuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| threeDigits twoDigits nice |\rthreeDigits := SortedCollection new. \rtwoDigits := SortedCollection new.\rTranscript show: newShuf; cr.\r1 to: 9 do: [ :i | ((newShuf at: i) size == 3) ifTrue: [threeDigits add: (newShuf at: i)] ifFalse: [twoDigits add: (newShuf at: i)]. ].\rnice :=  (twoDigits asArray) , (threeDigits asArray).\r^nice',			#stamp : 'MagdalenaDhima 1/30/2021 09:57',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sort:',			#protocol : #sorting,			#sourceCode : 'sort: newShuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| threeDigits twoDigits nice |\rthreeDigits := SortedCollection new. \rtwoDigits := SortedCollection new.\r\r1 to: 9 do: [ :i | ((newShuf at: i) size == 3) ifTrue: [threeDigits add: (newShuf at: i)] ifFalse: [twoDigits add: (newShuf at: i)]. ].\rnice :=  (twoDigits asArray) , (threeDigits asArray).\r^nice',			#stamp : 'MagdalenaDhima 1/30/2021 09:57',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T09:58:08.322794-05:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp values suits output val newShuf |\r\tnewShuf := Array new.\r\tvalues := #(\'ace\' \'2\' \'3\' \'4\' \'5\' \'6\' \'7\' \'8\' \'9\' \'10\' \'Jack\' \'Queen\' \'King\').\r\tsuits := #(\'Clubs\' \'Diamonds\' \'Hearts\' \'Spades\').\r\t9 timesRepeat: [ :i | \r\t\tval := shuf at: i.\r\t\tTranscript show: val; cr.\r\t\ttemp := val % 13.\r\t\tTranscript show: temp; cr.\r\t\toutput := (temp == 0) \r\t\t\tifFalse: [values at: temp]\r\t\t\tifTrue: [values at: 0]\r\t\t. \r\t\tTranscript show: output; cr.\r\t\ttemp := val-1 / 13 floor. \r\t\tTranscript show: temp; cr.\r\t\tval at: (output size +1) put: (suits at: temp). \r\t\tTranscript show: val; cr.\r\t\tnewShuf at: i put: output.\r\t\tTranscript show: newShuf; cr.\r\t].\r\t^ newShuf',			#stamp : 'MagdalenaDhima 1/24/2021 16:26',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp values suits output val newShuf |\r\tnewShuf := Array new.\r\tvalues := #(\'ace\' \'2\' \'3\' \'4\' \'5\' \'6\' \'7\' \'8\' \'9\' \'10\' \'Jack\' \'Queen\' \'King\').\r\tsuits := #(\'Clubs\' \'Diamonds\' \'Hearts\' \'Spades\').\r\t9 timesRepeat: [ :i | \r\t\tval := shuf at: i.\r\t\ttemp := val % 13.\r\t\toutput := (temp == 0) \r\t\t\tifFalse: [values at: temp]\r\t\t\tifTrue: [values at: 0]\r\t\t. \r\t\ttemp := val-1 / 13 floor. \r\t\tval at: (output size +1) put: (suits at: temp). \r\t\tnewShuf at: i put: output.\r\t].\r\t^ newShuf\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 09:58',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T10:09:48.153794-05:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getData:',			#protocol : #'as yet unclassified',			#sourceCode : 'getData: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| dataInHand card temp temp2 |\r\t\rdataInHand := Dictionary new. \rdataInHand := Dictionary new. 1 to: 13 do: [ :i | dataInHand at: i put: 0].\rdataInHand at: \'C\' put: 0. dataInHand at: \'D\' put: 0. dataInHand at: \'H\' put: 0. dataInHand at: \'S\' put: 0.\r\r\r1 to: 9 do: [ :i |\r\tcard := nice at: i.\r\ttemp := (card copyFrom: 1 to: (card size-1)).\r\ttemp2 := card at: (card size).\r\tdataInHand at: temp asNumber put: ((dataInHand at: temp asNumber) +1 ).\r\tdataInHand at: temp2 asString put: ((dataInHand at: temp2 asString) +1 ).\r ].\r^dataInHand',			#stamp : 'MagdalenaDhima 1/30/2021 10:09',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T10:10:16.674794-05:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getData:',			#protocol : #'as yet unclassified',			#sourceCode : 'getData: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| dataInHand card temp temp2 |\r\t\rdataInHand := Dictionary new. \rdataInHand := Dictionary new. 1 to: 13 do: [ :i | dataInHand at: i put: 0].\rdataInHand at: \'C\' put: 0. dataInHand at: \'D\' put: 0. dataInHand at: \'H\' put: 0. dataInHand at: \'S\' put: 0.\r\r\r1 to: 9 do: [ :i |\r\tcard := nice at: i.\r\ttemp := (card copyFrom: 1 to: (card size-1)).\r\ttemp2 := card at: (card size).\r\tdataInHand at: temp asNumber put: ((dataInHand at: temp asNumber) +1 ).\r\tdataInHand at: temp2 asString put: ((dataInHand at: temp2 asString) +1 ).\r ].\r^dataInHand',			#stamp : 'MagdalenaDhima 1/30/2021 10:09',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getData:',			#protocol : #'as yet unclassified',			#sourceCode : 'getData: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| dataInHand card temp temp2 |\r\t\rdataInHand := Dictionary new. \rdataInHand := Dictionary new. 1 to: 13 do: [ :i | dataInHand at: i put: 0].\rdataInHand at: \'C\' put: 0. dataInHand at: \'D\' put: 0. dataInHand at: \'H\' put: 0. dataInHand at: \'S\' put: 0.\r\r\r1 to: 9 do: [ :i |\r\tcard := nice at: i.\r\ttemp := (card copyFrom: 1 to: (card size-1)).\r\ttemp2 := card at: card size.\r\tdataInHand at: temp asNumber put: ((dataInHand at: temp asNumber) +1 ).\r\tdataInHand at: temp2 asString put: ((dataInHand at: temp2 asString) +1 ).\r ].\r^dataInHand',			#stamp : 'MagdalenaDhima 1/30/2021 10:10',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T10:10:25.314794-05:00' ],		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getData:',			#protocol : #'as yet unclassified',			#sourceCode : 'getData: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| dataInHand card temp temp2 |\r\t\rdataInHand := Dictionary new. \rdataInHand := Dictionary new. 1 to: 13 do: [ :i | dataInHand at: i put: 0].\rdataInHand at: \'C\' put: 0. dataInHand at: \'D\' put: 0. dataInHand at: \'H\' put: 0. dataInHand at: \'S\' put: 0.\r\r\r1 to: 9 do: [ :i |\r\tcard := nice at: i.\r\ttemp := (card copyFrom: 1 to: (card size-1)).\r\ttemp2 := card at: card size.\r\tdataInHand at: temp asNumber put: ((dataInHand at: temp asNumber) +1 ).\r\tdataInHand at: temp2 asString put: ((dataInHand at: temp2 asString) +1 ).\r ].\r^dataInHand',			#stamp : 'MagdalenaDhima 1/30/2021 10:10',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getData:',			#protocol : #'as yet unclassified',			#sourceCode : 'getData: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| dataInHand card temp temp2 |\r\t\rdataInHand := Dictionary new. \rdataInHand := Dictionary new. 1 to: 13 do: [ :i | dataInHand at: i put: 0].\rdataInHand at: \'C\' put: 0. dataInHand at: \'D\' put: 0. dataInHand at: \'H\' put: 0. dataInHand at: \'S\' put: 0.\r\r\r1 to: 9 do: [ :i |\r\tcard := nice at: i.\r\ttemp := (card copyFrom: 1 to: (card size-1)).\r\ttemp2 := card at: (card size).\r\tdataInHand at: temp asNumber put: ((dataInHand at: temp asNumber) +1 ).\r\tdataInHand at: temp2 asString put: ((dataInHand at: temp2 asString) +1 ).\r ].\r^dataInHand',			#stamp : 'MagdalenaDhima 1/30/2021 10:10',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T10:10:42.667794-05:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getData:',			#protocol : #'as yet unclassified',			#sourceCode : 'getData: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| dataInHand card temp temp2 |\r\t\rdataInHand := Dictionary new. \rdataInHand := Dictionary new. 1 to: 13 do: [ :i | dataInHand at: i put: 0].\rdataInHand at: \'C\' put: 0. dataInHand at: \'D\' put: 0. dataInHand at: \'H\' put: 0. dataInHand at: \'S\' put: 0.\r\r\r1 to: 9 do: [ :i |\r\tcard := nice at: i.\r\ttemp := (card copyFrom: 1 to: (card size-1)).\r\ttemp2 := card at: (card size).\r\tdataInHand at: temp asNumber put: ((dataInHand at: temp asNumber) +1 ).\r\tdataInHand at: temp2 asString put: ((dataInHand at: temp2 asString) +1 ).\r ].\r^dataInHand',			#stamp : 'MagdalenaDhima 1/30/2021 10:10',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getData:',			#protocol : #'as yet unclassified',			#sourceCode : 'getData: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| dataInHand card temp temp2 |\r\t\rdataInHand := Dictionary new. \r1 to: 13 do: [ :i | dataInHand at: i put: 0].\rdataInHand at: \'C\' put: 0. dataInHand at: \'D\' put: 0. dataInHand at: \'H\' put: 0. dataInHand at: \'S\' put: 0.\r\r\r1 to: 9 do: [ :i |\r\tcard := nice at: i.\r\ttemp := (card copyFrom: 1 to: (card size-1)).\r\ttemp2 := card at: (card size).\r\tdataInHand at: temp asNumber put: ((dataInHand at: temp asNumber) +1 ).\r\tdataInHand at: temp2 asString put: ((dataInHand at: temp2 asString) +1 ).\r ].\r^dataInHand',			#stamp : 'MagdalenaDhima 1/30/2021 10:10',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T10:36:25.073794-05:00' ],		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #'as yet unclassified',			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: 9 do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\r\t(previous asNumber == (current asNumber -1) & notFound)\r\t\tifTrue: [(streaks size == 0) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r]].\r\rTranscript show: streaks; cr.\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size) to: (streaks size -4) by: -1 do: [ :i | highestStreak add: (streaks at: i) ]].\rTranscript show: highestStreak; cr.\r\r^streaks',			#stamp : 'MagdalenaDhima 1/30/2021 10:36',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T10:36:44.687794-05:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #'as yet unclassified',			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: 9 do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\r\t(previous asNumber == (current asNumber -1) & notFound)\r\t\tifTrue: [(streaks size == 0) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r]].\r\rTranscript show: streaks; cr.\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size) to: (streaks size -4) by: -1 do: [ :i | highestStreak add: (streaks at: i) ]].\rTranscript show: highestStreak; cr.\r\r^streaks',			#stamp : 'MagdalenaDhima 1/30/2021 10:36',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #'as yet unclassified',			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: 9 do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\r\t(previous asNumber == (current asNumber -1) & notFound)\r\t\tifTrue: [(streaks size == 0) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r]].\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size) to: (streaks size -4) by: -1 do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak',			#stamp : 'MagdalenaDhima 1/30/2021 10:36',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T10:38:08.918794-05:00' ],		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #'as yet unclassified',			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: 9 do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\r\t(previous asNumber == (current asNumber -1) & notFound)\r\t\tifTrue: [(streaks size == 0) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r]].\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size) to: (streaks size -4) by: -1 do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak',			#stamp : 'MagdalenaDhima 1/30/2021 10:36',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #'as yet unclassified',			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: 9 do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\r\t(previous asNumber == (current asNumber -1) & notFound)\r\t\tifTrue: [(streaks size == 0) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r]].\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak',			#stamp : 'MagdalenaDhima 1/30/2021 10:38',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T11:09:35.334794-05:00' ],		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #'as yet unclassified',			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak |\rsuitStreak := OrderedCollection new.\r2 to: streaks size do: [ :i | \r\tpreviousCard := streaks at: (i-1).\r\tprevious := previousCard at: previousCard size.\r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\t(previous == current)\r\t\tifTrue: [(suitStreak size == 0) ifTrue:[suitStreak add: previousCard]. suitStreak add: card]].\r\t\rhighestSuitStreak := OrderedCollection new.\r(suitStreak size >= 5) ifTrue: [\r\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]].\r\r^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 11:09',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T11:09:54.943794-05:00' ],		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #'as yet unclassified',			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak |\rsuitStreak := OrderedCollection new.\r2 to: streaks size do: [ :i | \r\tpreviousCard := streaks at: (i-1).\r\tprevious := previousCard at: previousCard size.\r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\t(previous == current)\r\t\tifTrue: [(suitStreak size == 0) ifTrue:[suitStreak add: previousCard]. suitStreak add: card]].\r\t\rhighestSuitStreak := OrderedCollection new.\r(suitStreak size >= 5) ifTrue: [\r\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]].\r\r^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 11:09',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #'as yet unclassified',			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak |\rsuitStreak := OrderedCollection new.\r2 to: streaks size do: [ :i | \r\tpreviousCard := streaks at: (i-1).\r\tprevious := previousCard at: previousCard size.\r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\t(previous == current)\r\t\tifTrue: [(suitStreak isEmpty) ifTrue:[suitStreak add: previousCard]. suitStreak add: card]].\r\t\rhighestSuitStreak := OrderedCollection new.\r(suitStreak size >= 5) ifTrue: [\r\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]].\r\r^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 11:09',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T11:11:35.585794-05:00' ],		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #'as yet unclassified',			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: 9 do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\r\t(previous asNumber == (current asNumber -1) & notFound)\r\t\tifTrue: [(streaks size == 0) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r]].\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak',			#stamp : 'MagdalenaDhima 1/30/2021 10:38',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #'as yet unclassified',			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: 9 do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\r\t(previous asNumber == (current asNumber -1) & notFound)\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r]].\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak',			#stamp : 'MagdalenaDhima 1/30/2021 11:11',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T11:52:40.749794-05:00' ],		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#definitionSource : 'Object subclass: #Poker\r\tinstanceVariableNames: \'deal\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'CPS506\'',				#superclassName : 'Object',				#traitCompositionSource : '{}'			},			#name : #Poker,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Poker,						#isMetaSide : false					},					#name : #deal,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#definitionSource : 'Poker class\r\tinstanceVariableNames: \'\'',					#traitCompositionSource : '{}'				},				#name : #'Poker class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Poker,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #CPS506,			#package : #CPS506,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#definitionSource : 'Object subclass: #Poker\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'CPS506\'',				#superclassName : 'Object',				#traitCompositionSource : '{}'			},			#name : #Poker,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#definitionSource : 'Poker class\r\tinstanceVariableNames: \'\'',					#traitCompositionSource : '{}'				},				#name : #'Poker class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @23			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Poker,					#isMetaSide : false				},				#parent : @23,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #CPS506,			#package : #CPS506,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T11:58:19.866794-05:00' ],		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getData:',			#protocol : #'as yet unclassified',			#sourceCode : 'getData: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| dataInHand card temp temp2 |\r\t\rdataInHand := Dictionary new. \r1 to: 13 do: [ :i | dataInHand at: i put: 0].\rdataInHand at: \'C\' put: 0. dataInHand at: \'D\' put: 0. dataInHand at: \'H\' put: 0. dataInHand at: \'S\' put: 0.\r\r\r1 to: 9 do: [ :i |\r\tcard := nice at: i.\r\ttemp := (card copyFrom: 1 to: (card size-1)).\r\ttemp2 := card at: (card size).\r\tdataInHand at: temp asNumber put: ((dataInHand at: temp asNumber) +1 ).\r\tdataInHand at: temp2 asString put: ((dataInHand at: temp2 asString) +1 ).\r ].\r^dataInHand',			#stamp : 'MagdalenaDhima 1/30/2021 10:10',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getData:',			#protocol : #accessing,			#sourceCode : 'getData: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| dataInHand card temp temp2 |\r\t\rdataInHand := Dictionary new. \r1 to: 13 do: [ :i | dataInHand at: i put: 0].\rdataInHand at: \'C\' put: 0. dataInHand at: \'D\' put: 0. dataInHand at: \'H\' put: 0. dataInHand at: \'S\' put: 0.\r\r\r1 to: 9 do: [ :i |\r\tcard := nice at: i.\r\ttemp := (card copyFrom: 1 to: (card size-1)).\r\ttemp2 := card at: (card size).\r\tdataInHand at: temp asNumber put: ((dataInHand at: temp asNumber) +1 ).\r\tdataInHand at: temp2 asString put: ((dataInHand at: temp2 asString) +1 ).\r ].\r^dataInHand',			#stamp : 'MagdalenaDhima 1/30/2021 10:10',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T11:58:25.644794-05:00' ],		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #'as yet unclassified',			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: 9 do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\r\t(previous asNumber == (current asNumber -1) & notFound)\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r]].\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak',			#stamp : 'MagdalenaDhima 1/30/2021 11:11',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: 9 do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\r\t(previous asNumber == (current asNumber -1) & notFound)\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r]].\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak',			#stamp : 'MagdalenaDhima 1/30/2021 11:11',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T11:58:27.518794-05:00' ],		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #'as yet unclassified',			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak |\rsuitStreak := OrderedCollection new.\r2 to: streaks size do: [ :i | \r\tpreviousCard := streaks at: (i-1).\r\tprevious := previousCard at: previousCard size.\r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\t(previous == current)\r\t\tifTrue: [(suitStreak isEmpty) ifTrue:[suitStreak add: previousCard]. suitStreak add: card]].\r\t\rhighestSuitStreak := OrderedCollection new.\r(suitStreak size >= 5) ifTrue: [\r\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]].\r\r^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 11:09',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak |\rsuitStreak := OrderedCollection new.\r2 to: streaks size do: [ :i | \r\tpreviousCard := streaks at: (i-1).\r\tprevious := previousCard at: previousCard size.\r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\t(previous == current)\r\t\tifTrue: [(suitStreak isEmpty) ifTrue:[suitStreak add: previousCard]. suitStreak add: card]].\r\t\rhighestSuitStreak := OrderedCollection new.\r(suitStreak size >= 5) ifTrue: [\r\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]].\r\r^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 11:09',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T12:04:54.959794-05:00' ],		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#definitionSource : 'Object subclass: #Poker\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'CPS506\'',				#superclassName : 'Object',				#traitCompositionSource : '{}'			},			#name : #Poker,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#definitionSource : 'Poker class\r\tinstanceVariableNames: \'\'',					#traitCompositionSource : '{}'				},				#name : #'Poker class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Poker,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #CPS506,			#package : #CPS506,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#definitionSource : 'Object subclass: #Poker\r\tinstanceVariableNames: \'hand\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'CPS506\'',				#superclassName : 'Object',				#traitCompositionSource : '{}'			},			#name : #Poker,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Poker,						#isMetaSide : false					},					#name : #hand,					#parent : @21				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#definitionSource : 'Poker class\r\tinstanceVariableNames: \'\'',					#traitCompositionSource : '{}'				},				#name : #'Poker class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @21			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Poker,					#isMetaSide : false				},				#parent : @21,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #CPS506,			#package : #CPS506,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T12:05:28.963794-05:00' ],		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp values suits output val newShuf |\r\tnewShuf := Array new.\r\tvalues := #(\'ace\' \'2\' \'3\' \'4\' \'5\' \'6\' \'7\' \'8\' \'9\' \'10\' \'Jack\' \'Queen\' \'King\').\r\tsuits := #(\'Clubs\' \'Diamonds\' \'Hearts\' \'Spades\').\r\t9 timesRepeat: [ :i | \r\t\tval := shuf at: i.\r\t\ttemp := val % 13.\r\t\toutput := (temp == 0) \r\t\t\tifFalse: [values at: temp]\r\t\t\tifTrue: [values at: 0]\r\t\t. \r\t\ttemp := val-1 / 13 floor. \r\t\tval at: (output size +1) put: (suits at: temp). \r\t\tnewShuf at: i put: output.\r\t].\r\t^ newShuf\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 09:58',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp values suits output val |\r\thand := Array new.\r\tvalues := #(\'ace\' \'2\' \'3\' \'4\' \'5\' \'6\' \'7\' \'8\' \'9\' \'10\' \'Jack\' \'Queen\' \'King\').\r\tsuits := #(\'Clubs\' \'Diamonds\' \'Hearts\' \'Spades\').\r\t9 timesRepeat: [ :i | \r\t\tval := shuf at: i.\r\t\ttemp := val % 13.\r\t\toutput := (temp == 0) \r\t\t\tifFalse: [values at: temp]\r\t\t\tifTrue: [values at: 0]\r\t\t. \r\t\ttemp := val-1 / 13 floor. \r\t\tval at: (output size +1) put: (suits at: temp). \r\t\thand at: i put: output.\r\t].\r\t^hand\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 12:05',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T12:06:38.127794-05:00' ],		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#definitionSource : 'Object subclass: #Poker\r\tinstanceVariableNames: \'hand\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'CPS506\'',				#superclassName : 'Object',				#traitCompositionSource : '{}'			},			#name : #Poker,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Poker,						#isMetaSide : false					},					#name : #hand,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#definitionSource : 'Poker class\r\tinstanceVariableNames: \'\'',					#traitCompositionSource : '{}'				},				#name : #'Poker class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Poker,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #CPS506,			#package : #CPS506,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#definitionSource : 'Object subclass: #Poker\r\tinstanceVariableNames: \'hand shuf\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'CPS506\'',				#superclassName : 'Object',				#traitCompositionSource : '{}'			},			#name : #Poker,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Poker,						#isMetaSide : false					},					#name : #hand,					#parent : @23				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Poker,						#isMetaSide : false					},					#name : #shuf,					#parent : @23				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#definitionSource : 'Poker class\r\tinstanceVariableNames: \'\'',					#traitCompositionSource : '{}'				},				#name : #'Poker class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @23			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Poker,					#isMetaSide : false				},				#parent : @23,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #CPS506,			#package : #CPS506,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T12:07:05.906794-05:00' ],		#prior : OmReference [ '22' ],		#self : OmReference [ '23' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#definitionSource : 'Object subclass: #Poker\r\tinstanceVariableNames: \'hand shuf\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'CPS506\'',				#superclassName : 'Object',				#traitCompositionSource : '{}'			},			#name : #Poker,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Poker,						#isMetaSide : false					},					#name : #hand,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Poker,						#isMetaSide : false					},					#name : #shuf,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#definitionSource : 'Poker class\r\tinstanceVariableNames: \'\'',					#traitCompositionSource : '{}'				},				#name : #'Poker class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Poker,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #CPS506,			#package : #CPS506,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#definitionSource : 'Object subclass: #Poker\r\tinstanceVariableNames: \'hand\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'CPS506\'',				#superclassName : 'Object',				#traitCompositionSource : '{}'			},			#name : #Poker,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Poker,						#isMetaSide : false					},					#name : #hand,					#parent : @25				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#definitionSource : 'Poker class\r\tinstanceVariableNames: \'\'',					#traitCompositionSource : '{}'				},				#name : #'Poker class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @25			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Poker,					#isMetaSide : false				},				#parent : @25,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #CPS506,			#package : #CPS506,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T12:14:57.142794-05:00' ],		#prior : OmReference [ '23' ],		#self : OmReference [ '24' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp values suits output val |\r\thand := Array new.\r\tvalues := #(\'ace\' \'2\' \'3\' \'4\' \'5\' \'6\' \'7\' \'8\' \'9\' \'10\' \'Jack\' \'Queen\' \'King\').\r\tsuits := #(\'Clubs\' \'Diamonds\' \'Hearts\' \'Spades\').\r\t9 timesRepeat: [ :i | \r\t\tval := shuf at: i.\r\t\ttemp := val % 13.\r\t\toutput := (temp == 0) \r\t\t\tifFalse: [values at: temp]\r\t\t\tifTrue: [values at: 0]\r\t\t. \r\t\ttemp := val-1 / 13 floor. \r\t\tval at: (output size +1) put: (suits at: temp). \r\t\thand at: i put: output.\r\t].\r\t^hand\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 12:05',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp values suits output val |\r\thand := Array new.\r\tvalues := #(\'ace\' \'2\' \'3\' \'4\' \'5\' \'6\' \'7\' \'8\' \'9\' \'10\' \'Jack\' \'Queen\' \'King\').\r\tsuits := #(\'Clubs\' \'Diamonds\' \'Hearts\' \'Spades\').\r\tshuf size timesRepeat: [ :i | \r\t\tval := shuf at: i.\r\t\ttemp := val % 13.\r\t\toutput := (temp == 0) \r\t\t\tifFalse: [values at: temp]\r\t\t\tifTrue: [values at: 0]\r\t\t. \r\t\ttemp := val-1 / 13 floor. \r\t\tval at: (output size +1) put: (suits at: temp). \r\t\thand at: i put: output.\r\t].\r\t^hand\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 12:14',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T12:15:40.487794-05:00' ],		#prior : OmReference [ '24' ],		#self : OmReference [ '25' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp values suits output val |\r\thand := Array new.\r\tvalues := #(\'ace\' \'2\' \'3\' \'4\' \'5\' \'6\' \'7\' \'8\' \'9\' \'10\' \'Jack\' \'Queen\' \'King\').\r\tsuits := #(\'Clubs\' \'Diamonds\' \'Hearts\' \'Spades\').\r\tshuf size timesRepeat: [ :i | \r\t\tval := shuf at: i.\r\t\ttemp := val % 13.\r\t\toutput := (temp == 0) \r\t\t\tifFalse: [values at: temp]\r\t\t\tifTrue: [values at: 0]\r\t\t. \r\t\ttemp := val-1 / 13 floor. \r\t\tval at: (output size +1) put: (suits at: temp). \r\t\thand at: i put: output.\r\t].\r\t^hand\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 12:14',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp values suits output val |\r\thand := Array new.\r\tvalues := #(\'ace\' \'2\' \'3\' \'4\' \'5\' \'6\' \'7\' \'8\' \'9\' \'10\' \'Jack\' \'Queen\' \'King\').\r\tsuits := #(\'Clubs\' \'Diamonds\' \'Hearts\' \'Spades\').\r\t9 timesRepeat: [ :i | \r\t\tval := shuf at: i.\r\t\ttemp := val % 13.\r\t\toutput := (temp == 0) \r\t\t\tifFalse: [values at: temp]\r\t\t\tifTrue: [values at: 0]\r\t\t. \r\t\ttemp := val-1 / 13 floor. \r\t\tval at: (output size +1) put: (suits at: temp). \r\t\thand at: i put: output.\r\t].\r\t^hand\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 12:15',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T12:29:24.980794-05:00' ],		#prior : OmReference [ '25' ],		#self : OmReference [ '26' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp values suits output val |\r\thand := Array new.\r\tvalues := #(\'ace\' \'2\' \'3\' \'4\' \'5\' \'6\' \'7\' \'8\' \'9\' \'10\' \'Jack\' \'Queen\' \'King\').\r\tsuits := #(\'Clubs\' \'Diamonds\' \'Hearts\' \'Spades\').\r\t9 timesRepeat: [ :i | \r\t\tval := shuf at: i.\r\t\ttemp := val % 13.\r\t\toutput := (temp == 0) \r\t\t\tifFalse: [values at: temp]\r\t\t\tifTrue: [values at: 0]\r\t\t. \r\t\ttemp := val-1 / 13 floor. \r\t\tval at: (output size +1) put: (suits at: temp). \r\t\thand at: i put: output.\r\t].\r\t^hand\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 12:15',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp values suits output val |\r\thand := Array new.\r\tvalues := #(\'ace\' \'2\' \'3\' \'4\' \'5\' \'6\' \'7\' \'8\' \'9\' \'10\' \'Jack\' \'Queen\' \'King\').\r\tsuits := #(\'Clubs\' \'Diamonds\' \'Hearts\' \'Spades\').\r\t1 to: 9 do: [ :i | \r\t\tval := shuf at: i.\r\t\ttemp := val % 13.\r\t\toutput := (temp == 0) \r\t\t\tifFalse: [values at: temp]\r\t\t\tifTrue: [values at: 13]\r\t\t. \r\t\ttemp := val-1 // 13 + 1 floor. \r\t\toutput := output , (suits at: temp). \r\t\thand at: i put: output.\r].\r^hand\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 12:29',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T12:30:06.335794-05:00' ],		#prior : OmReference [ '26' ],		#self : OmReference [ '27' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp values suits output val |\r\thand := Array new.\r\tvalues := #(\'ace\' \'2\' \'3\' \'4\' \'5\' \'6\' \'7\' \'8\' \'9\' \'10\' \'Jack\' \'Queen\' \'King\').\r\tsuits := #(\'Clubs\' \'Diamonds\' \'Hearts\' \'Spades\').\r\t1 to: 9 do: [ :i | \r\t\tval := shuf at: i.\r\t\ttemp := val % 13.\r\t\toutput := (temp == 0) \r\t\t\tifFalse: [values at: temp]\r\t\t\tifTrue: [values at: 13]\r\t\t. \r\t\ttemp := val-1 // 13 + 1 floor. \r\t\toutput := output , (suits at: temp). \r\t\thand at: i put: output.\r].\r^hand\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 12:29',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp values suits output val |\r\thand := Array new.\r\tvalues := #(\'ace\' \'2\' \'3\' \'4\' \'5\' \'6\' \'7\' \'8\' \'9\' \'10\' \'Jack\' \'Queen\' \'King\').\r\tsuits := #(\'Clubs\' \'Diamonds\' \'Hearts\' \'Spades\').\r\t1 to: (shuf size) do: [ :i | \r\t\tval := shuf at: i.\r\t\ttemp := val % 13.\r\t\toutput := (temp == 0) \r\t\t\tifFalse: [values at: temp]\r\t\t\tifTrue: [values at: 13]\r\t\t. \r\t\ttemp := val-1 // 13 + 1 floor. \r\t\toutput := output , (suits at: temp). \r\t\thand at: i put: output.\r].\r^hand\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 12:30',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T12:30:31.278794-05:00' ],		#prior : OmReference [ '27' ],		#self : OmReference [ '28' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp values suits output val |\r\thand := Array new.\r\tvalues := #(\'ace\' \'2\' \'3\' \'4\' \'5\' \'6\' \'7\' \'8\' \'9\' \'10\' \'Jack\' \'Queen\' \'King\').\r\tsuits := #(\'Clubs\' \'Diamonds\' \'Hearts\' \'Spades\').\r\t1 to: (shuf size) do: [ :i | \r\t\tval := shuf at: i.\r\t\ttemp := val % 13.\r\t\toutput := (temp == 0) \r\t\t\tifFalse: [values at: temp]\r\t\t\tifTrue: [values at: 13]\r\t\t. \r\t\ttemp := val-1 // 13 + 1 floor. \r\t\toutput := output , (suits at: temp). \r\t\thand at: i put: output.\r].\r^hand\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 12:30',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp values suits output val |\r\thand := Array new.\r\tvalues := #(\'ace\' \'2\' \'3\' \'4\' \'5\' \'6\' \'7\' \'8\' \'9\' \'10\' \'Jack\' \'Queen\' \'King\').\r\tsuits := #(\'Clubs\' \'Diamonds\' \'Hearts\' \'Spades\').\r\t1 to: (shuf size) do: [ :i | \r\t\tval := shuf at: i.\r\t\ttemp := val % 13.\r\t\toutput := (temp == 0) \r\t\t\tifTrue: [values at: 13]\r\t\t\tifFalse: [values at: temp]\r\t\t. \r\t\ttemp := val-1 // 13 + 1 floor. \r\t\toutput := output , (suits at: temp). \r\t\thand at: i put: output.\r].\r^hand\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 12:30',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T12:34:36.003794-05:00' ],		#prior : OmReference [ '28' ],		#self : OmReference [ '29' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp values suits output val |\r\thand := Array new.\r\tvalues := #(\'ace\' \'2\' \'3\' \'4\' \'5\' \'6\' \'7\' \'8\' \'9\' \'10\' \'Jack\' \'Queen\' \'King\').\r\tsuits := #(\'Clubs\' \'Diamonds\' \'Hearts\' \'Spades\').\r\t1 to: (shuf size) do: [ :i | \r\t\tval := shuf at: i.\r\t\ttemp := val % 13.\r\t\toutput := (temp == 0) \r\t\t\tifTrue: [values at: 13]\r\t\t\tifFalse: [values at: temp]\r\t\t. \r\t\ttemp := val-1 // 13 + 1 floor. \r\t\toutput := output , (suits at: temp). \r\t\thand at: i put: output.\r].\r^hand\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 12:30',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp values suits output val |\r\thand := Array new.\r\tvalues := #(\'ace\' \'2\' \'3\' \'4\' \'5\' \'6\' \'7\' \'8\' \'9\' \'10\' \'Jack\' \'Queen\' \'King\').\r\tsuits := #(\'Clubs\' \'Diamonds\' \'Hearts\' \'Spades\').\r\t(shuf size) timesRepeat: [ :i | \r\t\tval := shuf at: i.\r\t\ttemp := val % 13.\r\t\toutput := (temp == 0) \r\t\t\tifTrue: [values at: 13]\r\t\t\tifFalse: [values at: temp]\r\t\t. \r\t\ttemp := val-1 // 13 + 1 floor. \r\t\toutput := output , (suits at: temp). \r\t\thand at: i put: output.\r].\r^hand\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 12:34',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T12:35:49.171794-05:00' ],		#prior : OmReference [ '29' ],		#self : OmReference [ '30' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp values suits output val |\r\thand := Array new.\r\tvalues := #(\'ace\' \'2\' \'3\' \'4\' \'5\' \'6\' \'7\' \'8\' \'9\' \'10\' \'Jack\' \'Queen\' \'King\').\r\tsuits := #(\'Clubs\' \'Diamonds\' \'Hearts\' \'Spades\').\r\t(shuf size) timesRepeat: [ :i | \r\t\tval := shuf at: i.\r\t\ttemp := val % 13.\r\t\toutput := (temp == 0) \r\t\t\tifTrue: [values at: 13]\r\t\t\tifFalse: [values at: temp]\r\t\t. \r\t\ttemp := val-1 // 13 + 1 floor. \r\t\toutput := output , (suits at: temp). \r\t\thand at: i put: output.\r].\r^hand\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 12:34',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp values suits output val |\r\thand := Array new.\r\tvalues := #(\'ace\' \'2\' \'3\' \'4\' \'5\' \'6\' \'7\' \'8\' \'9\' \'10\' \'Jack\' \'Queen\' \'King\').\r\tsuits := #(\'Clubs\' \'Diamonds\' \'Hearts\' \'Spades\').\r\t1 to: (shuf size) do: [ :i | \r\t\tval := shuf at: i.\r\t\ttemp := val % 13.\r\t\toutput := (temp == 0) \r\t\t\tifTrue: [values at: 13]\r\t\t\tifFalse: [values at: temp]\r\t\t. \r\t\ttemp := val-1 // 13 + 1 floor. \r\t\toutput := output , (suits at: temp). \r\t\thand at: i put: output.\r].\r^hand\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 12:35',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T12:38:01.824794-05:00' ],		#prior : OmReference [ '30' ],		#self : OmReference [ '31' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp values suits output val |\r\thand := Array new.\r\tvalues := #(\'ace\' \'2\' \'3\' \'4\' \'5\' \'6\' \'7\' \'8\' \'9\' \'10\' \'Jack\' \'Queen\' \'King\').\r\tsuits := #(\'Clubs\' \'Diamonds\' \'Hearts\' \'Spades\').\r\t1 to: (shuf size) do: [ :i | \r\t\tval := shuf at: i.\r\t\ttemp := val % 13.\r\t\toutput := (temp == 0) \r\t\t\tifTrue: [values at: 13]\r\t\t\tifFalse: [values at: temp]\r\t\t. \r\t\ttemp := val-1 // 13 + 1 floor. \r\t\toutput := output , (suits at: temp). \r\t\thand at: i put: output.\r].\r^hand\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 12:35',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp values suits output val |\r\thand := Array new: 9.\r\tvalues := #(\'ace\' \'2\' \'3\' \'4\' \'5\' \'6\' \'7\' \'8\' \'9\' \'10\' \'Jack\' \'Queen\' \'King\').\r\tsuits := #(\'Clubs\' \'Diamonds\' \'Hearts\' \'Spades\').\r1 to: 9 do: [ :i | \r\tTranscript cr.\r\tTranscript show: i; cr.\r\tval := shuf at: i.\r\tTranscript show: val; cr.\r\ttemp := val % 13.\r\tTranscript show: temp; cr.\r\toutput := (temp == 0) \r\t\tifFalse: [values at: temp]\r\t\tifTrue: [values at: 13]\r\t. \r\tTranscript show: output; cr.\r\ttemp := val-1 // 13 + 1 floor. \r\tTranscript show: temp; cr.\r\toutput := output , (suits at: temp). \r\tTranscript show: output; cr.\r\thand at: i put: output.\r\tTranscript show: hand; cr.\r].\r^hand\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 12:38',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T12:46:25.874794-05:00' ],		#prior : OmReference [ '31' ],		#self : OmReference [ '32' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp values suits output val |\r\thand := Array new: 9.\r\tvalues := #(\'ace\' \'2\' \'3\' \'4\' \'5\' \'6\' \'7\' \'8\' \'9\' \'10\' \'Jack\' \'Queen\' \'King\').\r\tsuits := #(\'Clubs\' \'Diamonds\' \'Hearts\' \'Spades\').\r1 to: 9 do: [ :i | \r\tTranscript cr.\r\tTranscript show: i; cr.\r\tval := shuf at: i.\r\tTranscript show: val; cr.\r\ttemp := val % 13.\r\tTranscript show: temp; cr.\r\toutput := (temp == 0) \r\t\tifFalse: [values at: temp]\r\t\tifTrue: [values at: 13]\r\t. \r\tTranscript show: output; cr.\r\ttemp := val-1 // 13 + 1 floor. \r\tTranscript show: temp; cr.\r\toutput := output , (suits at: temp). \r\tTranscript show: output; cr.\r\thand at: i put: output.\r\tTranscript show: hand; cr.\r].\r^hand\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 12:38',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp values suits output val |\r\thand := Array new: 9.\r\tvalues := #(\'1\' \'2\' \'3\' \'4\' \'5\' \'6\' \'7\' \'8\' \'9\' \'10\' \'11\' \'12\' \'13\').\r\tsuits := #(\'C\' \'D\' \'H\' \'S\').\r1 to: 9 do: [ :i | \r\tTranscript cr.\r\tTranscript show: i; cr.\r\tval := shuf at: i.\r\tTranscript show: val; cr.\r\ttemp := val % 13.\r\tTranscript show: temp; cr.\r\toutput := (temp == 0) \r\t\tifFalse: [values at: temp]\r\t\tifTrue: [values at: 13]\r\t. \r\tTranscript show: output; cr.\r\ttemp := val-1 // 13 + 1 floor. \r\tTranscript show: temp; cr.\r\toutput := output , (suits at: temp). \r\tTranscript show: output; cr.\r\thand at: i put: output.\r\tTranscript show: hand; cr.\r].\r^hand\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 12:46',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T12:47:03.231794-05:00' ],		#prior : OmReference [ '32' ],		#self : OmReference [ '33' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp values suits output val |\r\thand := Array new: 9.\r\tvalues := #(\'1\' \'2\' \'3\' \'4\' \'5\' \'6\' \'7\' \'8\' \'9\' \'10\' \'11\' \'12\' \'13\').\r\tsuits := #(\'C\' \'D\' \'H\' \'S\').\r1 to: 9 do: [ :i | \r\tTranscript cr.\r\tTranscript show: i; cr.\r\tval := shuf at: i.\r\tTranscript show: val; cr.\r\ttemp := val % 13.\r\tTranscript show: temp; cr.\r\toutput := (temp == 0) \r\t\tifFalse: [values at: temp]\r\t\tifTrue: [values at: 13]\r\t. \r\tTranscript show: output; cr.\r\ttemp := val-1 // 13 + 1 floor. \r\tTranscript show: temp; cr.\r\toutput := output , (suits at: temp). \r\tTranscript show: output; cr.\r\thand at: i put: output.\r\tTranscript show: hand; cr.\r].\r^hand\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 12:46',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp values suits output val |\r\thand := Array new: 9.\r\tvalues := #(\'1\' \'2\' \'3\' \'4\' \'5\' \'6\' \'7\' \'8\' \'9\' \'10\' \'11\' \'12\' \'13\').\r\tsuits := #(\'C\' \'D\' \'H\' \'S\').\r1 to: 9 do: [ :i | \r\tval := shuf at: i.\r\ttemp := val % 13.\r\toutput := (temp == 0) \r\t\tifFalse: [values at: temp]\r\t\tifTrue: [values at: 13]\r\t. \r\ttemp := val-1 // 13 + 1 floor. \r\toutput := output , (suits at: temp). \r\thand at: i put: output.\r].\r^hand\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 12:47',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T12:48:01.522794-05:00' ],		#prior : OmReference [ '33' ],		#self : OmReference [ '34' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp values suits output val |\r\thand := Array new: 9.\r\tvalues := #(\'1\' \'2\' \'3\' \'4\' \'5\' \'6\' \'7\' \'8\' \'9\' \'10\' \'11\' \'12\' \'13\').\r\tsuits := #(\'C\' \'D\' \'H\' \'S\').\r1 to: 9 do: [ :i | \r\tval := shuf at: i.\r\ttemp := val % 13.\r\toutput := (temp == 0) \r\t\tifFalse: [values at: temp]\r\t\tifTrue: [values at: 13]\r\t. \r\ttemp := val-1 // 13 + 1 floor. \r\toutput := output , (suits at: temp). \r\thand at: i put: output.\r].\r^hand\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 12:47',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp values suits output val |\r\thand := Array new: 9.\r\tvalues := #(\'1\' \'2\' \'3\' \'4\' \'5\' \'6\' \'7\' \'8\' \'9\' \'10\' \'11\' \'12\' \'13\').\r\tsuits := #(\'C\' \'D\' \'H\' \'S\').\r9 timesRepeat: [ :i | \r\tval := shuf at: i.\r\ttemp := val % 13.\r\toutput := (temp == 0) \r\t\tifFalse: [values at: temp]\r\t\tifTrue: [values at: 13]\r\t. \r\ttemp := val-1 // 13 + 1 floor. \r\toutput := output , (suits at: temp). \r\thand at: i put: output.\r].\r^hand\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 12:48',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T12:48:10.428794-05:00' ],		#prior : OmReference [ '34' ],		#self : OmReference [ '35' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp values suits output val |\r\thand := Array new: 9.\r\tvalues := #(\'1\' \'2\' \'3\' \'4\' \'5\' \'6\' \'7\' \'8\' \'9\' \'10\' \'11\' \'12\' \'13\').\r\tsuits := #(\'C\' \'D\' \'H\' \'S\').\r9 timesRepeat: [ :i | \r\tval := shuf at: i.\r\ttemp := val % 13.\r\toutput := (temp == 0) \r\t\tifFalse: [values at: temp]\r\t\tifTrue: [values at: 13]\r\t. \r\ttemp := val-1 // 13 + 1 floor. \r\toutput := output , (suits at: temp). \r\thand at: i put: output.\r].\r^hand\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 12:48',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp values suits output val |\r\thand := Array new: 9.\r\tvalues := #(\'1\' \'2\' \'3\' \'4\' \'5\' \'6\' \'7\' \'8\' \'9\' \'10\' \'11\' \'12\' \'13\').\r\tsuits := #(\'C\' \'D\' \'H\' \'S\').\r1 to: 9 do: [ :i | \r\tval := shuf at: i.\r\ttemp := val % 13.\r\toutput := (temp == 0) \r\t\tifFalse: [values at: temp]\r\t\tifTrue: [values at: 13]\r\t. \r\ttemp := val-1 // 13 + 1 floor. \r\toutput := output , (suits at: temp). \r\thand at: i put: output.\r].\r^hand\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 12:48',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T12:51:55.715794-05:00' ],		#prior : OmReference [ '35' ],		#self : OmReference [ '36' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'convert:',			#protocol : #'as yet unclassified',			#sourceCode : 'convert: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp values suits output val |\r\thand := Array new: 9.\r\tvalues := #(\'1\' \'2\' \'3\' \'4\' \'5\' \'6\' \'7\' \'8\' \'9\' \'10\' \'11\' \'12\' \'13\').\r\tsuits := #(\'C\' \'D\' \'H\' \'S\').\r\t1 to: 9 do: [ :i | \r\t\tval := shuf at: i.\r\t\ttemp := val % 13.\r\t\toutput := (temp == 0) \r\t\t\tifFalse: [values at: temp]\r\t\t\tifTrue: [values at: 13]\r\t\t. \r\t\ttemp := val-1 // 13 + 1 floor. \r\t\toutput := output , (suits at: temp). \r\t\thand at: i put: output.\r\t].\r\t^hand',			#stamp : 'MagdalenaDhima 1/30/2021 12:51',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T12:51:55.738794-05:00' ],		#prior : OmReference [ '36' ],		#self : OmReference [ '37' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'convert:',			#protocol : #'as yet unclassified',			#sourceCode : 'convert: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp values suits output val |\r\thand := Array new: 9.\r\tvalues := #(\'1\' \'2\' \'3\' \'4\' \'5\' \'6\' \'7\' \'8\' \'9\' \'10\' \'11\' \'12\' \'13\').\r\tsuits := #(\'C\' \'D\' \'H\' \'S\').\r\t1 to: 9 do: [ :i | \r\t\tval := shuf at: i.\r\t\ttemp := val % 13.\r\t\toutput := (temp == 0) \r\t\t\tifFalse: [values at: temp]\r\t\t\tifTrue: [values at: 13]\r\t\t. \r\t\ttemp := val-1 // 13 + 1 floor. \r\t\toutput := output , (suits at: temp). \r\t\thand at: i put: output.\r\t].\r\t^hand',			#stamp : 'MagdalenaDhima 1/30/2021 12:51',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'convert:',			#protocol : #actions,			#sourceCode : 'convert: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp values suits output val |\r\thand := Array new: 9.\r\tvalues := #(\'1\' \'2\' \'3\' \'4\' \'5\' \'6\' \'7\' \'8\' \'9\' \'10\' \'11\' \'12\' \'13\').\r\tsuits := #(\'C\' \'D\' \'H\' \'S\').\r\t1 to: 9 do: [ :i | \r\t\tval := shuf at: i.\r\t\ttemp := val % 13.\r\t\toutput := (temp == 0) \r\t\t\tifFalse: [values at: temp]\r\t\t\tifTrue: [values at: 13]\r\t\t. \r\t\ttemp := val-1 // 13 + 1 floor. \r\t\toutput := output , (suits at: temp). \r\t\thand at: i put: output.\r\t].\r\t^hand',			#stamp : 'MagdalenaDhima 1/30/2021 12:51',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T12:52:08.307794-05:00' ],		#prior : OmReference [ '37' ],		#self : OmReference [ '38' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'convert:',			#protocol : #actions,			#sourceCode : 'convert: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp values suits output val |\r\thand := Array new: 9.\r\tvalues := #(\'1\' \'2\' \'3\' \'4\' \'5\' \'6\' \'7\' \'8\' \'9\' \'10\' \'11\' \'12\' \'13\').\r\tsuits := #(\'C\' \'D\' \'H\' \'S\').\r\t1 to: 9 do: [ :i | \r\t\tval := shuf at: i.\r\t\ttemp := val % 13.\r\t\toutput := (temp == 0) \r\t\t\tifFalse: [values at: temp]\r\t\t\tifTrue: [values at: 13]\r\t\t. \r\t\ttemp := val-1 // 13 + 1 floor. \r\t\toutput := output , (suits at: temp). \r\t\thand at: i put: output.\r\t].\r\t^hand',			#stamp : 'MagdalenaDhima 1/30/2021 12:51',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'convert:',			#protocol : #actions,			#sourceCode : 'convert: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp values suits output val |\r\thand := Array new: 9.\r\tvalues := #(\'1\' \'2\' \'3\' \'4\' \'5\' \'6\' \'7\' \'8\' \'9\' \'10\' \'11\' \'12\' \'13\').\r\tsuits := #(\'C\' \'D\' \'H\' \'S\').\r\t1 to: 9 do: [ :i | \r\t\tval := shuf at: i.\r\t\ttemp := val % 13.\r\t\toutput := (temp == 0) \r\t\t\tifFalse: [values at: temp]\r\t\t\tifTrue: [values at: 13]\r\t\t. \r\t\ttemp := val-1 // 13 + 1 floor. \r\t\toutput := output , (suits at: temp). \r\t\thand at: i put: output.\r\t].',			#stamp : 'MagdalenaDhima 1/30/2021 12:52',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T12:54:40.724794-05:00' ],		#prior : OmReference [ '38' ],		#self : OmReference [ '39' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #convert,			#protocol : #actions,			#sourceCode : 'convert\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp values suits output val |\r\thand := Array new: 9.\r\tvalues := #(\'1\' \'2\' \'3\' \'4\' \'5\' \'6\' \'7\' \'8\' \'9\' \'10\' \'11\' \'12\' \'13\').\r\tsuits := #(\'C\' \'D\' \'H\' \'S\').\r\t1 to: 9 do: [ :i | \r\t\tval := hand at: i.\r\t\ttemp := val % 13.\r\t\toutput := (temp == 0) \r\t\t\tifFalse: [values at: temp]\r\t\t\tifTrue: [values at: 13]\r\t\t. \r\t\ttemp := val-1 // 13 + 1 floor. \r\t\toutput := output , (suits at: temp). \r\t\thand at: i put: output.\r\t].',			#stamp : 'MagdalenaDhima 1/30/2021 12:54',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T12:54:57.872794-05:00' ],		#prior : OmReference [ '39' ],		#self : OmReference [ '40' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp values suits output val |\r\thand := Array new: 9.\r\tvalues := #(\'1\' \'2\' \'3\' \'4\' \'5\' \'6\' \'7\' \'8\' \'9\' \'10\' \'11\' \'12\' \'13\').\r\tsuits := #(\'C\' \'D\' \'H\' \'S\').\r1 to: 9 do: [ :i | \r\tval := shuf at: i.\r\ttemp := val % 13.\r\toutput := (temp == 0) \r\t\tifFalse: [values at: temp]\r\t\tifTrue: [values at: 13]\r\t. \r\ttemp := val-1 // 13 + 1 floor. \r\toutput := output , (suits at: temp). \r\thand at: i put: output.\r].\r^hand\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 12:48',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\thand := shuf.\r\thand := hand convert.\r\t^hand\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 12:54',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T12:56:21.018794-05:00' ],		#prior : OmReference [ '40' ],		#self : OmReference [ '41' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'convert:',			#protocol : #actions,			#sourceCode : 'convert: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp values suits output val |\r\thand := Array new: 9.\r\tvalues := #(\'1\' \'2\' \'3\' \'4\' \'5\' \'6\' \'7\' \'8\' \'9\' \'10\' \'11\' \'12\' \'13\').\r\tsuits := #(\'C\' \'D\' \'H\' \'S\').\r\t1 to: 9 do: [ :i | \r\t\tval := shuf at: i.\r\t\ttemp := val % 13.\r\t\toutput := (temp == 0) \r\t\t\tifFalse: [values at: temp]\r\t\t\tifTrue: [values at: 13]\r\t\t. \r\t\ttemp := val-1 // 13 + 1 floor. \r\t\toutput := output , (suits at: temp). \r\t\thand at: i put: output.\r\t].',			#stamp : 'MagdalenaDhima 1/30/2021 12:52',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'convert:',			#protocol : #'as yet unclassified',			#sourceCode : 'convert: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp values suits output val |\r\thand := Array new: 9.\r\tvalues := #(\'1\' \'2\' \'3\' \'4\' \'5\' \'6\' \'7\' \'8\' \'9\' \'10\' \'11\' \'12\' \'13\').\r\tsuits := #(\'C\' \'D\' \'H\' \'S\').\r\t1 to: 9 do: [ :i | \r\t\tval := shuf at: i.\r\t\ttemp := val % 13.\r\t\toutput := (temp == 0) \r\t\t\tifFalse: [values at: temp]\r\t\t\tifTrue: [values at: 13]\r\t\t. \r\t\ttemp := val-1 // 13 + 1 floor. \r\t\toutput := output , (suits at: temp). \r\t\thand at: i put: output.\r\t].',			#stamp : 'MagdalenaDhima 1/30/2021 12:52',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T12:56:21.069794-05:00' ],		#prior : OmReference [ '41' ],		#self : OmReference [ '42' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'convert:',			#protocol : #actions,			#sourceCode : 'convert: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp values suits output val |\r\thand := Array new: 9.\r\tvalues := #(\'1\' \'2\' \'3\' \'4\' \'5\' \'6\' \'7\' \'8\' \'9\' \'10\' \'11\' \'12\' \'13\').\r\tsuits := #(\'C\' \'D\' \'H\' \'S\').\r\t1 to: 9 do: [ :i | \r\t\tval := shuf at: i.\r\t\ttemp := val % 13.\r\t\toutput := (temp == 0) \r\t\t\tifFalse: [values at: temp]\r\t\t\tifTrue: [values at: 13]\r\t\t. \r\t\ttemp := val-1 // 13 + 1 floor. \r\t\toutput := output , (suits at: temp). \r\t\thand at: i put: output.\r\t].',			#stamp : 'MagdalenaDhima 1/30/2021 12:52',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T12:56:56.459794-05:00' ],		#prior : OmReference [ '42' ],		#self : OmReference [ '43' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'convert:',			#protocol : #actions,			#sourceCode : 'convert: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp values suits output val |\r\thand := Array new: 9.\r\tvalues := #(\'1\' \'2\' \'3\' \'4\' \'5\' \'6\' \'7\' \'8\' \'9\' \'10\' \'11\' \'12\' \'13\').\r\tsuits := #(\'C\' \'D\' \'H\' \'S\').\r\t1 to: 9 do: [ :i | \r\t\tval := shuf at: i.\r\t\ttemp := val % 13.\r\t\toutput := (temp == 0) \r\t\t\tifFalse: [values at: temp]\r\t\t\tifTrue: [values at: 13]\r\t\t. \r\t\ttemp := val-1 // 13 + 1 floor. \r\t\toutput := output , (suits at: temp). \r\t\thand at: i put: output.\r\t].',			#stamp : 'MagdalenaDhima 1/30/2021 12:56',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T13:01:30.206794-05:00' ],		#prior : OmReference [ '43' ],		#self : OmReference [ '44' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'convert:',			#protocol : #actions,			#sourceCode : 'convert: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp values suits output val |\r\thand := Array new: 9.\r\tvalues := #(\'1\' \'2\' \'3\' \'4\' \'5\' \'6\' \'7\' \'8\' \'9\' \'10\' \'11\' \'12\' \'13\').\r\tsuits := #(\'C\' \'D\' \'H\' \'S\').\r\t1 to: 9 do: [ :i | \r\t\tval := shuf at: i.\r\t\ttemp := val % 13.\r\t\toutput := (temp == 0) \r\t\t\tifFalse: [values at: temp]\r\t\t\tifTrue: [values at: 13]\r\t\t. \r\t\ttemp := val-1 // 13 + 1 floor. \r\t\toutput := output , (suits at: temp). \r\t\thand at: i put: output.\r\t].',			#stamp : 'MagdalenaDhima 1/30/2021 12:56',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'convert:',			#protocol : #'as yet unclassified',			#sourceCode : 'convert: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp values suits output val |\r\thand := Array new: 9.\r\tvalues := #(\'1\' \'2\' \'3\' \'4\' \'5\' \'6\' \'7\' \'8\' \'9\' \'10\' \'11\' \'12\' \'13\').\r\tsuits := #(\'C\' \'D\' \'H\' \'S\').\r\t1 to: 9 do: [ :i | \r\t\tval := shuf at: i.\r\t\ttemp := val % 13.\r\t\toutput := (temp == 0) \r\t\t\tifFalse: [values at: temp]\r\t\t\tifTrue: [values at: 13]\r\t\t. \r\t\ttemp := val-1 // 13 + 1 floor. \r\t\toutput := output , (suits at: temp). \r\t\thand at: i put: output.\r\t].',			#stamp : 'MagdalenaDhima 1/30/2021 12:56',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T13:01:30.209794-05:00' ],		#prior : OmReference [ '44' ],		#self : OmReference [ '45' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'convert:',			#protocol : #actions,			#sourceCode : 'convert: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp values suits output val |\r\thand := Array new: 9.\r\tvalues := #(\'1\' \'2\' \'3\' \'4\' \'5\' \'6\' \'7\' \'8\' \'9\' \'10\' \'11\' \'12\' \'13\').\r\tsuits := #(\'C\' \'D\' \'H\' \'S\').\r\t1 to: 9 do: [ :i | \r\t\tval := shuf at: i.\r\t\ttemp := val % 13.\r\t\toutput := (temp == 0) \r\t\t\tifFalse: [values at: temp]\r\t\t\tifTrue: [values at: 13]\r\t\t. \r\t\ttemp := val-1 // 13 + 1 floor. \r\t\toutput := output , (suits at: temp). \r\t\thand at: i put: output.\r\t].',			#stamp : 'MagdalenaDhima 1/30/2021 12:56',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T13:02:20.067794-05:00' ],		#prior : OmReference [ '45' ],		#self : OmReference [ '46' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\thand := shuf.\r\thand := hand convert.\r\t^hand\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 12:54',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\thand := self convert.\r\t^hand\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 13:02',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T13:03:27.331794-05:00' ],		#prior : OmReference [ '46' ],		#self : OmReference [ '47' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\thand := self convert.\r\t^hand\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 13:02',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\thand := self convert: shuf.\r\t^hand\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 13:03',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T13:03:53.471794-05:00' ],		#prior : OmReference [ '47' ],		#self : OmReference [ '48' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'convert:',			#protocol : #actions,			#sourceCode : 'convert: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp values suits output val |\r\thand := Array new: 9.\r\tvalues := #(\'1\' \'2\' \'3\' \'4\' \'5\' \'6\' \'7\' \'8\' \'9\' \'10\' \'11\' \'12\' \'13\').\r\tsuits := #(\'C\' \'D\' \'H\' \'S\').\r\t1 to: 9 do: [ :i | \r\t\tval := shuf at: i.\r\t\ttemp := val % 13.\r\t\toutput := (temp == 0) \r\t\t\tifFalse: [values at: temp]\r\t\t\tifTrue: [values at: 13]\r\t\t. \r\t\ttemp := val-1 // 13 + 1 floor. \r\t\toutput := output , (suits at: temp). \r\t\thand at: i put: output.\r\t].',			#stamp : 'MagdalenaDhima 1/30/2021 13:03',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T13:04:06.286794-05:00' ],		#prior : OmReference [ '48' ],		#self : OmReference [ '49' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\thand := self convert: shuf.\r\t^hand\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 13:03',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\tself convert: shuf.\r\t^hand\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 13:04',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T13:05:34.645794-05:00' ],		#prior : OmReference [ '49' ],		#self : OmReference [ '50' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #getData,			#protocol : #accessing,			#sourceCode : 'getData\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| dataInHand card temp temp2 |\r\t\rdataInHand := Dictionary new. \r1 to: 13 do: [ :i | dataInHand at: i put: 0].\rdataInHand at: \'C\' put: 0. dataInHand at: \'D\' put: 0. dataInHand at: \'H\' put: 0. dataInHand at: \'S\' put: 0.\r\r\r1 to: (hand size) do: [ :i |\r\tcard := hand at: i.\r\ttemp := (card copyFrom: 1 to: (card size-1)).\r\ttemp2 := card at: (card size).\r\tdataInHand at: temp asNumber put: ((dataInHand at: temp asNumber) +1 ).\r\tdataInHand at: temp2 asString put: ((dataInHand at: temp2 asString) +1 ).\r ].\r^dataInHand',			#stamp : 'MagdalenaDhima 1/30/2021 13:05',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T13:06:42.272794-05:00' ],		#prior : OmReference [ '50' ],		#self : OmReference [ '51' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\tself convert: shuf.\r\t^hand\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 13:04',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted |\r\tself convert: shuf.\r\tsorted := self getData.\r\t^hand\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 13:06',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T13:06:58.699794-05:00' ],		#prior : OmReference [ '51' ],		#self : OmReference [ '52' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted |\r\tself convert: shuf.\r\tsorted := self getData.\r\t^hand\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 13:06',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted |\r\tself convert: shuf.\r\tsorted := self getData.\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 13:06',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T13:08:46.878794-05:00' ],		#prior : OmReference [ '52' ],		#self : OmReference [ '53' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getData:',			#protocol : #accessing,			#sourceCode : 'getData: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| dataInHand card temp temp2 |\r\t\rdataInHand := Dictionary new. \r1 to: 13 do: [ :i | dataInHand at: i put: 0].\rdataInHand at: \'C\' put: 0. dataInHand at: \'D\' put: 0. dataInHand at: \'H\' put: 0. dataInHand at: \'S\' put: 0.\r\r\r1 to: 9 do: [ :i |\r\tcard := nice at: i.\r\ttemp := (card copyFrom: 1 to: (card size-1)).\r\ttemp2 := card at: (card size).\r\tdataInHand at: temp asNumber put: ((dataInHand at: temp asNumber) +1 ).\r\tdataInHand at: temp2 asString put: ((dataInHand at: temp2 asString) +1 ).\r ].\r^dataInHand',			#stamp : 'MagdalenaDhima 1/30/2021 10:10',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getData:',			#protocol : #'as yet unclassified',			#sourceCode : 'getData: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| dataInHand card temp temp2 |\r\t\rdataInHand := Dictionary new. \r1 to: 13 do: [ :i | dataInHand at: i put: 0].\rdataInHand at: \'C\' put: 0. dataInHand at: \'D\' put: 0. dataInHand at: \'H\' put: 0. dataInHand at: \'S\' put: 0.\r\r\r1 to: 9 do: [ :i |\r\tcard := nice at: i.\r\ttemp := (card copyFrom: 1 to: (card size-1)).\r\ttemp2 := card at: (card size).\r\tdataInHand at: temp asNumber put: ((dataInHand at: temp asNumber) +1 ).\r\tdataInHand at: temp2 asString put: ((dataInHand at: temp2 asString) +1 ).\r ].\r^dataInHand',			#stamp : 'MagdalenaDhima 1/30/2021 10:10',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T13:08:46.935794-05:00' ],		#prior : OmReference [ '53' ],		#self : OmReference [ '54' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getData:',			#protocol : #accessing,			#sourceCode : 'getData: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| dataInHand card temp temp2 |\r\t\rdataInHand := Dictionary new. \r1 to: 13 do: [ :i | dataInHand at: i put: 0].\rdataInHand at: \'C\' put: 0. dataInHand at: \'D\' put: 0. dataInHand at: \'H\' put: 0. dataInHand at: \'S\' put: 0.\r\r\r1 to: 9 do: [ :i |\r\tcard := nice at: i.\r\ttemp := (card copyFrom: 1 to: (card size-1)).\r\ttemp2 := card at: (card size).\r\tdataInHand at: temp asNumber put: ((dataInHand at: temp asNumber) +1 ).\r\tdataInHand at: temp2 asString put: ((dataInHand at: temp2 asString) +1 ).\r ].\r^dataInHand',			#stamp : 'MagdalenaDhima 1/30/2021 10:10',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T13:09:11.458794-05:00' ],		#prior : OmReference [ '54' ],		#self : OmReference [ '55' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted |\r\tself convert: shuf.\r\tsorted := self getData.\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 13:06',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data |\r\tself convert: shuf.\r\tTranscript show: hand.\r\t\r\t\r\t\r\tdata := self getData.\r\tTranscript show: data.\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 13:09',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T13:09:35.522794-05:00' ],		#prior : OmReference [ '55' ],		#self : OmReference [ '56' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data |\r\tself convert: shuf.\r\tTranscript show: hand.\r\t\r\t\r\t\r\tdata := self getData.\r\tTranscript show: data.\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 13:09',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data |\r\tself convert: shuf.\r\tTranscript show: hand; cr.\r\t\r\t\r\t\r\tdata := self getData.\r\tTranscript show: data; cr.\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 13:09',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T13:11:08.485794-05:00' ],		#prior : OmReference [ '56' ],		#self : OmReference [ '57' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sort:',			#protocol : #sorting,			#sourceCode : 'sort: newShuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| threeDigits twoDigits nice |\rthreeDigits := SortedCollection new. \rtwoDigits := SortedCollection new.\r\r1 to: 9 do: [ :i | ((newShuf at: i) size == 3) ifTrue: [threeDigits add: (newShuf at: i)] ifFalse: [twoDigits add: (newShuf at: i)]. ].\rnice :=  (twoDigits asArray) , (threeDigits asArray).\r^nice',			#stamp : 'MagdalenaDhima 1/30/2021 09:57',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'sort:',			#protocol : #sorting,			#sourceCode : 'sort: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| threeDigits twoDigits sorted |\rthreeDigits := SortedCollection new. \rtwoDigits := SortedCollection new.\r\r1 to: 9 do: [ :i | ((shuf at: i) size == 3) ifTrue: [threeDigits add: (shuf at: i)] ifFalse: [twoDigits add: (shuf at: i)]. ].\rsorted :=  (twoDigits asArray) , (threeDigits asArray).\r^sorted',			#stamp : 'MagdalenaDhima 1/30/2021 13:11',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T13:12:14.732794-05:00' ],		#prior : OmReference [ '57' ],		#self : OmReference [ '58' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data |\r\tself convert: shuf.\r\tTranscript show: hand; cr.\r\t\r\t\r\t\r\tdata := self getData.\r\tTranscript show: data; cr.\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 13:09',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data |\r\tself convert: shuf.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: sorted; cr.\r\t\r\tdata := self getData.\r\tTranscript show: data; cr.\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 13:12',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T13:16:42.081794-05:00' ],		#prior : OmReference [ '58' ],		#self : OmReference [ '59' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data |\r\tself convert: shuf.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: sorted; cr.\r\t\r\tdata := self getData.\r\tTranscript show: data; cr.\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 13:12',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data topFive |\r\tself convert: shuf.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: sorted; cr.\r\t\r\tdata := self getData.\r\tTranscript show: data; cr.\r\t\r\ttopFive := self getHighestStreak: sorted.\r\tTranscript show: topFive; cr.\r\t\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 13:16',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T13:19:16.490794-05:00' ],		#prior : OmReference [ '59' ],		#self : OmReference [ '60' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data topFive |\r\tself convert: shuf.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: sorted; cr.\r\t\r\tdata := self getData.\r\tTranscript show: data; cr.\r\t\r\ttopFive := self getHighestStreak: sorted.\r\tTranscript show: topFive; cr.\r\t\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 13:16',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flush |\r\tself convert: shuf.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: sorted; cr.\r\t\r\tdata := self getData.\r\tTranscript show: data; cr.\r\t\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: straight; cr.\r\t\r\tflush := self getHighestSuitStreak: sorted.\r\tTranscript show: flush; cr.\r\t\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 13:19',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T13:51:20.478794-05:00' ],		#prior : OmReference [ '60' ],		#self : OmReference [ '61' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flush |\r\tself convert: shuf.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: sorted; cr.\r\t\r\tdata := self getData.\r\tTranscript show: data; cr.\r\t\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: straight; cr.\r\t\r\tflush := self getHighestSuitStreak: sorted.\r\tTranscript show: flush; cr.\r\t\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 13:19',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flush straightFlush |\r\tself convert: shuf.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: sorted; cr.\r\t\r\tdata := self getData.\r\tTranscript show: data; cr.\r\t\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: straight; cr.\r\t\r\tflush := self getHighestSuitStreak: sorted.\r\tTranscript show: flush; cr.\r\t\r\tstraightFlush := self getHighestStreak: flush.\r\tTranscript show: straightFlush; cr.\r\t\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 13:51',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T13:53:14.481794-05:00' ],		#prior : OmReference [ '61' ],		#self : OmReference [ '62' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flush straightFlush |\r\tself convert: shuf.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: sorted; cr.\r\t\r\tdata := self getData.\r\tTranscript show: data; cr.\r\t\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: straight; cr.\r\t\r\tflush := self getHighestSuitStreak: sorted.\r\tTranscript show: flush; cr.\r\t\r\tstraightFlush := self getHighestStreak: flush.\r\tTranscript show: straightFlush; cr.\r\t\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 13:51',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flush straightFlush |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tflush := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flush\'; cr.\r\tTranscript show: flush; cr.\r\t\r\tstraightFlush := self getHighestStreak: flush.\r\tTranscript show: straightFlush; cr.\r\t\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 13:53',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T13:55:51.339794-05:00' ],		#prior : OmReference [ '62' ],		#self : OmReference [ '63' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: 9 do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\r\t(previous asNumber == (current asNumber -1) & notFound)\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r]].\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak',			#stamp : 'MagdalenaDhima 1/30/2021 11:11',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: (nice size) do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\r\t(previous asNumber == (current asNumber -1) & notFound)\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r]].\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak',			#stamp : 'MagdalenaDhima 1/30/2021 13:55',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T13:56:05.334794-05:00' ],		#prior : OmReference [ '63' ],		#self : OmReference [ '64' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: (nice size) do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\r\t(previous asNumber == (current asNumber -1) & notFound)\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r]].\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak',			#stamp : 'MagdalenaDhima 1/30/2021 13:55',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\r\t(previous asNumber == (current asNumber -1) & notFound)\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r]].\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak',			#stamp : 'MagdalenaDhima 1/30/2021 13:56',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T13:56:45.251794-05:00' ],		#prior : OmReference [ '64' ],		#self : OmReference [ '65' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flush straightFlush |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tflush := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flush\'; cr.\r\tTranscript show: flush; cr.\r\t\r\tstraightFlush := self getHighestStreak: flush.\r\tTranscript show: straightFlush; cr.\r\t\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 13:53',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flush straightFlush |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tflush := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flush\'; cr.\r\tTranscript show: flush; cr.\r\t\r\tstraightFlush := self getHighestStreak: flush.\r\tTranscript show: \'straightFlush\'; cr.\r\tTranscript show: straightFlush; cr.\r\t\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 13:56',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T14:45:25.731794-05:00' ],		#prior : OmReference [ '65' ],		#self : OmReference [ '66' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'returnSuitCards:',			#protocol : #accessing,			#sourceCode : 'returnSuitCards: suitCard\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| cardsOfAKind card temp |\r\r\tcardsOfAKind := OrderedCollection new.\r\r\t1 to: (hand size) do: [ :i | \r\t\tcard := hand at: i.\r\t\ttemp := card at: (card size).\r\t\t(temp == suitCard) ifTrue: [cardsOfAKind add: card].\r].\r^cardsOfAKind',			#stamp : 'MagdalenaDhima 1/30/2021 14:45',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T14:46:58.587794-05:00' ],		#prior : OmReference [ '66' ],		#self : OmReference [ '67' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flush straightFlush |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tflush := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flush\'; cr.\r\tTranscript show: flush; cr.\r\t\r\tstraightFlush := self getHighestStreak: flush.\r\tTranscript show: \'straightFlush\'; cr.\r\tTranscript show: straightFlush; cr.\r\t\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 13:56',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tflush := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flush\'; cr.\r\tTranscript show: flush; cr.\r\t\r\tstraightFlush := self getHighestStreak: flush.\r\tTranscript show: \'straightFlush\'; cr.\r\tTranscript show: straightFlush; cr.\r\t\r\tmaxNumOfAKind := data inject: 0 into: [:a :c | (a  > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tsuitOfAKind := data keyAtValue: maxNumOfAKind.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitCards; cr.\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 14:46',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T14:47:28.098794-05:00' ],		#prior : OmReference [ '67' ],		#self : OmReference [ '68' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tflush := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flush\'; cr.\r\tTranscript show: flush; cr.\r\t\r\tstraightFlush := self getHighestStreak: flush.\r\tTranscript show: \'straightFlush\'; cr.\r\tTranscript show: straightFlush; cr.\r\t\r\tmaxNumOfAKind := data inject: 0 into: [:a :c | (a  > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tsuitOfAKind := data keyAtValue: maxNumOfAKind.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitCards; cr.\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 14:46',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tflush := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flush\'; cr.\r\tTranscript show: flush; cr.\r\t\r\tstraightFlush := self getHighestStreak: flush.\r\tTranscript show: \'straightFlush\'; cr.\r\tTranscript show: straightFlush; cr.\r\t\r\tmaxNumOfAKind := data inject: 0 into: [:a :c | (a  > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: suitCards; cr.\r\tsuitOfAKind := data keyAtValue: maxNumOfAKind.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitCards; cr.\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 14:47',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T14:48:15.433794-05:00' ],		#prior : OmReference [ '68' ],		#self : OmReference [ '69' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tflush := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flush\'; cr.\r\tTranscript show: flush; cr.\r\t\r\tstraightFlush := self getHighestStreak: flush.\r\tTranscript show: \'straightFlush\'; cr.\r\tTranscript show: straightFlush; cr.\r\t\r\tmaxNumOfAKind := data inject: 0 into: [:a :c | (a  > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: suitCards; cr.\r\tsuitOfAKind := data keyAtValue: maxNumOfAKind.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitCards; cr.\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 14:47',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tflush := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flush\'; cr.\r\tTranscript show: flush; cr.\r\t\r\tstraightFlush := self getHighestStreak: flush.\r\tTranscript show: \'straightFlush\'; cr.\r\tTranscript show: straightFlush; cr.\r\t\r\tmaxNumOfAKind := data inject: 0 into: [:a :c | (a value  > c value )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: suitCards; cr.\r\tsuitOfAKind := data keyAtValue: maxNumOfAKind.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitCards; cr.\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 14:48',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T14:51:35.535794-05:00' ],		#prior : OmReference [ '69' ],		#self : OmReference [ '70' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tflush := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flush\'; cr.\r\tTranscript show: flush; cr.\r\t\r\tstraightFlush := self getHighestStreak: flush.\r\tTranscript show: \'straightFlush\'; cr.\r\tTranscript show: straightFlush; cr.\r\t\r\tmaxNumOfAKind := data inject: 0 into: [:a :c | (a value  > c value )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: suitCards; cr.\r\tsuitOfAKind := data keyAtValue: maxNumOfAKind.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitCards; cr.\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 14:48',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tflush := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flush\'; cr.\r\tTranscript show: flush; cr.\r\t\r\tstraightFlush := self getHighestStreak: flush.\r\tTranscript show: \'straightFlush\'; cr.\r\tTranscript show: straightFlush; cr.\r\t\r\tmaxNumOfAKind := (data copyFrom: 1 to: 4) inject: 0 into: [:a :c | (a value  > c value )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := data keyAtValue: maxNumOfAKind.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitCards; cr.\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 14:51',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T14:52:12.406794-05:00' ],		#prior : OmReference [ '70' ],		#self : OmReference [ '71' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tflush := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flush\'; cr.\r\tTranscript show: flush; cr.\r\t\r\tstraightFlush := self getHighestStreak: flush.\r\tTranscript show: \'straightFlush\'; cr.\r\tTranscript show: straightFlush; cr.\r\t\r\tmaxNumOfAKind := (data copyFrom: 1 to: 4) inject: 0 into: [:a :c | (a value  > c value )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := data keyAtValue: maxNumOfAKind.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitCards; cr.\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 14:51',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tflush := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flush\'; cr.\r\tTranscript show: flush; cr.\r\t\r\tstraightFlush := self getHighestStreak: flush.\r\tTranscript show: \'straightFlush\'; cr.\r\tTranscript show: straightFlush; cr.\r\t\r\tmaxNumOfAKind := (data keys copyFrom: 1 to: 4) inject: 0 into: [:a :c | (a value  > c value )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := data keyAtValue: maxNumOfAKind.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitCards; cr.\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 14:52',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T14:53:20.861794-05:00' ],		#prior : OmReference [ '71' ],		#self : OmReference [ '72' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tflush := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flush\'; cr.\r\tTranscript show: flush; cr.\r\t\r\tstraightFlush := self getHighestStreak: flush.\r\tTranscript show: \'straightFlush\'; cr.\r\tTranscript show: straightFlush; cr.\r\t\r\tmaxNumOfAKind := (data keys copyFrom: 1 to: 4) inject: 0 into: [:a :c | (a value  > c value )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := data keyAtValue: maxNumOfAKind.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitCards; cr.\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 14:52',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tflush := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flush\'; cr.\r\tTranscript show: flush; cr.\r\t\r\tstraightFlush := self getHighestStreak: flush.\r\tTranscript show: \'straightFlush\'; cr.\r\tTranscript show: straightFlush; cr.\r\t\r\tmaxNumOfAKind := ((data values) copyFrom: 1 to: 4) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := data keyAtValue: maxNumOfAKind.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitCards; cr.\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 14:53',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T14:54:03.981794-05:00' ],		#prior : OmReference [ '72' ],		#self : OmReference [ '73' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tflush := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flush\'; cr.\r\tTranscript show: flush; cr.\r\t\r\tstraightFlush := self getHighestStreak: flush.\r\tTranscript show: \'straightFlush\'; cr.\r\tTranscript show: straightFlush; cr.\r\t\r\tmaxNumOfAKind := ((data values) copyFrom: 1 to: 4) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := data keyAtValue: maxNumOfAKind.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitCards; cr.\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 14:53',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tflush := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flush\'; cr.\r\tTranscript show: flush; cr.\r\t\r\tstraightFlush := self getHighestStreak: flush.\r\tTranscript show: \'straightFlush\'; cr.\r\tTranscript show: straightFlush; cr.\r\t\r\tTranscript show: ((data values) copyFrom: 1 to: 4); cr.\r\tmaxNumOfAKind := ((data values) copyFrom: 1 to: 4) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := data keyAtValue: maxNumOfAKind.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitCards; cr.\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 14:54',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T14:54:49.272794-05:00' ],		#prior : OmReference [ '73' ],		#self : OmReference [ '74' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tflush := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flush\'; cr.\r\tTranscript show: flush; cr.\r\t\r\tstraightFlush := self getHighestStreak: flush.\r\tTranscript show: \'straightFlush\'; cr.\r\tTranscript show: straightFlush; cr.\r\t\r\tTranscript show: ((data values) copyFrom: 1 to: 4); cr.\r\tmaxNumOfAKind := ((data values) copyFrom: 1 to: 4) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := data keyAtValue: maxNumOfAKind.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitCards; cr.\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 14:54',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tflush := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flush\'; cr.\r\tTranscript show: flush; cr.\r\t\r\tstraightFlush := self getHighestStreak: flush.\r\tTranscript show: \'straightFlush\'; cr.\r\tTranscript show: straightFlush; cr.\r\t\r\tTranscript show: (data values); cr.\r\tTranscript show: ((data values) copyFrom: 1 to: 4); cr.\r\tmaxNumOfAKind := ((data values) copyFrom: 1 to: 4) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := data keyAtValue: maxNumOfAKind.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitCards; cr.\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 14:54',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T14:55:41.623794-05:00' ],		#prior : OmReference [ '74' ],		#self : OmReference [ '75' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tflush := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flush\'; cr.\r\tTranscript show: flush; cr.\r\t\r\tstraightFlush := self getHighestStreak: flush.\r\tTranscript show: \'straightFlush\'; cr.\r\tTranscript show: straightFlush; cr.\r\t\r\tTranscript show: (data values); cr.\r\tTranscript show: ((data values) copyFrom: 1 to: 4); cr.\r\tmaxNumOfAKind := ((data values) copyFrom: 1 to: 4) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := data keyAtValue: maxNumOfAKind.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitCards; cr.\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 14:54',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tflush := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flush\'; cr.\r\tTranscript show: flush; cr.\r\t\r\tstraightFlush := self getHighestStreak: flush.\r\tTranscript show: \'straightFlush\'; cr.\r\tTranscript show: straightFlush; cr.\r\t\r\tTranscript show: (data values); cr.\r\tTranscript show: ((data values) copyFrom: 13 to: 17); cr.\r\tmaxNumOfAKind := ((data values) copyFrom: 1 to: 4) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := data keyAtValue: maxNumOfAKind.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitCards; cr.\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 14:55',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T14:56:18.632794-05:00' ],		#prior : OmReference [ '75' ],		#self : OmReference [ '76' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tflush := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flush\'; cr.\r\tTranscript show: flush; cr.\r\t\r\tstraightFlush := self getHighestStreak: flush.\r\tTranscript show: \'straightFlush\'; cr.\r\tTranscript show: straightFlush; cr.\r\t\r\tTranscript show: (data values); cr.\r\tTranscript show: ((data values) copyFrom: 13 to: 17); cr.\r\tmaxNumOfAKind := ((data values) copyFrom: 1 to: 4) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := data keyAtValue: maxNumOfAKind.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitCards; cr.\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 14:55',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tflush := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flush\'; cr.\r\tTranscript show: flush; cr.\r\t\r\tstraightFlush := self getHighestStreak: flush.\r\tTranscript show: \'straightFlush\'; cr.\r\tTranscript show: straightFlush; cr.\r\t\r\tTranscript show: (data values); cr.\r\tTranscript show: ((data values) copyFrom: 14 to: 17); cr.\r\tmaxNumOfAKind := ((data values) copyFrom: 1 to: 4) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := data keyAtValue: maxNumOfAKind.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitCards; cr.\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 14:56',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T14:57:06.086794-05:00' ],		#prior : OmReference [ '76' ],		#self : OmReference [ '77' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tflush := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flush\'; cr.\r\tTranscript show: flush; cr.\r\t\r\tstraightFlush := self getHighestStreak: flush.\r\tTranscript show: \'straightFlush\'; cr.\r\tTranscript show: straightFlush; cr.\r\t\r\tTranscript show: (data values); cr.\r\tTranscript show: ((data values) copyFrom: 14 to: 17); cr.\r\tmaxNumOfAKind := ((data values) copyFrom: 1 to: 4) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := data keyAtValue: maxNumOfAKind.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitCards; cr.\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 14:56',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tflush := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flush\'; cr.\r\tTranscript show: flush; cr.\r\t\r\tstraightFlush := self getHighestStreak: flush.\r\tTranscript show: \'straightFlush\'; cr.\r\tTranscript show: straightFlush; cr.\r\t\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := data keyAtValue: maxNumOfAKind.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitCards; cr.\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 14:57',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T14:57:36.660794-05:00' ],		#prior : OmReference [ '77' ],		#self : OmReference [ '78' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tflush := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flush\'; cr.\r\tTranscript show: flush; cr.\r\t\r\tstraightFlush := self getHighestStreak: flush.\r\tTranscript show: \'straightFlush\'; cr.\r\tTranscript show: straightFlush; cr.\r\t\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := data keyAtValue: maxNumOfAKind.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitCards; cr.\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 14:57',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tflush := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flush\'; cr.\r\tTranscript show: flush; cr.\r\t\r\tstraightFlush := self getHighestStreak: flush.\r\tTranscript show: \'straightFlush\'; cr.\r\tTranscript show: straightFlush; cr.\r\t\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := data keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitCards; cr.\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 14:57',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T14:58:41.052794-05:00' ],		#prior : OmReference [ '78' ],		#self : OmReference [ '79' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'returnSuitCards:',			#protocol : #accessing,			#sourceCode : 'returnSuitCards: suitCard\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| cardsOfAKind card temp |\r\r\tcardsOfAKind := OrderedCollection new.\r\r\t1 to: (hand size) do: [ :i | \r\t\tcard := hand at: i.\r\t\ttemp := card at: (card size).\r\t\t(temp == suitCard) ifTrue: [cardsOfAKind add: card].\r].\r^cardsOfAKind',			#stamp : 'MagdalenaDhima 1/30/2021 14:45',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'returnSuitCards:',			#protocol : #accessing,			#sourceCode : 'returnSuitCards: suit\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| cardsOfAKind card temp |\r\r\tcardsOfAKind := OrderedCollection new.\r\r\t1 to: (hand size) do: [ :i | \r\t\tcard := hand at: i.\r\t\ttemp := card at: (card size).\r\t\t(temp == suit) ifTrue: [cardsOfAKind add: card].\r].\r^cardsOfAKind',			#stamp : 'MagdalenaDhima 1/30/2021 14:58',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T14:59:30.884794-05:00' ],		#prior : OmReference [ '79' ],		#self : OmReference [ '80' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'returnSuitCards:',			#protocol : #accessing,			#sourceCode : 'returnSuitCards: suit\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| cardsOfAKind card temp |\r\r\tcardsOfAKind := OrderedCollection new.\r\r\t1 to: (hand size) do: [ :i | \r\t\tcard := hand at: i.\r\t\ttemp := card at: (card size).\r\t\t(temp == suit) ifTrue: [cardsOfAKind add: card].\r].\r^cardsOfAKind',			#stamp : 'MagdalenaDhima 1/30/2021 14:58',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'returnSuitCards:',			#protocol : #accessing,			#sourceCode : 'returnSuitCards: suit\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| cardsOfAKind card temp |\r\r\tcardsOfAKind := OrderedCollection new.\r\r\t1 to: (hand size) do: [ :i | \r\t\tcard := hand at: i.\r\t\ttemp := card at: (card size).\r\t\t(temp = suit) ifTrue: [cardsOfAKind add: card].\r].\r^cardsOfAKind',			#stamp : 'MagdalenaDhima 1/30/2021 14:59',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T15:00:16.082794-05:00' ],		#prior : OmReference [ '80' ],		#self : OmReference [ '81' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'returnSuitCards:',			#protocol : #accessing,			#sourceCode : 'returnSuitCards: suit\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| cardsOfAKind card temp |\r\r\tcardsOfAKind := OrderedCollection new.\r\r\t1 to: (hand size) do: [ :i | \r\t\tcard := hand at: i.\r\t\ttemp := card at: (card size).\r\t\t(temp = suit) ifTrue: [cardsOfAKind add: card].\r].\r^cardsOfAKind',			#stamp : 'MagdalenaDhima 1/30/2021 14:59',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'returnSuitCards:',			#protocol : #accessing,			#sourceCode : 'returnSuitCards: suit\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| cardsOfAKind card temp |\r\r\tcardsOfAKind := OrderedCollection new.\r\r\t1 to: (hand size) do: [ :i | \r\t\tcard := hand at: i.\r\t\ttemp := card at: (card size).\r\t\tTranscript show: temp class; cr.\r\t\tTranscript show: suit class; cr.\r\t\t(temp = suit) ifTrue: [cardsOfAKind add: card].\r].\r^cardsOfAKind',			#stamp : 'MagdalenaDhima 1/30/2021 15:00',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T15:01:01.847794-05:00' ],		#prior : OmReference [ '81' ],		#self : OmReference [ '82' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'returnSuitCards:',			#protocol : #accessing,			#sourceCode : 'returnSuitCards: suit\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| cardsOfAKind card temp |\r\r\tcardsOfAKind := OrderedCollection new.\r\r\t1 to: (hand size) do: [ :i | \r\t\tcard := hand at: i.\r\t\ttemp := card at: (card size).\r\t\tTranscript show: temp class; cr.\r\t\tTranscript show: suit class; cr.\r\t\t(temp = suit) ifTrue: [cardsOfAKind add: card].\r].\r^cardsOfAKind',			#stamp : 'MagdalenaDhima 1/30/2021 15:00',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'returnSuitCards:',			#protocol : #accessing,			#sourceCode : 'returnSuitCards: suit\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| cardsOfAKind card temp |\r\r\tcardsOfAKind := OrderedCollection new.\r\r\t1 to: (hand size) do: [ :i | \r\t\tcard := hand at: i.\r\t\ttemp := card at: (card size).\r\t\tTranscript show: temp class; cr.\r\t\tTranscript show: suit class; cr.\r\t\t(temp == suit asCharacter) ifTrue: [cardsOfAKind add: card].\r].\r^cardsOfAKind',			#stamp : 'MagdalenaDhima 1/30/2021 15:01',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T15:01:16.090794-05:00' ],		#prior : OmReference [ '82' ],		#self : OmReference [ '83' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'returnSuitCards:',			#protocol : #accessing,			#sourceCode : 'returnSuitCards: suit\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| cardsOfAKind card temp |\r\r\tcardsOfAKind := OrderedCollection new.\r\r\t1 to: (hand size) do: [ :i | \r\t\tcard := hand at: i.\r\t\ttemp := card at: (card size).\r\t\tTranscript show: temp class; cr.\r\t\tTranscript show: suit class; cr.\r\t\t(temp == suit asCharacter) ifTrue: [cardsOfAKind add: card].\r].\r^cardsOfAKind',			#stamp : 'MagdalenaDhima 1/30/2021 15:01',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'returnSuitCards:',			#protocol : #accessing,			#sourceCode : 'returnSuitCards: suit\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| cardsOfAKind card temp |\r\r\tcardsOfAKind := OrderedCollection new.\r\r\t1 to: (hand size) do: [ :i | \r\t\tcard := hand at: i.\r\t\ttemp := card at: (card size).\r\t\tTranscript show: temp class; cr.\r\t\tTranscript show: suit class; cr.\r\t\t(temp == suit asString) ifTrue: [cardsOfAKind add: card].\r].\r^cardsOfAKind',			#stamp : 'MagdalenaDhima 1/30/2021 15:01',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T15:01:32.037794-05:00' ],		#prior : OmReference [ '83' ],		#self : OmReference [ '84' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'returnSuitCards:',			#protocol : #accessing,			#sourceCode : 'returnSuitCards: suit\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| cardsOfAKind card temp |\r\r\tcardsOfAKind := OrderedCollection new.\r\r\t1 to: (hand size) do: [ :i | \r\t\tcard := hand at: i.\r\t\ttemp := card at: (card size).\r\t\tTranscript show: temp class; cr.\r\t\tTranscript show: suit class; cr.\r\t\t(temp == suit asString) ifTrue: [cardsOfAKind add: card].\r].\r^cardsOfAKind',			#stamp : 'MagdalenaDhima 1/30/2021 15:01',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'returnSuitCards:',			#protocol : #accessing,			#sourceCode : 'returnSuitCards: suit\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| cardsOfAKind card temp |\r\r\tcardsOfAKind := OrderedCollection new.\r\r\t1 to: (hand size) do: [ :i | \r\t\tcard := hand at: i.\r\t\ttemp := card at: (card size).\r\t\tTranscript show: temp class; cr.\r\t\tTranscript show: suit class; cr.\r\t\t(temp asString == suit asString) ifTrue: [cardsOfAKind add: card].\r].\r^cardsOfAKind',			#stamp : 'MagdalenaDhima 1/30/2021 15:01',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T15:02:43.546794-05:00' ],		#prior : OmReference [ '84' ],		#self : OmReference [ '85' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'returnSuitCards:',			#protocol : #accessing,			#sourceCode : 'returnSuitCards: suit\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| cardsOfAKind card temp |\r\r\tcardsOfAKind := OrderedCollection new.\r\r\t1 to: (hand size) do: [ :i | \r\t\tcard := hand at: i.\r\t\ttemp := card at: (card size).\r\t\tTranscript show: temp class; cr.\r\t\tTranscript show: suit class; cr.\r\t\t(temp asString == suit asString) ifTrue: [cardsOfAKind add: card].\r].\r^cardsOfAKind',			#stamp : 'MagdalenaDhima 1/30/2021 15:01',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'returnSuitCards:',			#protocol : #accessing,			#sourceCode : 'returnSuitCards: suit\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| cardsOfAKind card temp |\r\r\tcardsOfAKind := OrderedCollection new.\r\r\t1 to: (hand size) do: [ :i | \r\t\tcard := hand at: i.\r\t\ttemp := card at: (card size).\r\t\tTranscript show: temp ; cr.\r\t\tTranscript show: suit ; cr.\r\t\t(temp asString == suit asString) ifTrue: [cardsOfAKind add: card].\r].\r^cardsOfAKind',			#stamp : 'MagdalenaDhima 1/30/2021 15:02',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T15:02:57.693794-05:00' ],		#prior : OmReference [ '85' ],		#self : OmReference [ '86' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'returnSuitCards:',			#protocol : #accessing,			#sourceCode : 'returnSuitCards: suit\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| cardsOfAKind card temp |\r\r\tcardsOfAKind := OrderedCollection new.\r\r\t1 to: (hand size) do: [ :i | \r\t\tcard := hand at: i.\r\t\ttemp := card at: (card size).\r\t\tTranscript show: temp ; cr.\r\t\tTranscript show: suit ; cr.\r\t\t(temp asString == suit asString) ifTrue: [cardsOfAKind add: card].\r].\r^cardsOfAKind',			#stamp : 'MagdalenaDhima 1/30/2021 15:02',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'returnSuitCards:',			#protocol : #accessing,			#sourceCode : 'returnSuitCards: suit\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| cardsOfAKind card temp |\r\r\tcardsOfAKind := OrderedCollection new.\r\r\t1 to: (hand size) do: [ :i | \r\t\tcard := hand at: i.\r\t\ttemp := card at: (card size).\r\t\tTranscript show: temp ; cr.\r\t\tTranscript show: suit ; cr.\r\t\t(temp asString == suit) ifTrue: [cardsOfAKind add: card].\r].\r^cardsOfAKind',			#stamp : 'MagdalenaDhima 1/30/2021 15:02',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T15:03:12.248794-05:00' ],		#prior : OmReference [ '86' ],		#self : OmReference [ '87' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'returnSuitCards:',			#protocol : #accessing,			#sourceCode : 'returnSuitCards: suit\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| cardsOfAKind card temp |\r\r\tcardsOfAKind := OrderedCollection new.\r\r\t1 to: (hand size) do: [ :i | \r\t\tcard := hand at: i.\r\t\ttemp := card at: (card size).\r\t\tTranscript show: temp ; cr.\r\t\tTranscript show: suit ; cr.\r\t\t(temp asString == suit) ifTrue: [cardsOfAKind add: card].\r].\r^cardsOfAKind',			#stamp : 'MagdalenaDhima 1/30/2021 15:02',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'returnSuitCards:',			#protocol : #accessing,			#sourceCode : 'returnSuitCards: suit\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| cardsOfAKind card temp |\r\r\tcardsOfAKind := OrderedCollection new.\r\r\t1 to: (hand size) do: [ :i | \r\t\tcard := hand at: i.\r\t\ttemp := card at: (card size).\r\t\tTranscript show: temp ; cr.\r\t\tTranscript show: suit ; cr.\r\t\t(temp asSymbol == suit asSymbol) ifTrue: [cardsOfAKind add: card].\r].\r^cardsOfAKind',			#stamp : 'MagdalenaDhima 1/30/2021 15:03',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T15:03:28.503794-05:00' ],		#prior : OmReference [ '87' ],		#self : OmReference [ '88' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'returnSuitCards:',			#protocol : #accessing,			#sourceCode : 'returnSuitCards: suit\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| cardsOfAKind card temp |\r\r\tcardsOfAKind := OrderedCollection new.\r\r\t1 to: (hand size) do: [ :i | \r\t\tcard := hand at: i.\r\t\ttemp := card at: (card size).\r\t\tTranscript show: temp ; cr.\r\t\tTranscript show: suit ; cr.\r\t\t(temp asSymbol == suit asSymbol) ifTrue: [cardsOfAKind add: card].\r].\r^cardsOfAKind',			#stamp : 'MagdalenaDhima 1/30/2021 15:03',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'returnSuitCards:',			#protocol : #accessing,			#sourceCode : 'returnSuitCards: suit\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| cardsOfAKind card temp |\r\r\tcardsOfAKind := OrderedCollection new.\r\r\t1 to: (hand size) do: [ :i | \r\t\tcard := hand at: i.\r\t\ttemp := card at: (card size).\r\t\t(temp asSymbol == suit asSymbol) ifTrue: [cardsOfAKind add: card].\r].\r^cardsOfAKind',			#stamp : 'MagdalenaDhima 1/30/2021 15:03',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T15:15:17.979794-05:00' ],		#prior : OmReference [ '88' ],		#self : OmReference [ '89' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tflush := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flush\'; cr.\r\tTranscript show: flush; cr.\r\t\r\tstraightFlush := self getHighestStreak: flush.\r\tTranscript show: \'straightFlush\'; cr.\r\tTranscript show: straightFlush; cr.\r\t\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := data keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitCards; cr.\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 14:57',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tflush := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flush\'; cr.\r\tTranscript show: flush; cr.\r\t\r\tstraightFlush := self getHighestStreak: flush.\r\tTranscript show: \'straightFlush\'; cr.\r\tTranscript show: straightFlush; cr.\r\t\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := data keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitCards; cr.\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 15:15',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T15:16:53.818794-05:00' ],		#prior : OmReference [ '89' ],		#self : OmReference [ '90' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tflush := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flush\'; cr.\r\tTranscript show: flush; cr.\r\t\r\tstraightFlush := self getHighestStreak: flush.\r\tTranscript show: \'straightFlush\'; cr.\r\tTranscript show: straightFlush; cr.\r\t\r\t(straightFlush size == 5) ifTrue: [^straightFlush].\r\t\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := data keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitCards; cr.\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 15:15',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tflush := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flush\'; cr.\r\tTranscript show: flush; cr.\r\t\r\tstraightFlush := self getHighestStreak: flush.\r\tTranscript show: \'straightFlush\'; cr.\r\tTranscript show: straightFlush; cr.\r\t\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := data keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitCards; cr.\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 15:16',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T15:38:04.609794-05:00' ],		#prior : OmReference [ '90' ],		#self : OmReference [ '91' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tflush := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flush\'; cr.\r\tTranscript show: flush; cr.\r\t\r\tstraightFlush := self getHighestStreak: flush.\r\tTranscript show: \'straightFlush\'; cr.\r\tTranscript show: straightFlush; cr.\r\t\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := data keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitCards; cr.\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 15:16',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tflush := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flush\'; cr.\r\tTranscript show: flush; cr.\r\t\r\tstraightFlush := self getHighestStreak: flush.\r\tTranscript show: \'straightFlush\'; cr.\r\tTranscript show: straightFlush; cr.\r\t\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := data keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\t(suitCards size == 4) ifTrue: [Transcript show: 3; cr. ^suitCards].\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 15:38',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T15:40:55.413794-05:00' ],		#prior : OmReference [ '91' ],		#self : OmReference [ '92' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tflush := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flush\'; cr.\r\tTranscript show: flush; cr.\r\t\r\tstraightFlush := self getHighestStreak: flush.\r\tTranscript show: \'straightFlush\'; cr.\r\tTranscript show: straightFlush; cr.\r\t\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := data keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\t(suitCards size == 4) ifTrue: [Transcript show: 3; cr. ^suitCards].\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 15:38',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tflush := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flush\'; cr.\r\tTranscript show: flush; cr.\r\t\r\tstraightFlush := self getHighestStreak: flush.\r\tTranscript show: \'straightFlush\'; cr.\r\tTranscript show: straightFlush; cr.\r\t\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t(suitCards size == 4) ifTrue: [Transcript show: 3; cr. ^suitCards].\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 15:40',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T15:43:44.430794-05:00' ],		#prior : OmReference [ '92' ],		#self : OmReference [ '93' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getStreak:',			#protocol : #accessing,			#sourceCode : 'getStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak |\rsuitStreak := OrderedCollection new.\r2 to: streaks size do: [ :i | \r\tpreviousCard := streaks at: (i-1).\r\tprevious := previousCard at: previousCard size.\r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\t(previous == current)\r\t\tifTrue: [(suitStreak isEmpty) ifTrue:[suitStreak add: previousCard]. suitStreak add: card]].\r\t',			#stamp : 'MagdalenaDhima 1/30/2021 15:43',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T15:45:31.577794-05:00' ],		#prior : OmReference [ '93' ],		#self : OmReference [ '94' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getStreak:',			#protocol : #accessing,			#sourceCode : 'getStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak |\rsuitStreak := OrderedCollection new.\r2 to: streaks size do: [ :i | \r\tpreviousCard := streaks at: (i-1).\r\tprevious := previousCard at: previousCard size.\r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\t(previous == current)\r\t\tifTrue: [(suitStreak isEmpty) ifTrue:[suitStreak add: previousCard]. suitStreak add: card]].\r\t',			#stamp : 'MagdalenaDhima 1/30/2021 15:43',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getStreak:',			#protocol : #accessing,			#sourceCode : 'getStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak |\rsuitStreak := OrderedCollection new.\r2 to: streaks size do: [ :i | \r\tpreviousCard := streaks at: (i-1).\r\tprevious := previousCard at: previousCard size.\r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\t(previous == current)\r\t\tifTrue: [(suitStreak isEmpty) ifTrue:[suitStreak add: previousCard]. suitStreak add: card]].\r\t^suitStreak\r\t',			#stamp : 'MagdalenaDhima 1/30/2021 15:45',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T15:49:00.506794-05:00' ],		#prior : OmReference [ '94' ],		#self : OmReference [ '95' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak |\rsuitStreak := OrderedCollection new.\r2 to: streaks size do: [ :i | \r\tpreviousCard := streaks at: (i-1).\r\tprevious := previousCard at: previousCard size.\r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\t(previous == current)\r\t\tifTrue: [(suitStreak isEmpty) ifTrue:[suitStreak add: previousCard]. suitStreak add: card]].\r\t\rhighestSuitStreak := OrderedCollection new.\r(suitStreak size >= 5) ifTrue: [\r\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]].\r\r^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 11:09',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak |\rsuitStreak := OrderedCollection new.\r2 to: streaks size do: [ :i | \r\tpreviousCard := streaks at: (i-1).\r\tprevious := previousCard at: previousCard size.\r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\t(previous == current)\r\t\tifTrue: [(suitStreak isEmpty) ifTrue:[suitStreak add: previousCard]. suitStreak add: card]].\r\r\rhighestSuitStreak := OrderedCollection new.\r(suitStreak size >= 5) \r\tifTrue: [\r\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 15:49',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T15:55:21.437794-05:00' ],		#prior : OmReference [ '95' ],		#self : OmReference [ '96' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#definitionSource : 'Object subclass: #Poker\r\tinstanceVariableNames: \'hand\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'CPS506\'',				#superclassName : 'Object',				#traitCompositionSource : '{}'			},			#name : #Poker,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Poker,						#isMetaSide : false					},					#name : #hand,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#definitionSource : 'Poker class\r\tinstanceVariableNames: \'\'',					#traitCompositionSource : '{}'				},				#name : #'Poker class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Poker,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #CPS506,			#package : #CPS506,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#definitionSource : 'Object subclass: #Poker\r\tinstanceVariableNames: \'handdata\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'CPS506\'',				#superclassName : 'Object',				#traitCompositionSource : '{}'			},			#name : #Poker,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Poker,						#isMetaSide : false					},					#name : #handdata,					#parent : @23				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#definitionSource : 'Poker class\r\tinstanceVariableNames: \'\'',					#traitCompositionSource : '{}'				},				#name : #'Poker class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @23			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Poker,					#isMetaSide : false				},				#parent : @23,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #CPS506,			#package : #CPS506,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T15:55:36.907794-05:00' ],		#prior : OmReference [ '96' ],		#self : OmReference [ '97' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#definitionSource : 'Object subclass: #Poker\r\tinstanceVariableNames: \'handdata\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'CPS506\'',				#superclassName : 'Object',				#traitCompositionSource : '{}'			},			#name : #Poker,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Poker,						#isMetaSide : false					},					#name : #handdata,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#definitionSource : 'Poker class\r\tinstanceVariableNames: \'\'',					#traitCompositionSource : '{}'				},				#name : #'Poker class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Poker,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #CPS506,			#package : #CPS506,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#definitionSource : 'Object subclass: #Poker\r\tinstanceVariableNames: \'hand data\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'CPS506\'',				#superclassName : 'Object',				#traitCompositionSource : '{}'			},			#name : #Poker,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Poker,						#isMetaSide : false					},					#name : #hand,					#parent : @23				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Poker,						#isMetaSide : false					},					#name : #data,					#parent : @23				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#definitionSource : 'Poker class\r\tinstanceVariableNames: \'\'',					#traitCompositionSource : '{}'				},				#name : #'Poker class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @23			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Poker,					#isMetaSide : false				},				#parent : @23,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #CPS506,			#package : #CPS506,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T15:57:18.033794-05:00' ],		#prior : OmReference [ '97' ],		#self : OmReference [ '98' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#definitionSource : 'Object subclass: #Poker\r\tinstanceVariableNames: \'hand data\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'CPS506\'',				#superclassName : 'Object',				#traitCompositionSource : '{}'			},			#name : #Poker,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Poker,						#isMetaSide : false					},					#name : #hand,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Poker,						#isMetaSide : false					},					#name : #data,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#definitionSource : 'Poker class\r\tinstanceVariableNames: \'\'',					#traitCompositionSource : '{}'				},				#name : #'Poker class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Poker,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #CPS506,			#package : #CPS506,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#definitionSource : 'Object subclass: #Poker\r\tinstanceVariableNames: \'data\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'CPS506\'',				#superclassName : 'Object',				#traitCompositionSource : '{}'			},			#name : #Poker,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Poker,						#isMetaSide : false					},					#name : #data,					#parent : @25				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#definitionSource : 'Poker class\r\tinstanceVariableNames: \'\'',					#traitCompositionSource : '{}'				},				#name : #'Poker class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @25			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Poker,					#isMetaSide : false				},				#parent : @25,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #CPS506,			#package : #CPS506,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T15:58:10.597794-05:00' ],		#prior : OmReference [ '98' ],		#self : OmReference [ '99' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#definitionSource : 'Object subclass: #Poker\r\tinstanceVariableNames: \'data\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'CPS506\'',				#superclassName : 'Object',				#traitCompositionSource : '{}'			},			#name : #Poker,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Poker,						#isMetaSide : false					},					#name : #data,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#definitionSource : 'Poker class\r\tinstanceVariableNames: \'\'',					#traitCompositionSource : '{}'				},				#name : #'Poker class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Poker,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #CPS506,			#package : #CPS506,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#definitionSource : 'Object subclass: #Poker\r\tinstanceVariableNames: \'hand\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'CPS506\'',				#superclassName : 'Object',				#traitCompositionSource : '{}'			},			#name : #Poker,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Poker,						#isMetaSide : false					},					#name : #hand,					#parent : @23				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#definitionSource : 'Poker class\r\tinstanceVariableNames: \'\'',					#traitCompositionSource : '{}'				},				#name : #'Poker class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @23			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Poker,					#isMetaSide : false				},				#parent : @23,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #CPS506,			#package : #CPS506,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T15:58:35.913794-05:00' ],		#prior : OmReference [ '99' ],		#self : OmReference [ '100' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #convert,			#protocol : #actions,			#sourceCode : 'convert\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp values suits output val |\r\thand := Array new: 9.\r\tvalues := #(\'1\' \'2\' \'3\' \'4\' \'5\' \'6\' \'7\' \'8\' \'9\' \'10\' \'11\' \'12\' \'13\').\r\tsuits := #(\'C\' \'D\' \'H\' \'S\').\r\t1 to: 9 do: [ :i | \r\t\tval := hand at: i.\r\t\ttemp := val % 13.\r\t\toutput := (temp == 0) \r\t\t\tifFalse: [values at: temp]\r\t\t\tifTrue: [values at: 13]\r\t\t. \r\t\ttemp := val-1 // 13 + 1 floor. \r\t\toutput := output , (suits at: temp). \r\t\thand at: i put: output.\r\t].',			#stamp : 'MagdalenaDhima 1/30/2021 12:54',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #convert,			#protocol : #'as yet unclassified',			#sourceCode : 'convert\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp values suits output val |\r\thand := Array new: 9.\r\tvalues := #(\'1\' \'2\' \'3\' \'4\' \'5\' \'6\' \'7\' \'8\' \'9\' \'10\' \'11\' \'12\' \'13\').\r\tsuits := #(\'C\' \'D\' \'H\' \'S\').\r\t1 to: 9 do: [ :i | \r\t\tval := hand at: i.\r\t\ttemp := val % 13.\r\t\toutput := (temp == 0) \r\t\t\tifFalse: [values at: temp]\r\t\t\tifTrue: [values at: 13]\r\t\t. \r\t\ttemp := val-1 // 13 + 1 floor. \r\t\toutput := output , (suits at: temp). \r\t\thand at: i put: output.\r\t].',			#stamp : 'MagdalenaDhima 1/30/2021 12:54',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T15:58:35.991794-05:00' ],		#prior : OmReference [ '100' ],		#self : OmReference [ '101' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #convert,			#protocol : #actions,			#sourceCode : 'convert\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp values suits output val |\r\thand := Array new: 9.\r\tvalues := #(\'1\' \'2\' \'3\' \'4\' \'5\' \'6\' \'7\' \'8\' \'9\' \'10\' \'11\' \'12\' \'13\').\r\tsuits := #(\'C\' \'D\' \'H\' \'S\').\r\t1 to: 9 do: [ :i | \r\t\tval := hand at: i.\r\t\ttemp := val % 13.\r\t\toutput := (temp == 0) \r\t\t\tifFalse: [values at: temp]\r\t\t\tifTrue: [values at: 13]\r\t\t. \r\t\ttemp := val-1 // 13 + 1 floor. \r\t\toutput := output , (suits at: temp). \r\t\thand at: i put: output.\r\t].',			#stamp : 'MagdalenaDhima 1/30/2021 12:54',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T16:21:26.277794-05:00' ],		#prior : OmReference [ '101' ],		#self : OmReference [ '102' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak |\rsuitStreak := OrderedCollection new.\r2 to: streaks size do: [ :i | \r\tpreviousCard := streaks at: (i-1).\r\tprevious := previousCard at: previousCard size.\r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\t(previous == current)\r\t\tifTrue: [(suitStreak isEmpty) ifTrue:[suitStreak add: previousCard]. suitStreak add: card]].\r\r\rhighestSuitStreak := OrderedCollection new.\r(suitStreak size >= 5) \r\tifTrue: [\r\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 15:49',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak dataInHand newList max |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rnewList := OrderedCollection.\rdataInHand at: \'C\' put: nil. dataInHand at: \'D\' put: nil. dataInHand at: \'H\' put: nil. dataInHand at: \'S\' put: nil.\r2 to: streaks size do: [ :i | \r\tpreviousCard := streaks at: (i-1).\r\tprevious := previousCard at: previousCard size.\r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\t(previous == current)\r\t\tifTrue: [(suitStreak isEmpty) ifTrue:[suitStreak add: previousCard]. suitStreak add: card]\r\t\tifFalse: [(suitStreak size ~= 0) ifTrue: [dataInHand at: previous put: suitStreak. suitStreak := \t\t\tOrderedCollection new] ] ].\r\t(suitStreak size ~= 0) ifTrue: [dataInHand at: previous put: suitStreak].\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 16:21',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T16:21:47.597794-05:00' ],		#prior : OmReference [ '102' ],		#self : OmReference [ '103' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak dataInHand newList max |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rnewList := OrderedCollection.\rdataInHand at: \'C\' put: nil. dataInHand at: \'D\' put: nil. dataInHand at: \'H\' put: nil. dataInHand at: \'S\' put: nil.\r2 to: streaks size do: [ :i | \r\tpreviousCard := streaks at: (i-1).\r\tprevious := previousCard at: previousCard size.\r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\t(previous == current)\r\t\tifTrue: [(suitStreak isEmpty) ifTrue:[suitStreak add: previousCard]. suitStreak add: card]\r\t\tifFalse: [(suitStreak size ~= 0) ifTrue: [dataInHand at: previous put: suitStreak. suitStreak := \t\t\tOrderedCollection new] ] ].\r\t(suitStreak size ~= 0) ifTrue: [dataInHand at: previous put: suitStreak].\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 16:21',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak dataInHand max |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: nil. dataInHand at: \'D\' put: nil. dataInHand at: \'H\' put: nil. dataInHand at: \'S\' put: nil.\r2 to: streaks size do: [ :i | \r\tpreviousCard := streaks at: (i-1).\r\tprevious := previousCard at: previousCard size.\r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\t(previous == current)\r\t\tifTrue: [(suitStreak isEmpty) ifTrue:[suitStreak add: previousCard]. suitStreak add: card]\r\t\tifFalse: [(suitStreak size ~= 0) ifTrue: [dataInHand at: previous put: suitStreak. suitStreak := \t\t\tOrderedCollection new] ] ].\r\t(suitStreak size ~= 0) ifTrue: [dataInHand at: previous put: suitStreak].\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 16:21',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T16:24:07.055794-05:00' ],		#prior : OmReference [ '103' ],		#self : OmReference [ '104' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tflush := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flush\'; cr.\r\tTranscript show: flush; cr.\r\t\r\tstraightFlush := self getHighestStreak: flush.\r\tTranscript show: \'straightFlush\'; cr.\r\tTranscript show: straightFlush; cr.\r\t\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t(suitCards size == 4) ifTrue: [Transcript show: 3; cr. ^suitCards].\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 15:40',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tflush := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flush\'; cr.\r\tTranscript show: flush; cr.\r\t\r\tstraightFlush := self getHighestStreak: flush.\r\tTranscript show: \'straightFlush\'; cr.\r\tTranscript show: straightFlush; cr.\r\t\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t(suitCards size == 4) ifTrue: [Transcript show: 3; cr. ^suitCards].\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 16:24',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T16:25:32.625794-05:00' ],		#prior : OmReference [ '104' ],		#self : OmReference [ '105' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak dataInHand max |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: nil. dataInHand at: \'D\' put: nil. dataInHand at: \'H\' put: nil. dataInHand at: \'S\' put: nil.\r2 to: streaks size do: [ :i | \r\tpreviousCard := streaks at: (i-1).\r\tprevious := previousCard at: previousCard size.\r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\t(previous == current)\r\t\tifTrue: [(suitStreak isEmpty) ifTrue:[suitStreak add: previousCard]. suitStreak add: card]\r\t\tifFalse: [(suitStreak size ~= 0) ifTrue: [dataInHand at: previous put: suitStreak. suitStreak := \t\t\tOrderedCollection new] ] ].\r\t(suitStreak size ~= 0) ifTrue: [dataInHand at: previous put: suitStreak].\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 16:21',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: newList. dataInHand at: \'D\' put: newList. dataInHand at: \'H\' put: newList. dataInHand at: \'S\' put: newList.\r2 to: streaks size do: [ :i | \r\tpreviousCard := streaks at: (i-1).\r\tprevious := previousCard at: previousCard size.\r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\t(previous == current)\r\t\tifTrue: [(suitStreak isEmpty) ifTrue:[suitStreak add: previousCard]. suitStreak add: card]\r\t\tifFalse: [(suitStreak size ~= 0) ifTrue: [dataInHand at: previous put: suitStreak. suitStreak := \t\t\tOrderedCollection new] ] ].\r\t(suitStreak size ~= 0) ifTrue: [dataInHand at: previous put: suitStreak].\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 16:25',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T16:26:16.137794-05:00' ],		#prior : OmReference [ '105' ],		#self : OmReference [ '106' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tflush := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flush\'; cr.\r\tTranscript show: flush; cr.\r\t\r\tstraightFlush := self getHighestStreak: flush.\r\tTranscript show: \'straightFlush\'; cr.\r\tTranscript show: straightFlush; cr.\r\t\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t(suitCards size == 4) ifTrue: [Transcript show: 3; cr. ^suitCards].\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 16:24',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tflush := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flush\'; cr.\r\tTranscript show: flush; cr.\r\t\r\tstraightFlush := self getHighestStreak: flush.\r\tTranscript show: \'straightFlush\'; cr.\r\tTranscript show: straightFlush; cr.\r\t\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t(suitCards size == 4) ifTrue: [Transcript show: 3; cr. ^suitCards].\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 16:26',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T16:26:38.899794-05:00' ],		#prior : OmReference [ '106' ],		#self : OmReference [ '107' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tflush := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flush\'; cr.\r\tTranscript show: flush; cr.\r\t\r\tstraightFlush := self getHighestStreak: flush.\r\tTranscript show: \'straightFlush\'; cr.\r\tTranscript show: straightFlush; cr.\r\t\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t(suitCards size == 4) ifTrue: [Transcript show: 3; cr. ^suitCards].\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 16:26',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tflush := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flush\'; cr.\r\tTranscript show: flush; cr.\r\t\r\tstraightFlush := self getHighestStreak: flush.\r\tTranscript show: \'straightFlush\'; cr.\r\tTranscript show: straightFlush; cr.\r\t\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\t(suitCards size == 4) ifTrue: [Transcript show: 3; cr. ^suitCards].\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 16:26',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T16:32:30.788794-05:00' ],		#prior : OmReference [ '107' ],		#self : OmReference [ '108' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flush straightFlush maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tflush := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flush\'; cr.\r\tTranscript show: flush; cr.\r\t\r\tstraightFlush := self getHighestStreak: flush.\r\tTranscript show: \'straightFlush\'; cr.\r\tTranscript show: straightFlush; cr.\r\t\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\t(suitCards size == 4) ifTrue: [Transcript show: 3; cr. ^suitCards].\r\t^sorted\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 16:26',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flushOrSuitStreak straightFlush maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tflushOrSuitStreak := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak; cr.\r\t\r\t(flushOrSuitStreak size > 4) ifTrue: [  \r\t\tstraightFlush := self getHighestStreak: flushOrSuitStreak.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush; cr.].\r\t\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^suitCards].\r\t^sorted\r\t\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 16:32',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T16:32:42.253794-05:00' ],		#prior : OmReference [ '108' ],		#self : OmReference [ '109' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flushOrSuitStreak straightFlush maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tflushOrSuitStreak := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak; cr.\r\t\r\t(flushOrSuitStreak size > 4) ifTrue: [  \r\t\tstraightFlush := self getHighestStreak: flushOrSuitStreak.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush; cr.].\r\t\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^suitCards].\r\t^sorted\r\t\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 16:32',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flushOrSuitStreak straightFlush maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tflushOrSuitStreak := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak; cr.\r\t\r\t(flushOrSuitStreak size > 4) ifTrue: [  \r\t\tstraightFlush := self getHighestStreak: flushOrSuitStreak.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush; cr.].\r\t\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t^sorted\r\t\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 16:32',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T16:42:12.742794-05:00' ],		#prior : OmReference [ '109' ],		#self : OmReference [ '110' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flushOrSuitStreak straightFlush maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tflushOrSuitStreak := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak; cr.\r\t\r\t(flushOrSuitStreak size > 4) ifTrue: [  \r\t\tstraightFlush := self getHighestStreak: flushOrSuitStreak.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush; cr.].\r\t\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t^sorted\r\t\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 16:32',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flushOrSuitStreak straightFlush maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tflushOrSuitStreak := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak; cr.\r\t\r\tstraightFlush := OrderedCollection new.\r\t(flushOrSuitStreak size > 4) ifTrue: [  \r\t\tstraightFlush := self getHighestStreak: flushOrSuitStreak.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush; cr.].\r\t\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t^sorted\r\t\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 16:42',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T17:03:15.937794-05:00' ],		#prior : OmReference [ '110' ],		#self : OmReference [ '111' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #'as yet unclassified',			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand max highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\t(previous == current)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. \t\tvalueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. valueStreak := aValue ] ].\r\r\thighestValueStreak := OrderedCollection new.\r\t(valueStreak size >= 5) \r\tifTrue: [\r\t\t(valueStreak size -4) to: (valueStreak size) do: [:i | highestValueStreak add: (valueStreak at: \ti)]]\r\tifFalse: [highestValueStreak := valueStreak].\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/30/2021 17:03',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T17:03:45.676794-05:00' ],		#prior : OmReference [ '111' ],		#self : OmReference [ '112' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #'as yet unclassified',			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand max highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\t(previous == current)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. \t\tvalueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. valueStreak := aValue ] ].\r\r\thighestValueStreak := OrderedCollection new.\r\t(valueStreak size >= 5) \r\tifTrue: [\r\t\t(valueStreak size -4) to: (valueStreak size) do: [:i | highestValueStreak add: (valueStreak at: \ti)]]\r\tifFalse: [highestValueStreak := valueStreak].\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/30/2021 17:03',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand max highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\t(previous == current)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. \t\tvalueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. valueStreak := aValue ] ].\r\r\thighestValueStreak := OrderedCollection new.\r\t(valueStreak size >= 5) \r\tifTrue: [\r\t\t(valueStreak size -4) to: (valueStreak size) do: [:i | highestValueStreak add: (valueStreak at: \ti)]]\r\tifFalse: [highestValueStreak := valueStreak].\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/30/2021 17:03',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T17:04:42.327794-05:00' ],		#prior : OmReference [ '112' ],		#self : OmReference [ '113' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flushOrSuitStreak straightFlush maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tflushOrSuitStreak := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak; cr.\r\t\r\tstraightFlush := OrderedCollection new.\r\t(flushOrSuitStreak size > 4) ifTrue: [  \r\t\tstraightFlush := self getHighestStreak: flushOrSuitStreak.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush; cr.].\r\t\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t^sorted\r\t\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 16:42',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flushOrSuitStreak straightFlush straightOrValueStreak maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tstraightOrValueStreak := self getHighestValueStreak: sorted.\r\tTranscript show: \'straightOrValueStreak\'; cr.\r\tTranscript show: straightOrValueStreak; cr.\r\t\r\tflushOrSuitStreak := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak; cr.\r\t\r\tstraightFlush := OrderedCollection new.\r\t(flushOrSuitStreak size > 4) ifTrue: [  \r\t\tstraightFlush := self getHighestStreak: flushOrSuitStreak.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush; cr.].\r\t\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t^sorted\r\t\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 17:04',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T17:09:50.152794-05:00' ],		#prior : OmReference [ '113' ],		#self : OmReference [ '114' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand max highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\t(previous == current)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. \t\tvalueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. valueStreak := aValue ] ].\r\r\thighestValueStreak := OrderedCollection new.\r\t(valueStreak size >= 5) \r\tifTrue: [\r\t\t(valueStreak size -4) to: (valueStreak size) do: [:i | highestValueStreak add: (valueStreak at: \ti)]]\r\tifFalse: [highestValueStreak := valueStreak].\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/30/2021 17:03',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand max highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\tTranscript show: card; cr.\r\t\tTranscript show: previous; cr.\r\t\t(previous == current)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. \t\tvalueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. valueStreak := aValue ] ].\r\r\thighestValueStreak := OrderedCollection new.\r\t(valueStreak size >= 5) \r\tifTrue: [\r\t\t(valueStreak size -4) to: (valueStreak size) do: [:i | highestValueStreak add: (valueStreak at: \ti)]]\r\tifFalse: [highestValueStreak := valueStreak].\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/30/2021 17:09',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T17:10:41.322794-05:00' ],		#prior : OmReference [ '114' ],		#self : OmReference [ '115' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand max highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\tTranscript show: card; cr.\r\t\tTranscript show: previous; cr.\r\t\t(previous == current)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. \t\tvalueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. valueStreak := aValue ] ].\r\r\thighestValueStreak := OrderedCollection new.\r\t(valueStreak size >= 5) \r\tifTrue: [\r\t\t(valueStreak size -4) to: (valueStreak size) do: [:i | highestValueStreak add: (valueStreak at: \ti)]]\r\tifFalse: [highestValueStreak := valueStreak].\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/30/2021 17:09',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand max highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\tTranscript show: card; cr.\r\t\tTranscript show: \'d\'; cr.\r\t\tTranscript show: previous; cr.\r\t\t(previous == current)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. \t\tvalueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. valueStreak := aValue ] ].\r\r\thighestValueStreak := OrderedCollection new.\r\t(valueStreak size >= 5) \r\tifTrue: [\r\t\t(valueStreak size -4) to: (valueStreak size) do: [:i | highestValueStreak add: (valueStreak at: \ti)]]\r\tifFalse: [highestValueStreak := valueStreak].\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/30/2021 17:10',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T17:11:33.014794-05:00' ],		#prior : OmReference [ '115' ],		#self : OmReference [ '116' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand max highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\tTranscript show: card; cr.\r\t\tTranscript show: \'d\'; cr.\r\t\tTranscript show: previous; cr.\r\t\t(previous == current)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. \t\tvalueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. valueStreak := aValue ] ].\r\r\thighestValueStreak := OrderedCollection new.\r\t(valueStreak size >= 5) \r\tifTrue: [\r\t\t(valueStreak size -4) to: (valueStreak size) do: [:i | highestValueStreak add: (valueStreak at: \ti)]]\r\tifFalse: [highestValueStreak := valueStreak].\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/30/2021 17:10',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand max highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\tTranscript show: card; cr.\r\t\t(previous == current)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. \t\tvalueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. valueStreak := aValue ] ].\r\r\thighestValueStreak := OrderedCollection new.\r\t(valueStreak size >= 5) \r\tifTrue: [\r\t\t(valueStreak size -4) to: (valueStreak size) do: [:i | highestValueStreak add: (valueStreak at: \ti)]]\r\tifFalse: [highestValueStreak := valueStreak].\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/30/2021 17:11',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T17:11:51.331794-05:00' ],		#prior : OmReference [ '116' ],		#self : OmReference [ '117' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand max highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\tTranscript show: card; cr.\r\t\t(previous == current)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. \t\tvalueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. valueStreak := aValue ] ].\r\r\thighestValueStreak := OrderedCollection new.\r\t(valueStreak size >= 5) \r\tifTrue: [\r\t\t(valueStreak size -4) to: (valueStreak size) do: [:i | highestValueStreak add: (valueStreak at: \ti)]]\r\tifFalse: [highestValueStreak := valueStreak].\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/30/2021 17:11',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand max highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\tTranscript show: current; cr.\r\t\t(previous == current)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. \t\tvalueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. valueStreak := aValue ] ].\r\r\thighestValueStreak := OrderedCollection new.\r\t(valueStreak size >= 5) \r\tifTrue: [\r\t\t(valueStreak size -4) to: (valueStreak size) do: [:i | highestValueStreak add: (valueStreak at: \ti)]]\r\tifFalse: [highestValueStreak := valueStreak].\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/30/2021 17:11',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T17:12:18.011794-05:00' ],		#prior : OmReference [ '117' ],		#self : OmReference [ '118' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand max highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\tTranscript show: current; cr.\r\t\t(previous == current)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. \t\tvalueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. valueStreak := aValue ] ].\r\r\thighestValueStreak := OrderedCollection new.\r\t(valueStreak size >= 5) \r\tifTrue: [\r\t\t(valueStreak size -4) to: (valueStreak size) do: [:i | highestValueStreak add: (valueStreak at: \ti)]]\r\tifFalse: [highestValueStreak := valueStreak].\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/30/2021 17:11',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand max highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\tTranscript show: valueStreak; cr.\r\t\t(previous == current)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. \t\tvalueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. valueStreak := aValue ] ].\r\r\thighestValueStreak := OrderedCollection new.\r\t(valueStreak size >= 5) \r\tifTrue: [\r\t\t(valueStreak size -4) to: (valueStreak size) do: [:i | highestValueStreak add: (valueStreak at: \ti)]]\r\tifFalse: [highestValueStreak := valueStreak].\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/30/2021 17:12',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T17:13:14.905794-05:00' ],		#prior : OmReference [ '118' ],		#self : OmReference [ '119' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand max highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\tTranscript show: valueStreak; cr.\r\t\t(previous == current)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. \t\tvalueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. valueStreak := aValue ] ].\r\r\thighestValueStreak := OrderedCollection new.\r\t(valueStreak size >= 5) \r\tifTrue: [\r\t\t(valueStreak size -4) to: (valueStreak size) do: [:i | highestValueStreak add: (valueStreak at: \ti)]]\r\tifFalse: [highestValueStreak := valueStreak].\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/30/2021 17:12',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand max highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\t(previous == current)\r\t\t\tifTrue: [Transcript show: \'h\'; cr. (valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. \t\tvalueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. valueStreak := aValue ] ].\r\r\thighestValueStreak := OrderedCollection new.\r\t(valueStreak size >= 5) \r\tifTrue: [\r\t\t(valueStreak size -4) to: (valueStreak size) do: [:i | highestValueStreak add: (valueStreak at: \ti)]]\r\tifFalse: [highestValueStreak := valueStreak].\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/30/2021 17:13',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T17:14:00.538794-05:00' ],		#prior : OmReference [ '119' ],		#self : OmReference [ '120' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand max highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\t(previous == current)\r\t\t\tifTrue: [Transcript show: \'h\'; cr. (valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. \t\tvalueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. valueStreak := aValue ] ].\r\r\thighestValueStreak := OrderedCollection new.\r\t(valueStreak size >= 5) \r\tifTrue: [\r\t\t(valueStreak size -4) to: (valueStreak size) do: [:i | highestValueStreak add: (valueStreak at: \ti)]]\r\tifFalse: [highestValueStreak := valueStreak].\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/30/2021 17:13',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand max highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\tTranscript show: previous; cr.\r\t\tTranscript show: current; cr.\r\t\t(previous == current)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. \t\tvalueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. valueStreak := aValue ] ].\r\r\thighestValueStreak := OrderedCollection new.\r\t(valueStreak size >= 5) \r\tifTrue: [\r\t\t(valueStreak size -4) to: (valueStreak size) do: [:i | highestValueStreak add: (valueStreak at: \ti)]]\r\tifFalse: [highestValueStreak := valueStreak].\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/30/2021 17:14',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T17:14:23.324794-05:00' ],		#prior : OmReference [ '120' ],		#self : OmReference [ '121' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand max highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\tTranscript show: previous; cr.\r\t\tTranscript show: current; cr.\r\t\t(previous == current)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. \t\tvalueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. valueStreak := aValue ] ].\r\r\thighestValueStreak := OrderedCollection new.\r\t(valueStreak size >= 5) \r\tifTrue: [\r\t\t(valueStreak size -4) to: (valueStreak size) do: [:i | highestValueStreak add: (valueStreak at: \ti)]]\r\tifFalse: [highestValueStreak := valueStreak].\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/30/2021 17:14',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand max highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\tTranscript show: previous class; cr.\r\t\tTranscript show: current class; cr.\r\t\t(previous == current)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. \t\tvalueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. valueStreak := aValue ] ].\r\r\thighestValueStreak := OrderedCollection new.\r\t(valueStreak size >= 5) \r\tifTrue: [\r\t\t(valueStreak size -4) to: (valueStreak size) do: [:i | highestValueStreak add: (valueStreak at: \ti)]]\r\tifFalse: [highestValueStreak := valueStreak].\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/30/2021 17:14',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T17:14:58.973794-05:00' ],		#prior : OmReference [ '121' ],		#self : OmReference [ '122' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand max highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\tTranscript show: previous class; cr.\r\t\tTranscript show: current class; cr.\r\t\t(previous == current)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. \t\tvalueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. valueStreak := aValue ] ].\r\r\thighestValueStreak := OrderedCollection new.\r\t(valueStreak size >= 5) \r\tifTrue: [\r\t\t(valueStreak size -4) to: (valueStreak size) do: [:i | highestValueStreak add: (valueStreak at: \ti)]]\r\tifFalse: [highestValueStreak := valueStreak].\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/30/2021 17:14',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand max highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\t(previous == current)\r\t\t\tifTrue: [\t\tTranscript show: current class; cr. (valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. \t\tvalueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. valueStreak := aValue ] ].\r\r\thighestValueStreak := OrderedCollection new.\r\t(valueStreak size >= 5) \r\tifTrue: [\r\t\t(valueStreak size -4) to: (valueStreak size) do: [:i | highestValueStreak add: (valueStreak at: \ti)]]\r\tifFalse: [highestValueStreak := valueStreak].\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/30/2021 17:14',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T17:16:05.948794-05:00' ],		#prior : OmReference [ '122' ],		#self : OmReference [ '123' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand max highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\t(previous == current)\r\t\t\tifTrue: [\t\tTranscript show: current class; cr. (valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. \t\tvalueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. valueStreak := aValue ] ].\r\r\thighestValueStreak := OrderedCollection new.\r\t(valueStreak size >= 5) \r\tifTrue: [\r\t\t(valueStreak size -4) to: (valueStreak size) do: [:i | highestValueStreak add: (valueStreak at: \ti)]]\r\tifFalse: [highestValueStreak := valueStreak].\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/30/2021 17:14',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand max highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\t(previous asNumber == current asNumber)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. \t\tvalueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. valueStreak := aValue ] ].\r\r\thighestValueStreak := OrderedCollection new.\r\t(valueStreak size >= 5) \r\tifTrue: [\r\t\t(valueStreak size -4) to: (valueStreak size) do: [:i | highestValueStreak add: (valueStreak at: \ti)]]\r\tifFalse: [highestValueStreak := valueStreak].\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/30/2021 17:16',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T17:28:48.127794-05:00' ],		#prior : OmReference [ '123' ],		#self : OmReference [ '124' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand max highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\t(previous asNumber == current asNumber)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. \t\tvalueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. valueStreak := aValue ] ].\r\r\thighestValueStreak := OrderedCollection new.\r\t(valueStreak size >= 5) \r\tifTrue: [\r\t\t(valueStreak size -4) to: (valueStreak size) do: [:i | highestValueStreak add: (valueStreak at: \ti)]]\r\tifFalse: [highestValueStreak := valueStreak].\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/30/2021 17:16',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\t(previous asNumber == current asNumber)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. \t\tvalueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmaxCount := 0.\r\tmaxVal := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > maxCount | (aKey > maxVal & (aValue size >= maxCount))) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue ] ].\r\r\thighestValueStreak := valueStreak.\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/30/2021 17:28',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T17:54:55.874794-05:00' ],		#prior : OmReference [ '124' ],		#self : OmReference [ '125' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flushOrSuitStreak straightFlush straightOrValueStreak maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tstraightOrValueStreak := self getHighestValueStreak: sorted.\r\tTranscript show: \'straightOrValueStreak\'; cr.\r\tTranscript show: straightOrValueStreak; cr.\r\t\r\tflushOrSuitStreak := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak; cr.\r\t\r\tstraightFlush := OrderedCollection new.\r\t(flushOrSuitStreak size > 4) ifTrue: [  \r\t\tstraightFlush := self getHighestStreak: flushOrSuitStreak.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush; cr.].\r\t\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t^sorted\r\t\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 17:04',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flushOrSuitStreak straightFlush valueStreak maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tvalueStreak := self getHighestValueStreak: sorted.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak; cr.\r\t\r\tflushOrSuitStreak := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak; cr.\r\t\r\tstraightFlush := OrderedCollection new.\r\t(flushOrSuitStreak size > 4) ifTrue: [  \r\t\tstraightFlush := self getHighestStreak: flushOrSuitStreak.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush; cr.].\r\t\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t^sorted\r\t\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 17:54',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T17:55:42.211794-05:00' ],		#prior : OmReference [ '125' ],		#self : OmReference [ '126' ]	},	#content : EpSessionSnapshot {		#imageName : 'C:\\Users\\Administrator\\Documents\\Pharo\\images\\Pharo 8.0 - 64bit (stable)\\Pharo 8.0 - 64bit (stable).image'	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T18:16:10.975794-05:00' ],		#prior : OmReference [ '126' ],		#self : OmReference [ '127' ]	},	#content : EpSessionSnapshot {		#imageName : 'C:\\Users\\Administrator\\Documents\\Pharo\\images\\Pharo 8.0 - 64bit (stable)\\Pharo 8.0 - 64bit (stable).image'	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T18:17:43.425794-05:00' ],		#prior : OmReference [ '127' ],		#self : OmReference [ '128' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\r\t(previous asNumber == (current asNumber -1) & notFound)\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r]].\r\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak',			#stamp : 'MagdalenaDhima 1/30/2021 13:56',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\r\t(previous asNumber == (current asNumber -1) & notFound)\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r]].\rTranscript show: \'h\', highestStreak; cr.\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak',			#stamp : 'MagdalenaDhima 1/30/2021 18:17',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T18:19:01.760794-05:00' ],		#prior : OmReference [ '128' ],		#self : OmReference [ '129' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\r\t(previous asNumber == (current asNumber -1) & notFound)\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r]].\rTranscript show: \'h\', highestStreak; cr.\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak',			#stamp : 'MagdalenaDhima 1/30/2021 18:17',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\r\t(previous asNumber == (current asNumber -1) & notFound)\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r]].\rTranscript show: highestStreak; cr.\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak',			#stamp : 'MagdalenaDhima 1/30/2021 18:19',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T18:21:02.533794-05:00' ],		#prior : OmReference [ '129' ],		#self : OmReference [ '130' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: nice\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: nice size do: [ :i | \r\tpreviousCard := nice at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := nice at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\r\t(previous asNumber == (current asNumber -1) & notFound)\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r]].\rTranscript show: highestStreak; cr.\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak',			#stamp : 'MagdalenaDhima 1/30/2021 18:19',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: shuf size do: [ :i | \r\tpreviousCard := shuf at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := shuf at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\r\t(previous asNumber == (current asNumber -1) & notFound)\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r]].\rTranscript show: streaks; cr.\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak',			#stamp : 'MagdalenaDhima 1/30/2021 18:21',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T18:22:50.406794-05:00' ],		#prior : OmReference [ '130' ],		#self : OmReference [ '131' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: shuf size do: [ :i | \r\tpreviousCard := shuf at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := shuf at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\r\t(previous asNumber == (current asNumber -1) & notFound)\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r]].\rTranscript show: streaks; cr.\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak',			#stamp : 'MagdalenaDhima 1/30/2021 18:21',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: shuf size do: [ :i | \r\tpreviousCard := shuf at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := shuf at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\r\t(previous asNumber == (current asNumber -1) & notFound)\r\t\tifTrue: [(streaks isEmpty) ifTrue: [Transcript show: current; cr. streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r]].\rTranscript show: streaks; cr.\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak',			#stamp : 'MagdalenaDhima 1/30/2021 18:22',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T18:29:21.039794-05:00' ],		#prior : OmReference [ '131' ],		#self : OmReference [ '132' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: shuf size do: [ :i | \r\tpreviousCard := shuf at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := shuf at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\r\t(previous asNumber == (current asNumber -1) & notFound)\r\t\tifTrue: [(streaks isEmpty) ifTrue: [Transcript show: current; cr. streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r]].\rTranscript show: streaks; cr.\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak',			#stamp : 'MagdalenaDhima 1/30/2021 18:22',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: shuf size do: [ :i | \r\tpreviousCard := shuf at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := shuf at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t(previous asNumber == (current asNumber -1) & notFound)\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r]] ].\rTranscript show: streaks; cr.\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak',			#stamp : 'MagdalenaDhima 1/30/2021 18:29',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T18:33:56.663794-05:00' ],		#prior : OmReference [ '132' ],		#self : OmReference [ '133' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flushOrSuitStreak straightFlush valueStreak maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tvalueStreak := self getHighestValueStreak: sorted.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak; cr.\r\t\r\tflushOrSuitStreak := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak; cr.\r\t\r\tstraightFlush := OrderedCollection new.\r\t(flushOrSuitStreak size > 4) ifTrue: [  \r\t\tstraightFlush := self getHighestStreak: flushOrSuitStreak.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush; cr.].\r\t\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t^sorted\r\t\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 17:54',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flushOrSuitStreak straightFlush valueStreak maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tvalueStreak := self getHighestValueStreak: sorted.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak; cr.\r\t\r\tflushOrSuitStreak := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak; cr.\r\t\r\tstraightFlush := OrderedCollection new.\r\t(flushOrSuitStreak size > 4) ifTrue: [  \r\t\tstraightFlush := self getHighestStreak: flushOrSuitStreak.\r\t\tTranscript show: flushOrSuitStreak; cr.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush; cr.].\r\t\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t^sorted\r\t\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 18:33',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T18:34:59.602794-05:00' ],		#prior : OmReference [ '133' ],		#self : OmReference [ '134' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flushOrSuitStreak straightFlush valueStreak maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tvalueStreak := self getHighestValueStreak: sorted.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak; cr.\r\t\r\tflushOrSuitStreak := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak; cr.\r\t\r\tstraightFlush := OrderedCollection new.\r\t(flushOrSuitStreak size > 4) ifTrue: [  \r\t\tstraightFlush := self getHighestStreak: flushOrSuitStreak.\r\t\tTranscript show: flushOrSuitStreak; cr.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush; cr.].\r\t\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t^sorted\r\t\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 18:33',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'deal:',			#protocol : #accessing,			#sourceCode : 'deal: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t| sorted data straight flushOrSuitStreak straightFlush valueStreak maxNumOfAKind suitOfAKind suitCards |\r\tself convert: shuf.\r\tTranscript show: \'hand\'; cr.\r\tTranscript show: hand; cr.\r\t\r\tsorted := self sort: hand.\r\tTranscript show: \'sorted\'; cr.\r\tTranscript show: sorted; cr.\r\t"\r\tdata := self getData.\r\tTranscript show: \'data\'; cr.\r\tTranscript show: data; cr.\r\t"\r\tstraight := self getHighestStreak: sorted.\r\tTranscript show: \'straight\'; cr.\r\tTranscript show: straight; cr.\r\t\r\tvalueStreak := self getHighestValueStreak: sorted.\r\tTranscript show: \'valueStreak\'; cr.\r\tTranscript show: valueStreak; cr.\r\t\r\tflushOrSuitStreak := self getHighestSuitStreak: sorted.\r\tTranscript show: \'flushOrSuitStreak\'; cr.\r\tTranscript show: flushOrSuitStreak; cr.\r\t\r\tstraightFlush := OrderedCollection new.\r\t(flushOrSuitStreak size > 4) ifTrue: [  \r\t\tstraightFlush := self getHighestStreak: flushOrSuitStreak.\r\t\tTranscript show: \'straightFlush\'; cr.\r\t\tTranscript show: straightFlush; cr.].\r\t\r\t(straightFlush size == 5) ifTrue: [Transcript show: 1; cr. ^straightFlush].\r\t(flushOrSuitStreak size == 4) ifTrue: [Transcript show: 3; cr. ^flushOrSuitStreak].\r\t^sorted\r\t\r\t\r\t"\r\tmaxNumOfAKind := ((data values) copyFrom: 14 to: 17) inject: 0 into: [:a :c | (a > c )\r   ifTrue: [a]\r   ifFalse: [c]].\r\tTranscript show: maxNumOfAKind; cr.\r\tsuitOfAKind := (data copyFrom: 14 to: 17) keyAtValue: maxNumOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t\r\tsuitCards := self returnSuitCards: suitOfAKind.\r\tTranscript show: suitOfAKind; cr.\r\t"\r\r\t\r',			#stamp : 'MagdalenaDhima 1/30/2021 18:34',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T18:36:38.274794-05:00' ],		#prior : OmReference [ '134' ],		#self : OmReference [ '135' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: shuf size do: [ :i | \r\tpreviousCard := shuf at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := shuf at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t(previous asNumber == (current asNumber -1) & notFound)\r\t\tifTrue: [(streaks isEmpty) ifTrue: [streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r]] ].\rTranscript show: streaks; cr.\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak',			#stamp : 'MagdalenaDhima 1/30/2021 18:29',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: shuf size do: [ :i | \r\tpreviousCard := shuf at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := shuf at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t(previous asNumber == (current asNumber -1) & notFound)\r\t\tifTrue: [(streaks isEmpty) ifTrue: [Transcript show: previousCard; cr. streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r]] ].\rTranscript show: streaks; cr.\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak',			#stamp : 'MagdalenaDhima 1/30/2021 18:36',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T18:37:07.016794-05:00' ],		#prior : OmReference [ '135' ],		#self : OmReference [ '136' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: shuf size do: [ :i | \r\tpreviousCard := shuf at: (i-1).\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := shuf at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t(previous asNumber == (current asNumber -1) & notFound)\r\t\tifTrue: [(streaks isEmpty) ifTrue: [Transcript show: previousCard; cr. streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r]] ].\rTranscript show: streaks; cr.\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak',			#stamp : 'MagdalenaDhima 1/30/2021 18:36',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestStreak: shuf\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| streaks notFound previousCard previous card current highestStreak |\rstreaks := OrderedCollection new.\rnotFound := true.\r2 to: shuf size do: [ :i | \r\tpreviousCard := shuf at: (i-1).\r\tTranscript show: previousCard; cr.\r\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\tcard := shuf at: i.\r\tcurrent := card copyFrom: 1 to: (card size-1).\r\t(previous ~= current) ifTrue: [  \r\t(previous asNumber == (current asNumber -1) & notFound)\r\t\tifTrue: [(streaks isEmpty) ifTrue: [Transcript show: previousCard; cr. streaks add: previousCard]. streaks add: card]\r\t\tifFalse: [(streaks size < 5) ifTrue: [streaks := OrderedCollection new] ifFalse: [notFound := false]\r]] ].\rTranscript show: streaks; cr.\rhighestStreak := OrderedCollection new.\r(streaks size >= 5) \r\tifTrue: [(streaks size -4) to: (streaks size) do: [ :i | highestStreak add: (streaks at: i) ]].\r\r^highestStreak',			#stamp : 'MagdalenaDhima 1/30/2021 18:37',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T18:41:04.828794-05:00' ],		#prior : OmReference [ '136' ],		#self : OmReference [ '137' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\t(previous asNumber == current asNumber)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. \t\tvalueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmaxCount := 0.\r\tmaxVal := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > maxCount | (aKey > maxVal & (aValue size >= maxCount))) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue ] ].\r\r\thighestValueStreak := valueStreak.\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/30/2021 17:28',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\t\r\tTTranscript show: streaks.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\t(previous asNumber == current asNumber)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. \t\tvalueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmaxCount := 0.\r\tmaxVal := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > maxCount | (aKey > maxVal & (aValue size >= maxCount))) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue ] ].\r\r\thighestValueStreak := valueStreak.\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/30/2021 18:41',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T18:41:18.009794-05:00' ],		#prior : OmReference [ '137' ],		#self : OmReference [ '138' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\t\r\tTTranscript show: streaks.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\t(previous asNumber == current asNumber)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. \t\tvalueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmaxCount := 0.\r\tmaxVal := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > maxCount | (aKey > maxVal & (aValue size >= maxCount))) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue ] ].\r\r\thighestValueStreak := valueStreak.\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/30/2021 18:41',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\t\r\tTranscript show: streaks.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\t(previous asNumber == current asNumber)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. \t\tvalueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmaxCount := 0.\r\tmaxVal := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > maxCount | (aKey > maxVal & (aValue size >= maxCount))) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue ] ].\r\r\thighestValueStreak := valueStreak.\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/30/2021 18:41',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T18:42:09.365794-05:00' ],		#prior : OmReference [ '138' ],		#self : OmReference [ '139' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\t\r\tTranscript show: streaks.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\t(previous asNumber == current asNumber)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. \t\tvalueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmaxCount := 0.\r\tmaxVal := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > maxCount | (aKey > maxVal & (aValue size >= maxCount))) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue ] ].\r\r\thighestValueStreak := valueStreak.\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/30/2021 18:41',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestValueStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestValueStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| previousCard previous card current valueStreak newList dataInHand maxVal maxCount highestValueStreak |\r\tvalueStreak := OrderedCollection new.\r\tnewList :=  OrderedCollection new.\r\r\tdataInHand := Dictionary new. \r\t1 to: 13 do: [ :i | dataInHand at: i put: newList].\r\t2 to: streaks size do: [ :i | \r\t\tpreviousCard := streaks at: (i-1).\r\t\tprevious := previousCard copyFrom: 1 to: (previousCard size-1).\r\t\tcard := streaks at: i.\r\t\tcurrent := card copyFrom: 1 to: (card size-1).\r\t\t(previous asNumber == current asNumber)\r\t\t\tifTrue: [(valueStreak isEmpty) ifTrue:[valueStreak add: previousCard]. valueStreak add: card]\r\t\t\tifFalse: [(valueStreak size ~= 0) ifTrue: [dataInHand at: previous asNumber put: valueStreak. \t\tvalueStreak := OrderedCollection new] ] ].\r\t(valueStreak size ~= 0) ifTrue: [dataInHand at: previous put: valueStreak].\r\r\tvalueStreak := OrderedCollection new.\r\tmaxCount := 0.\r\tmaxVal := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > maxCount | (aKey > maxVal & (aValue size >= maxCount))) ifTrue: [maxCount := aValue size. maxVal := aKey. valueStreak := aValue ] ].\r\r\thighestValueStreak := valueStreak.\r\r\t^highestValueStreak',			#stamp : 'MagdalenaDhima 1/30/2021 18:42',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T18:42:21.896794-05:00' ],		#prior : OmReference [ '139' ],		#self : OmReference [ '140' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: newList. dataInHand at: \'D\' put: newList. dataInHand at: \'H\' put: newList. dataInHand at: \'S\' put: newList.\r2 to: streaks size do: [ :i | \r\tpreviousCard := streaks at: (i-1).\r\tprevious := previousCard at: previousCard size.\r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\t(previous == current)\r\t\tifTrue: [(suitStreak isEmpty) ifTrue:[suitStreak add: previousCard]. suitStreak add: card]\r\t\tifFalse: [(suitStreak size ~= 0) ifTrue: [dataInHand at: previous put: suitStreak. suitStreak := \t\t\tOrderedCollection new] ] ].\r\t(suitStreak size ~= 0) ifTrue: [dataInHand at: previous put: suitStreak].\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 16:25',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rTranscript show: streaks.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: newList. dataInHand at: \'D\' put: newList. dataInHand at: \'H\' put: newList. dataInHand at: \'S\' put: newList.\r2 to: streaks size do: [ :i | \r\tpreviousCard := streaks at: (i-1).\r\tprevious := previousCard at: previousCard size.\r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\t(previous == current)\r\t\tifTrue: [(suitStreak isEmpty) ifTrue:[suitStreak add: previousCard]. suitStreak add: card]\r\t\tifFalse: [(suitStreak size ~= 0) ifTrue: [dataInHand at: previous put: suitStreak. suitStreak := \t\t\tOrderedCollection new] ] ].\r\t(suitStreak size ~= 0) ifTrue: [dataInHand at: previous put: suitStreak].\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 18:42',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T18:53:19.153794-05:00' ],		#prior : OmReference [ '140' ],		#self : OmReference [ '141' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rTranscript show: streaks.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: newList. dataInHand at: \'D\' put: newList. dataInHand at: \'H\' put: newList. dataInHand at: \'S\' put: newList.\r2 to: streaks size do: [ :i | \r\tpreviousCard := streaks at: (i-1).\r\tprevious := previousCard at: previousCard size.\r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\t(previous == current)\r\t\tifTrue: [(suitStreak isEmpty) ifTrue:[suitStreak add: previousCard]. suitStreak add: card]\r\t\tifFalse: [(suitStreak size ~= 0) ifTrue: [dataInHand at: previous put: suitStreak. suitStreak := \t\t\tOrderedCollection new] ] ].\r\t(suitStreak size ~= 0) ifTrue: [dataInHand at: previous put: suitStreak].\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 18:42',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: newList. dataInHand at: \'D\' put: newList. dataInHand at: \'H\' put: newList. dataInHand at: \'S\' put: newList.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current put: ( (dataInHand at: current) add: card ).\r\t].\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 18:53',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T18:54:00.819794-05:00' ],		#prior : OmReference [ '141' ],		#self : OmReference [ '142' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: newList. dataInHand at: \'D\' put: newList. dataInHand at: \'H\' put: newList. dataInHand at: \'S\' put: newList.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current put: ( (dataInHand at: current) add: card ).\r\t].\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 18:53',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: newList. dataInHand at: \'D\' put: newList. dataInHand at: \'H\' put: newList. dataInHand at: \'S\' put: newList.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current put: ( (dataInHand at: current) add: card ).\r\t].\r\tTranscript show: dataInHand.\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 18:54',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T18:55:14.769794-05:00' ],		#prior : OmReference [ '142' ],		#self : OmReference [ '143' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: newList. dataInHand at: \'D\' put: newList. dataInHand at: \'H\' put: newList. dataInHand at: \'S\' put: newList.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current put: ( (dataInHand at: current) add: card ).\r\t].\r\tTranscript show: dataInHand.\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 18:54',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: newList copy. dataInHand at: \'D\' put: newList copy. dataInHand at: \'H\' put: newList copy. dataInHand at: \'S\' put: newList copy. \r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current put: ( (dataInHand at: current) add: card ).\r\t].\r\tTranscript show: dataInHand.\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 18:55',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T18:55:49.146794-05:00' ],		#prior : OmReference [ '143' ],		#self : OmReference [ '144' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: newList copy. dataInHand at: \'D\' put: newList copy. dataInHand at: \'H\' put: newList copy. dataInHand at: \'S\' put: newList copy. \r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current put: ( (dataInHand at: current) add: card ).\r\t].\r\tTranscript show: dataInHand.\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 18:55',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: newList copy. dataInHand at: \'D\' put: newList copy. dataInHand at: \'H\' put: newList copy. dataInHand at: \'S\' put: newList copy. \r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: dataInHand.\r\tdataInHand at: current put: ( (dataInHand at: current) add: card ).\r\t].\r\tTranscript show: dataInHand.\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 18:55',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T18:56:41.658794-05:00' ],		#prior : OmReference [ '144' ],		#self : OmReference [ '145' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: newList copy. dataInHand at: \'D\' put: newList copy. dataInHand at: \'H\' put: newList copy. dataInHand at: \'S\' put: newList copy. \r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: dataInHand.\r\tdataInHand at: current put: ( (dataInHand at: current) add: card ).\r\t].\r\tTranscript show: dataInHand.\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 18:55',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: newList copy. dataInHand at: \'D\' put: newList copy. dataInHand at: \'H\' put: newList copy. dataInHand at: \'S\' put: newList copy. \r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: dataInHand.\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current) add: card ).\r\t].\r\tTranscript show: dataInHand.\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 18:56',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T18:57:18.038794-05:00' ],		#prior : OmReference [ '145' ],		#self : OmReference [ '146' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: newList copy. dataInHand at: \'D\' put: newList copy. dataInHand at: \'H\' put: newList copy. dataInHand at: \'S\' put: newList copy. \r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: dataInHand.\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current) add: card ).\r\t].\r\tTranscript show: dataInHand.\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 18:56',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: newList copy. dataInHand at: \'D\' put: newList copy. dataInHand at: \'H\' put: newList copy. dataInHand at: \'S\' put: newList copy. \r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: dataInHand.\r\tdataInHand at: current asString put: ( (dataInHand at: current) add: card ).\r\t].\r\tTranscript show: dataInHand.\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 18:57',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T18:58:01.528794-05:00' ],		#prior : OmReference [ '146' ],		#self : OmReference [ '147' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: newList copy. dataInHand at: \'D\' put: newList copy. dataInHand at: \'H\' put: newList copy. dataInHand at: \'S\' put: newList copy. \r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: dataInHand.\r\tdataInHand at: current asString put: ( (dataInHand at: current) add: card ).\r\t].\r\tTranscript show: dataInHand.\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 18:57',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: newList copy. dataInHand at: \'D\' put: newList copy. dataInHand at: \'H\' put: newList copy. dataInHand at: \'S\' put: newList copy. \r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current asSymbol).\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current) add: card ).\r\t].\r\tTranscript show: dataInHand.\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 18:58',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T18:58:20.187794-05:00' ],		#prior : OmReference [ '147' ],		#self : OmReference [ '148' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: newList copy. dataInHand at: \'D\' put: newList copy. dataInHand at: \'H\' put: newList copy. dataInHand at: \'S\' put: newList copy. \r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current asSymbol).\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current) add: card ).\r\t].\r\tTranscript show: dataInHand.\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 18:58',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: newList copy. dataInHand at: \'D\' put: newList copy. dataInHand at: \'H\' put: newList copy. dataInHand at: \'S\' put: newList copy. \r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current asSymbol).\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) add: card ).\r\t].\r\tTranscript show: dataInHand.\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 18:58',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T18:59:32.884794-05:00' ],		#prior : OmReference [ '148' ],		#self : OmReference [ '149' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: newList copy. dataInHand at: \'D\' put: newList copy. dataInHand at: \'H\' put: newList copy. dataInHand at: \'S\' put: newList copy. \r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current asSymbol).\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) add: card ).\r\t].\r\tTranscript show: dataInHand.\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 18:58',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: newList. dataInHand at: \'D\' put: newList. dataInHand at: \'H\' put: newList. dataInHand at: \'S\' put: newList. \r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current asSymbol).\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) add: card ).\r\t].\r\tTranscript show: dataInHand.\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 18:59',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T19:00:06.614794-05:00' ],		#prior : OmReference [ '149' ],		#self : OmReference [ '150' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: newList. dataInHand at: \'D\' put: newList. dataInHand at: \'H\' put: newList. dataInHand at: \'S\' put: newList. \r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current asSymbol).\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) add: card ).\r\t].\r\tTranscript show: dataInHand.\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 18:59',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: newList. dataInHand at: \'D\' put: newList. dataInHand at: \'H\' put: newList. dataInHand at: \'S\' put: newList. \r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current asSymbol).\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) add: card ).\r\tTranscript show: (dataInHand at: current asSymbol) class.\r\t].\r\tTranscript show: dataInHand.\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 19:00',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T19:01:02.977794-05:00' ],		#prior : OmReference [ '150' ],		#self : OmReference [ '151' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: newList. dataInHand at: \'D\' put: newList. dataInHand at: \'H\' put: newList. dataInHand at: \'S\' put: newList. \r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current asSymbol).\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) add: card ).\r\tTranscript show: (dataInHand at: current asSymbol) class.\r\t].\r\tTranscript show: dataInHand.\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 19:00',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: OrderedCollection new. dataInHand at: \'D\' put: OrderedCollection new. dataInHand at: \'H\' put: OrderedCollection new. dataInHand at: \'S\' put: OrderedCollection new. \r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current asSymbol).\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) add: card ).\r\tTranscript show: (dataInHand at: current asSymbol) class.\r\t].\r\tTranscript show: dataInHand.\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 19:01',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T19:01:49.423794-05:00' ],		#prior : OmReference [ '151' ],		#self : OmReference [ '152' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: OrderedCollection new. dataInHand at: \'D\' put: OrderedCollection new. dataInHand at: \'H\' put: OrderedCollection new. dataInHand at: \'S\' put: OrderedCollection new. \r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current asSymbol).\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol) add: card ).\r\tTranscript show: (dataInHand at: current asSymbol) class.\r\t].\r\tTranscript show: dataInHand.\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 19:01',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: OrderedCollection new. dataInHand at: \'D\' put: OrderedCollection new. dataInHand at: \'H\' put: OrderedCollection new. dataInHand at: \'S\' put: OrderedCollection new. \r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current asSymbol).\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol), card ).\r\tTranscript show: (dataInHand at: current asSymbol) class.\r\t].\r\tTranscript show: dataInHand.\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 19:01',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T19:02:57.220794-05:00' ],		#prior : OmReference [ '152' ],		#self : OmReference [ '153' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: OrderedCollection new. dataInHand at: \'D\' put: OrderedCollection new. dataInHand at: \'H\' put: OrderedCollection new. dataInHand at: \'S\' put: OrderedCollection new. \r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current asSymbol).\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol), card ).\r\tTranscript show: (dataInHand at: current asSymbol) class.\r\t].\r\tTranscript show: dataInHand.\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 19:01',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: OrderedCollection new. dataInHand at: \'D\' put: OrderedCollection new. dataInHand at: \'H\' put: OrderedCollection new. dataInHand at: \'S\' put: OrderedCollection new. \r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current asSymbol); cr.\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol), card ).\r\tTranscript show: (dataInHand at: current asSymbol); cr.\r\t].\r\tTranscript show: dataInHand; cr.\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 19:02',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T19:04:35.256794-05:00' ],		#prior : OmReference [ '153' ],		#self : OmReference [ '154' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: OrderedCollection new. dataInHand at: \'D\' put: OrderedCollection new. dataInHand at: \'H\' put: OrderedCollection new. dataInHand at: \'S\' put: OrderedCollection new. \r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current asSymbol); cr.\r\tdataInHand at: current asSymbol put: ( (dataInHand at: current asSymbol), card ).\r\tTranscript show: (dataInHand at: current asSymbol); cr.\r\t].\r\tTranscript show: dataInHand; cr.\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 19:02',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: OrderedCollection new. dataInHand at: \'D\' put: OrderedCollection new. dataInHand at: \'H\' put: OrderedCollection new. dataInHand at: \'S\' put: OrderedCollection new. \r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current asSymbol); cr.\r\tdataInHand at: current asSymbol put: ( card ).\r\tTranscript show: (dataInHand at: current asSymbol); cr.\r\t].\r\tTranscript show: dataInHand; cr.\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 19:04',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T19:05:53.098794-05:00' ],		#prior : OmReference [ '154' ],		#self : OmReference [ '155' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: OrderedCollection new. dataInHand at: \'D\' put: OrderedCollection new. dataInHand at: \'H\' put: OrderedCollection new. dataInHand at: \'S\' put: OrderedCollection new. \r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current asSymbol); cr.\r\tdataInHand at: current asSymbol put: ( card ).\r\tTranscript show: (dataInHand at: current asSymbol); cr.\r\t].\r\tTranscript show: dataInHand; cr.\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 19:04',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: Array new. dataInHand at: \'D\' put: Array new. dataInHand at: \'H\' put: Array new. dataInHand at: \'S\' put: Array new. \r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current asSymbol); cr.\r\tdataInHand at: current asSymbol put: ( card ).\r\tTranscript show: (dataInHand at: current asSymbol); cr.\r\t].\r\tTranscript show: dataInHand; cr.\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 19:05',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T19:07:21.004794-05:00' ],		#prior : OmReference [ '155' ],		#self : OmReference [ '156' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: Array new. dataInHand at: \'D\' put: Array new. dataInHand at: \'H\' put: Array new. dataInHand at: \'S\' put: Array new. \r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current asSymbol); cr.\r\tdataInHand at: current asSymbol put: ( card ).\r\tTranscript show: (dataInHand at: current asSymbol); cr.\r\t].\r\tTranscript show: dataInHand; cr.\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 19:05',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: newList. dataInHand at: \'D\' put: newList. dataInHand at: \'H\' put: newList. dataInHand at: \'S\' put: newList.\r2 to: streaks size do: [ :i | \r\tpreviousCard := streaks at: (i-1).\r\tprevious := previousCard at: previousCard size.\r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\t(previous == current)\r\t\tifTrue: [(suitStreak isEmpty) ifTrue:[suitStreak add: previousCard]. suitStreak add: card]\r\t\tifFalse: [(suitStreak size ~= 0) ifTrue: [dataInHand at: previous put: suitStreak. suitStreak := \t\t\tOrderedCollection new] ] ].\r\t(suitStreak size ~= 0) ifTrue: [dataInHand at: previous put: suitStreak].\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 19:07',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T19:10:10.170794-05:00' ],		#prior : OmReference [ '156' ],		#self : OmReference [ '157' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: newList. dataInHand at: \'D\' put: newList. dataInHand at: \'H\' put: newList. dataInHand at: \'S\' put: newList.\r2 to: streaks size do: [ :i | \r\tpreviousCard := streaks at: (i-1).\r\tprevious := previousCard at: previousCard size.\r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\t(previous == current)\r\t\tifTrue: [(suitStreak isEmpty) ifTrue:[suitStreak add: previousCard]. suitStreak add: card]\r\t\tifFalse: [(suitStreak size ~= 0) ifTrue: [dataInHand at: previous put: suitStreak. suitStreak := \t\t\tOrderedCollection new] ] ].\r\t(suitStreak size ~= 0) ifTrue: [dataInHand at: previous put: suitStreak].\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 19:07',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: newList. dataInHand at: \'D\' put: newList. dataInHand at: \'H\' put: newList. dataInHand at: \'S\' put: newList.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current put: ((dataInHand at: current) add: card)].\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 19:10',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T19:11:07.692794-05:00' ],		#prior : OmReference [ '157' ],		#self : OmReference [ '158' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: newList. dataInHand at: \'D\' put: newList. dataInHand at: \'H\' put: newList. dataInHand at: \'S\' put: newList.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tdataInHand at: current put: ((dataInHand at: current) add: card)].\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 19:10',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: newList. dataInHand at: \'D\' put: newList. dataInHand at: \'H\' put: newList. dataInHand at: \'S\' put: newList.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) add: card)].\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 19:11',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T19:13:52.812794-05:00' ],		#prior : OmReference [ '158' ],		#self : OmReference [ '159' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: newList. dataInHand at: \'D\' put: newList. dataInHand at: \'H\' put: newList. dataInHand at: \'S\' put: newList.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) add: card)].\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 19:11',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 19:13',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T19:14:36.999794-05:00' ],		#prior : OmReference [ '159' ],		#self : OmReference [ '160' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: \'C\' put: \'\'. dataInHand at: \'D\' put: \'\'. dataInHand at: \'H\' put: \'\'. dataInHand at: \'S\' put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 19:13',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 19:14',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T19:15:36.343794-05:00' ],		#prior : OmReference [ '160' ],		#self : OmReference [ '161' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 19:14',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: OrderedCollection new. dataInHand at: $D put: OrderedCollection new. dataInHand at: $H put: OrderedCollection new. dataInHand at: $S put: OrderedCollection new.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) add: card).\r\tTranscript show: (dataInHand at: current); cr.].\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 19:15',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T19:16:00.939794-05:00' ],		#prior : OmReference [ '161' ],		#self : OmReference [ '162' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: OrderedCollection new. dataInHand at: $D put: OrderedCollection new. dataInHand at: $H put: OrderedCollection new. dataInHand at: $S put: OrderedCollection new.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) add: card).\r\tTranscript show: (dataInHand at: current); cr.].\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 19:15',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 19:16',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T19:19:50.842794-05:00' ],		#prior : OmReference [ '162' ],		#self : OmReference [ '163' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 19:16',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , \' \' , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 19:19',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T19:45:04.729794-05:00' ],		#prior : OmReference [ '163' ],		#self : OmReference [ '164' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak newList dataInHand max |\rsuitStreak := OrderedCollection new.\rnewList :=  OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , \' \' , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\t(aValue size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 19:19',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , \' \' , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tcount := 0. word := \'\'.\r\t\taValue do: [:a | (a ~= \' \' & count ~= 0) ifTrue: [count := count + 1. word at: count put: a\r\t\t\t\t\t\t\tifFalse: [ count := count + 1. suitStreak add: word. word := \'\' ] ] ]. \r\t\t(count size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 19:45',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T19:45:38.922794-05:00' ],		#prior : OmReference [ '164' ],		#self : OmReference [ '165' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , \' \' , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tcount := 0. word := \'\'.\r\t\taValue do: [:a | (a ~= \' \' & count ~= 0) ifTrue: [count := count + 1. word at: count put: a\r\t\t\t\t\t\t\tifFalse: [ count := count + 1. suitStreak add: word. word := \'\' ] ] ]. \r\t\t(count size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 19:45',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , \' \' , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\t\r\tTranscript show: (dataInHand); cr.\r\t\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tcount := 0. word := \'\'.\r\t\taValue do: [:a | (a ~= \' \' & count ~= 0) ifTrue: [count := count + 1. word at: count put: a\r\t\t\t\t\t\t\tifFalse: [ count := count + 1. suitStreak add: word. word := \'\' ] ] ]. \r\t\t(count size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 19:45',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T19:50:21.988794-05:00' ],		#prior : OmReference [ '165' ],		#self : OmReference [ '166' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , \' \' , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\t\r\tTranscript show: (dataInHand); cr.\r\t\r\tsuitStreak := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tcount := 0. word := \'\'.\r\t\taValue do: [:a | (a ~= \' \' & count ~= 0) ifTrue: [count := count + 1. word at: count put: a\r\t\t\t\t\t\t\tifFalse: [ count := count + 1. suitStreak add: word. word := \'\' ] ] ]. \r\t\t(count size > max) ifTrue: [max := aValue size. suitStreak := aValue ] ].\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 19:45',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , \' \' , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\t\r\tTranscript show: (dataInHand); cr.\r\t\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tcount := 0. word := \'\'.\r\t\taValue do: [:a | (a ~= \' \' & (count ~= 0) ) ifTrue: [count := count + 1. word at: count put: a]\r\t\t\t\t\t\t\tifFalse: [ count := count + 1. temp add: word. word := \'\' ] ]. \r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: (suitStreak); cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 19:50',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T19:51:10.246794-05:00' ],		#prior : OmReference [ '166' ],		#self : OmReference [ '167' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , \' \' , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\t\r\tTranscript show: (dataInHand); cr.\r\t\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tcount := 0. word := \'\'.\r\t\taValue do: [:a | (a ~= \' \' & (count ~= 0) ) ifTrue: [count := count + 1. word at: count put: a]\r\t\t\t\t\t\t\tifFalse: [ count := count + 1. temp add: word. word := \'\' ] ]. \r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: (suitStreak); cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 19:50',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , \' \' , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\t\r\tTranscript show: (dataInHand); cr.\r\t\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tcount := 0. word := \'\'.\r\t\taValue do: [:a | Transcript show: a. (a ~= \' \' & (count ~= 0) ) ifTrue: [count := count + 1. word at: count put: a]\r\t\t\t\t\t\t\tifFalse: [ count := count + 1. temp add: word. word := \'\' ] ]. \r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: (suitStreak); cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 19:51',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T19:52:00.557794-05:00' ],		#prior : OmReference [ '167' ],		#self : OmReference [ '168' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , \' \' , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\t\r\tTranscript show: (dataInHand); cr.\r\t\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tcount := 0. word := \'\'.\r\t\taValue do: [:a | Transcript show: a. (a ~= \' \' & (count ~= 0) ) ifTrue: [count := count + 1. word at: count put: a]\r\t\t\t\t\t\t\tifFalse: [ count := count + 1. temp add: word. word := \'\' ] ]. \r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: (suitStreak); cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 19:51',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , \' \' , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\t\r\tTranscript show: (dataInHand); cr.\r\t\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tcount := 0. word := \'\'.\r\t\taValue do: [:a | (a ~= \' \' & (count ~= 0) ) ifTrue: [count := count + 1. word at: count put: a]\r\t\t\t\t\t\t\tifFalse: [ count := count + 1. temp add: word. word := \'\' ] ]. \r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: (suitStreak); cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 19:52',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T19:52:17.439794-05:00' ],		#prior : OmReference [ '168' ],		#self : OmReference [ '169' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , \' \' , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\t\r\tTranscript show: (dataInHand); cr.\r\t\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tcount := 0. word := \'\'.\r\t\taValue do: [:a | (a ~= \' \' & (count ~= 0) ) ifTrue: [count := count + 1. word at: count put: a]\r\t\t\t\t\t\t\tifFalse: [ count := count + 1. temp add: word. word := \'\' ] ]. \r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: (suitStreak); cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 19:52',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , \' \' , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\t\r\tTranscript show: (dataInHand); cr.\r\t\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tcount := 0. word := \'\'.\r\t\taValue do: [:a | Transcript show: (temp); cr. (a ~= \' \' & (count ~= 0) ) ifTrue: [count := count + 1. word at: count put: a]\r\t\t\t\t\t\t\tifFalse: [ count := count + 1. temp add: word. word := \'\' ] ]. \r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: (suitStreak); cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 19:52',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T19:53:23.781794-05:00' ],		#prior : OmReference [ '169' ],		#self : OmReference [ '170' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , \' \' , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\t\r\tTranscript show: (dataInHand); cr.\r\t\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tcount := 0. word := \'\'.\r\t\taValue do: [:a | Transcript show: (temp); cr. (a ~= \' \' & (count ~= 0) ) ifTrue: [count := count + 1. word at: count put: a]\r\t\t\t\t\t\t\tifFalse: [ count := count + 1. temp add: word. word := \'\' ] ]. \r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: (suitStreak); cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 19:52',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , \' \' , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\t\r\tTranscript show: (dataInHand); cr.\r\t\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tcount := 0. word := \'\'.\r\t\taValue do: [:a | Transcript show: (a); cr. (a ~= \' \' & (count ~= 0) ) ifTrue: [count := count + 1. word at: count put: a]\r\t\t\t\t\t\t\tifFalse: [ count := count + 1. temp add: word. word := \'\' ] ]. \r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: (suitStreak); cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 19:53',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T19:55:05.808794-05:00' ],		#prior : OmReference [ '170' ],		#self : OmReference [ '171' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , \' \' , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\t\r\tTranscript show: (dataInHand); cr.\r\t\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tcount := 0. word := \'\'.\r\t\taValue do: [:a | Transcript show: (a); cr. (a ~= \' \' & (count ~= 0) ) ifTrue: [count := count + 1. word at: count put: a]\r\t\t\t\t\t\t\tifFalse: [ count := count + 1. temp add: word. word := \'\' ] ]. \r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: (suitStreak); cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 19:53',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , \' \' , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\t\r\tTranscript show: (dataInHand); cr.\r\t\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tcount := 0. word := \'\'.\r\t\taValue do: [:a | (a ~= \' \' & (count ~= 0) ) ifTrue: [count := count + 1. word at: count put: a]\r\t\t\t\t\t\t\tifFalse: [ count := count + 1. (count ~= 0) ifTrue: [temp add: word. word := \'\' ]] ]. \r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: (suitStreak); cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 19:55',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T19:56:08.792794-05:00' ],		#prior : OmReference [ '171' ],		#self : OmReference [ '172' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , \' \' , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\t\r\tTranscript show: (dataInHand); cr.\r\t\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tcount := 0. word := \'\'.\r\t\taValue do: [:a | (a ~= \' \' & (count ~= 0) ) ifTrue: [count := count + 1. word at: count put: a]\r\t\t\t\t\t\t\tifFalse: [ count := count + 1. (count ~= 0) ifTrue: [temp add: word. word := \'\' ]] ]. \r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: (suitStreak); cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 19:55',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , \' \' , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\t\r\tTranscript show: (dataInHand); cr.\r\t\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tcount := 0. word := \'\'.\r\t\taValue do: [:a | Transcript show: (a); cr. (a ~= \' \' & (count ~= 0) ) ifTrue: [count := count + 1. word at: count put: a]\r\t\t\t\t\t\t\tifFalse: [ count := count + 1. (count ~= 0) ifTrue: [temp add: word. word := \'\' ]] ]. \r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: (suitStreak); cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 19:56',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T19:56:57.692794-05:00' ],		#prior : OmReference [ '172' ],		#self : OmReference [ '173' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , \' \' , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\t\r\tTranscript show: (dataInHand); cr.\r\t\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tcount := 0. word := \'\'.\r\t\taValue do: [:a | Transcript show: (a); cr. (a ~= \' \' & (count ~= 0) ) ifTrue: [count := count + 1. word at: count put: a]\r\t\t\t\t\t\t\tifFalse: [ count := count + 1. (count ~= 0) ifTrue: [temp add: word. word := \'\' ]] ]. \r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: (suitStreak); cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 19:56',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , \' \' , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\t\r\tTranscript show: (dataInHand); cr.\r\t\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tcount := 0. word := \'\'.\r\t\taValue do: [:a | Transcript show: (a); cr. (a ~= \' \' & (count ~= 0) ) ifTrue: [count := count + 1. word at: count put: a]\r\t\t\t\t\t\t\tifFalse: [ count := count + 1. (count ~= 1) ifTrue: [temp add: word. word := \'\' ]] ]. \r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: (suitStreak); cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 19:56',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T19:57:24.958794-05:00' ],		#prior : OmReference [ '173' ],		#self : OmReference [ '174' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , \' \' , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\t\r\tTranscript show: (dataInHand); cr.\r\t\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tcount := 0. word := \'\'.\r\t\taValue do: [:a | Transcript show: (a); cr. (a ~= \' \' & (count ~= 0) ) ifTrue: [count := count + 1. word at: count put: a]\r\t\t\t\t\t\t\tifFalse: [ count := count + 1. (count ~= 1) ifTrue: [temp add: word. word := \'\' ]] ]. \r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: (suitStreak); cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 19:56',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , \' \' , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\t\r\tTranscript show: (dataInHand); cr.\r\t\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tcount := 0. word := \'\'.\r\t\taValue do: [:a | Transcript show: (a); cr. (a ~= \' \' & (count ~= 0) ) ifTrue: [count := count + 1. word at: count put: a]\r\t\t\t\t\t\t\tifFalse: [ (count ~= 0) ifTrue: [temp add: word. word := \'\' ]. count := count + 1. ] ]. \r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: (suitStreak); cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 19:57',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T20:00:22.816794-05:00' ],		#prior : OmReference [ '174' ],		#self : OmReference [ '175' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , \' \' , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\t\r\tTranscript show: (dataInHand); cr.\r\t\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tcount := 0. word := \'\'.\r\t\taValue do: [:a | Transcript show: (a); cr. (a ~= \' \' & (count ~= 0) ) ifTrue: [count := count + 1. word at: count put: a]\r\t\t\t\t\t\t\tifFalse: [ (count ~= 0) ifTrue: [temp add: word. word := \'\' ]. count := count + 1. ] ]. \r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: (suitStreak); cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 19:57',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , \' \' , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\t\r\tTranscript show: (dataInHand); cr.\r\t\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tcount := 0. word := \'\'.\r\t\taValue do: [:a | Transcript show: (a); cr. (a ~= \' \' & (count ~= 0) ) \r\t\t\tifTrue: [count := count + 1. word at: count put: a]\r\t\t\tifFalse: [ (count ~= 0) ifTrue: [temp add: word. word := \'\' ] ]  ]. \r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: (suitStreak); cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:00',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T20:00:53.738794-05:00' ],		#prior : OmReference [ '175' ],		#self : OmReference [ '176' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , \' \' , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\t\r\tTranscript show: (dataInHand); cr.\r\t\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tcount := 0. word := \'\'.\r\t\taValue do: [:a | Transcript show: (a); cr. (a ~= \' \' & (count ~= 0) ) \r\t\t\tifTrue: [count := count + 1. word at: count put: a]\r\t\t\tifFalse: [ (count ~= 0) ifTrue: [temp add: word. word := \'\' ] ]  ]. \r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: (suitStreak); cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:00',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , \' \' , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\t\r\tTranscript show: (dataInHand); cr.\r\t\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tcount := 0. word := \'\'.\r\t\taValue do: [:a | Transcript show: (a); cr. (a ~= \' \' & (count ~= 0) ) \r\t\t\tifTrue: [count := count + 1. word at: count put: a]\r\t\t\tifFalse: [ (count ~= 0) ifTrue: [temp add: word. word := \'\' ] ]  ]. \r\t\tTranscript show: (temp); cr.\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: (suitStreak); cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:00',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T20:03:28.519794-05:00' ],		#prior : OmReference [ '176' ],		#self : OmReference [ '177' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , \' \' , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\t\r\tTranscript show: (dataInHand); cr.\r\t\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tcount := 0. word := \'\'.\r\t\taValue do: [:a | Transcript show: (a); cr. (a ~= \' \' & (count ~= 0) ) \r\t\t\tifTrue: [count := count + 1. word at: count put: a]\r\t\t\tifFalse: [ (count ~= 0) ifTrue: [temp add: word. word := \'\' ] ]  ]. \r\t\tTranscript show: (temp); cr.\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: (suitStreak); cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:00',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| spaces temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , \' \' , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\t\r\tTranscript show: (dataInHand); cr.\r\t\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tcount := 0. spaces := 0. word := \'\'.\r\t\taValue do: [:a | Transcript show: (a); cr. (a ~= \' \' & (count ~= 0) ) \r\t\t\tifTrue: [count := count + 1. word at: count put: a]\r\t\t\tifFalse: [ (count ~= 0) ifTrue: [temp add: word. word := \'\' ] ]  ]. \r\t\tTranscript show: (temp); cr.\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: (suitStreak); cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:03',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T20:04:24.756794-05:00' ],		#prior : OmReference [ '177' ],		#self : OmReference [ '178' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| spaces temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , \' \' , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\t\r\tTranscript show: (dataInHand); cr.\r\t\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tcount := 0. spaces := 0. word := \'\'.\r\t\taValue do: [:a | Transcript show: (a); cr. (a ~= \' \' & (count ~= 0) ) \r\t\t\tifTrue: [count := count + 1. word at: count put: a]\r\t\t\tifFalse: [ (count ~= 0) ifTrue: [temp add: word. word := \'\' ] ]  ]. \r\t\tTranscript show: (temp); cr.\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: (suitStreak); cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:03',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| spaces temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , \' \' , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\t\r\tTranscript show: (dataInHand); cr.\r\t\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tcount := 0. spaces := 0. word := \'\'.\r\t\taValue do: [:a | Transcript show: (a); cr. (a ~= \' \' & (count ~= 0) ) \r\t\t\tifTrue: [count := count + 1. word at: count put: a]\r\t\t\tifFalse: [ (count ~= 0) ifTrue: [temp add: word. word := \'\' ]. count := count + 1. spaces := spaces + 1. ]  ]. \r\t\tTranscript show: (temp); cr.\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: (suitStreak); cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:04',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T20:09:14.146794-05:00' ],		#prior : OmReference [ '178' ],		#self : OmReference [ '179' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| spaces temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , \' \' , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\t\r\tTranscript show: (dataInHand); cr.\r\t\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tcount := 0. spaces := 0. word := \'\'.\r\t\taValue do: [:a | Transcript show: (a); cr. (a ~= \' \' & (count ~= 0) ) \r\t\t\tifTrue: [count := count + 1. word at: count put: a]\r\t\t\tifFalse: [ (count ~= 0) ifTrue: [temp add: word. word := \'\' ]. count := count + 1. spaces := spaces + 1. ]  ]. \r\t\tTranscript show: (temp); cr.\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: (suitStreak); cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:04',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| spaces temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , \' \' , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\t\r\tTranscript show: (dataInHand); cr.\r\t\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tcount := 1. spaces := 0. word := \'\'.\r\t\taValue do: [:a | Transcript show: (a); cr. (a ~= \' \' & (count ~= 1) ) \r\t\t\tifTrue: [word at: (count - spaces) put: a]\r\t\t\tifFalse: [ (count ~= 1) ifTrue: [temp add: word. word := \'\' ]. count := count + 1. spaces := spaces + 1. ]  ]. \r\t\tTranscript show: (temp); cr.\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: (suitStreak); cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:09',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T20:09:59.930794-05:00' ],		#prior : OmReference [ '179' ],		#self : OmReference [ '180' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| spaces temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , \' \' , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\t\r\tTranscript show: (dataInHand); cr.\r\t\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tcount := 1. spaces := 0. word := \'\'.\r\t\taValue do: [:a | Transcript show: (a); cr. (a ~= \' \' & (count ~= 1) ) \r\t\t\tifTrue: [word at: (count - spaces) put: a]\r\t\t\tifFalse: [ (count ~= 1) ifTrue: [temp add: word. word := \'\' ]. count := count + 1. spaces := spaces + 1. ]  ]. \r\t\tTranscript show: (temp); cr.\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: (suitStreak); cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:09',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| spaces temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , \' \' , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\t\r\tTranscript show: (dataInHand); cr.\r\t\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tcount := 1. spaces := 0. word := \'\'.\r\t\taValue do: [:a | Transcript show: (a); cr. (a ~= \' \' & (count ~= 1) ) \r\t\t\tifTrue: [word at: (count - spaces) put: a]\r\t\t\tifFalse: [ (count ~= 1) ifTrue: [temp add: word. word := \'\' ]. count := count + 1. spaces := spaces + 1. Transcript show: ((count - spaces)); cr.]  ]. \r\t\tTranscript show: (temp); cr.\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: (suitStreak); cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:09',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T20:11:01.241794-05:00' ],		#prior : OmReference [ '180' ],		#self : OmReference [ '181' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| spaces temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , \' \' , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\t\r\tTranscript show: (dataInHand); cr.\r\t\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tcount := 1. spaces := 0. word := \'\'.\r\t\taValue do: [:a | Transcript show: (a); cr. (a ~= \' \' & (count ~= 1) ) \r\t\t\tifTrue: [word at: (count - spaces) put: a]\r\t\t\tifFalse: [ (count ~= 1) ifTrue: [temp add: word. word := \'\' ]. count := count + 1. spaces := spaces + 1. Transcript show: ((count - spaces)); cr.]  ]. \r\t\tTranscript show: (temp); cr.\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: (suitStreak); cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:09',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| spaces temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , \' \' , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\t\r\tTranscript show: (dataInHand); cr.\r\t\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tcount := 1. spaces := 0. word := \'\'.\r\t\taValue do: [:a | Transcript show: \'h\'. Transcript show: (a); cr. (a ~= \' \' & (count ~= 1) ) \r\t\t\tifTrue: [word at: (count - spaces) put: a]\r\t\t\tifFalse: [ (count ~= 1) ifTrue: [temp add: word. word := \'\' ]. count := count + 1. spaces := spaces + 1. Transcript show: ((count - spaces)); cr.]  ]. \r\t\tTranscript show: (temp); cr.\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: (suitStreak); cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:11',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T20:12:03.591794-05:00' ],		#prior : OmReference [ '181' ],		#self : OmReference [ '182' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| spaces temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , \' \' , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\t\r\tTranscript show: (dataInHand); cr.\r\t\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tcount := 1. spaces := 0. word := \'\'.\r\t\taValue do: [:a | Transcript show: \'h\'. Transcript show: (a); cr. (a ~= \' \' & (count ~= 1) ) \r\t\t\tifTrue: [word at: (count - spaces) put: a]\r\t\t\tifFalse: [ (count ~= 1) ifTrue: [temp add: word. word := \'\' ]. count := count + 1. spaces := spaces + 1. Transcript show: ((count - spaces)); cr.]  ]. \r\t\tTranscript show: (temp); cr.\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: (suitStreak); cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:11',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| spaces temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , \' \' , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\t\r\tTranscript show: (dataInHand); cr.\r\t\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tcount := 1. spaces := 0. word := \'\'.\r\t\taValue do: [:a | Transcript show: \'h\'. Transcript show: (a); cr. (a ~= \' \' & (count ~= 1) ) \r\t\t\tifTrue: [word at: (count - spaces) put: a. count := count + 1.]\r\t\t\tifFalse: [ (count ~= 1) ifTrue: [temp add: word. word := \'\' ]. count := count + 1. spaces := spaces + 1. Transcript show: ((count - spaces)); cr.]  ]. \r\t\tTranscript show: (temp); cr.\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: (suitStreak); cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:12',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T20:12:35.708794-05:00' ],		#prior : OmReference [ '182' ],		#self : OmReference [ '183' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| spaces temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , \' \' , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\t\r\tTranscript show: (dataInHand); cr.\r\t\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tcount := 1. spaces := 0. word := \'\'.\r\t\taValue do: [:a | Transcript show: \'h\'. Transcript show: (a); cr. (a ~= \' \' & (count ~= 1) ) \r\t\t\tifTrue: [word at: (count - spaces) put: a. count := count + 1.]\r\t\t\tifFalse: [ (count ~= 1) ifTrue: [temp add: word. word := \'\' ]. count := count + 1. spaces := spaces + 1. Transcript show: ((count - spaces)); cr.]  ]. \r\t\tTranscript show: (temp); cr.\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: (suitStreak); cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:12',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| spaces temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , \' \' , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\t\r\tTranscript show: (dataInHand); cr.\r\t\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tcount := 1. spaces := 0. word := \'\'.\r\t\taValue do: [:a | Transcript show: \'h\'. Transcript show: (a); cr. (a ~= \' \' & (count ~= 1) ) \r\t\t\tifTrue: [word at: (count - spaces) put: a. count := count + 1. Transcript show: word.]\r\t\t\tifFalse: [ (count ~= 1) ifTrue: [temp add: word. word := \'\' ]. count := count + 1. spaces := spaces + 1. Transcript show: ((count - spaces)); cr.]  ]. \r\t\tTranscript show: (temp); cr.\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: (suitStreak); cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:12',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T20:14:30.089794-05:00' ],		#prior : OmReference [ '183' ],		#self : OmReference [ '184' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| spaces temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , \' \' , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\t\r\tTranscript show: (dataInHand); cr.\r\t\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tcount := 1. spaces := 0. word := \'\'.\r\t\taValue do: [:a | Transcript show: \'h\'. Transcript show: (a); cr. (a ~= \' \' & (count ~= 1) ) \r\t\t\tifTrue: [word at: (count - spaces) put: a. count := count + 1. Transcript show: word.]\r\t\t\tifFalse: [ (count ~= 1) ifTrue: [temp add: word. word := \'\' ]. count := count + 1. spaces := spaces + 1. Transcript show: ((count - spaces)); cr.]  ]. \r\t\tTranscript show: (temp); cr.\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: (suitStreak); cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:12',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| spaces temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , \' \' , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\t\r\tTranscript show: (dataInHand); cr.\r\t\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tcount := 1. spaces := 0. word := \'\'.\r\t\taValue do: [:a | Transcript show: \'h\'. Transcript show: (a); cr. (a ~= \' \' & (count ~= 1) ) \r\t\t\tifTrue: [word at: (count - spaces) put: a asString. count := count + 1. Transcript show: word.]\r\t\t\tifFalse: [ (count ~= 1) ifTrue: [temp add: word. word := \'\' ]. count := count + 1. spaces := spaces + 1. Transcript show: ((count - spaces)); cr.]  ]. \r\t\tTranscript show: (temp); cr.\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: (suitStreak); cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:14',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T20:14:48.469794-05:00' ],		#prior : OmReference [ '184' ],		#self : OmReference [ '185' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| spaces temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , \' \' , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\t\r\tTranscript show: (dataInHand); cr.\r\t\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tcount := 1. spaces := 0. word := \'\'.\r\t\taValue do: [:a | Transcript show: \'h\'. Transcript show: (a); cr. (a ~= \' \' & (count ~= 1) ) \r\t\t\tifTrue: [word at: (count - spaces) put: a asString. count := count + 1. Transcript show: word.]\r\t\t\tifFalse: [ (count ~= 1) ifTrue: [temp add: word. word := \'\' ]. count := count + 1. spaces := spaces + 1. Transcript show: ((count - spaces)); cr.]  ]. \r\t\tTranscript show: (temp); cr.\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: (suitStreak); cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:14',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| spaces temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , \' \' , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\t\r\tTranscript show: (dataInHand); cr.\r\t\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tcount := 1. spaces := 0. word := \'\'.\r\t\taValue do: [:a | Transcript show: \'h\'. Transcript show: (a); cr. (a ~= \' \' & (count ~= 1) ) \r\t\t\tifTrue: [word at: (count - spaces) put: a asCharacter. count := count + 1. Transcript show: word.]\r\t\t\tifFalse: [ (count ~= 1) ifTrue: [temp add: word. word := \'\' ]. count := count + 1. spaces := spaces + 1. Transcript show: ((count - spaces)); cr.]  ]. \r\t\tTranscript show: (temp); cr.\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: (suitStreak); cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:14',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T20:17:30.226794-05:00' ],		#prior : OmReference [ '185' ],		#self : OmReference [ '186' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| spaces temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , \' \' , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\t\r\tTranscript show: (dataInHand); cr.\r\t\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tcount := 1. spaces := 0. word := \'\'.\r\t\taValue do: [:a | Transcript show: \'h\'. Transcript show: (a); cr. (a ~= \' \' & (count ~= 1) ) \r\t\t\tifTrue: [word at: (count - spaces) put: a asCharacter. count := count + 1. Transcript show: word.]\r\t\t\tifFalse: [ (count ~= 1) ifTrue: [temp add: word. word := \'\' ]. count := count + 1. spaces := spaces + 1. Transcript show: ((count - spaces)); cr.]  ]. \r\t\tTranscript show: (temp); cr.\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: (suitStreak); cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:14',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| spaces temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , \' \' , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\t\r\tTranscript show: (dataInHand); cr.\r\t\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tcount := 1. spaces := 0. word := \'\'.\r\t\taValue do: [:a | Transcript show: \'h\'. Transcript show: (a); cr. (a ~= \' \' & (count ~= 1) ) \r\t\t\tifTrue: [word at: (count - spaces) put: a asSymbol. count := count + 1. Transcript show: word.]\r\t\t\tifFalse: [ (count ~= 1) ifTrue: [temp add: word. word := \'\' ]. count := count + 1. spaces := spaces + 1. Transcript show: ((count - spaces)); cr.]  ]. \r\t\tTranscript show: (temp); cr.\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: (suitStreak); cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:17',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T20:18:53.314794-05:00' ],		#prior : OmReference [ '186' ],		#self : OmReference [ '187' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| spaces temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , \' \' , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\t\r\tTranscript show: (dataInHand); cr.\r\t\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tcount := 1. spaces := 0. word := \'\'.\r\t\taValue do: [:a | Transcript show: \'h\'. Transcript show: (a); cr. (a ~= \' \' & (count ~= 1) ) \r\t\t\tifTrue: [word at: (count - spaces) put: a asSymbol. count := count + 1. Transcript show: word.]\r\t\t\tifFalse: [ (count ~= 1) ifTrue: [temp add: word. word := \'\' ]. count := count + 1. spaces := spaces + 1. Transcript show: ((count - spaces)); cr.]  ]. \r\t\tTranscript show: (temp); cr.\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: (suitStreak); cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:17',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| spaces temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , \' \' , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\t\r\tTranscript show: (dataInHand); cr.\r\t\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tcount := 1. spaces := 0. word := \'\'.\r\t\taValue do: [:a | Transcript show: \'h\'. Transcript show: (a); cr. (a ~= \' \' & (count ~= 1) ) \r\t\t\tifTrue: [word , a. count := count + 1. Transcript show: word.]\r\t\t\tifFalse: [ (count ~= 1) ifTrue: [temp add: word. word := \'\' ]. count := count + 1. spaces := spaces + 1. Transcript show: ((count - spaces)); cr.]  ]. \r\t\tTranscript show: (temp); cr.\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: (suitStreak); cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:18',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T20:19:20.573794-05:00' ],		#prior : OmReference [ '187' ],		#self : OmReference [ '188' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| spaces temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , \' \' , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\t\r\tTranscript show: (dataInHand); cr.\r\t\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tcount := 1. spaces := 0. word := \'\'.\r\t\taValue do: [:a | Transcript show: \'h\'. Transcript show: (a); cr. (a ~= \' \' & (count ~= 1) ) \r\t\t\tifTrue: [word , a. count := count + 1. Transcript show: word.]\r\t\t\tifFalse: [ (count ~= 1) ifTrue: [temp add: word. word := \'\' ]. count := count + 1. spaces := spaces + 1. Transcript show: ((count - spaces)); cr.]  ]. \r\t\tTranscript show: (temp); cr.\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: (suitStreak); cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:18',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| spaces temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , \' \' , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\t\r\tTranscript show: (dataInHand); cr.\r\t\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tcount := 1. spaces := 0. word := \'\'.\r\t\taValue do: [:a | Transcript show: \'h\'. Transcript show: (a); cr. (a ~= \' \' & (count ~= 1) ) \r\t\t\tifTrue: [word := word , a. Transcript show: word.]\r\t\t\tifFalse: [ (count ~= 1) ifTrue: [temp add: word. word := \'\' ]. count := count + 1. spaces := spaces + 1. Transcript show: ((count - spaces)); cr.]  ]. \r\t\tTranscript show: (temp); cr.\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: (suitStreak); cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:19',			#package : #CPS506		}	}}OmEntry {	#tags : {		#author : 'MagdalenaDhima',		#time : DateAndTime [ '2021-01-30T20:19:38.798794-05:00' ],		#prior : OmReference [ '188' ],		#self : OmReference [ '189' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| spaces temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , \' \' , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\t\r\tTranscript show: (dataInHand); cr.\r\t\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tcount := 1. spaces := 0. word := \'\'.\r\t\taValue do: [:a | Transcript show: \'h\'. Transcript show: (a); cr. (a ~= \' \' & (count ~= 1) ) \r\t\t\tifTrue: [word := word , a. Transcript show: word.]\r\t\t\tifFalse: [ (count ~= 1) ifTrue: [temp add: word. word := \'\' ]. count := count + 1. spaces := spaces + 1. Transcript show: ((count - spaces)); cr.]  ]. \r\t\tTranscript show: (temp); cr.\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: (suitStreak); cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:19',			#package : #CPS506		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Poker,				#isMetaSide : false			},			#name : #'getHighestSuitStreak:',			#protocol : #accessing,			#sourceCode : 'getHighestSuitStreak: streaks\r\t"comment stating purpose of instance-side message"\r\t"scope: class-variables  &  instance-variables"\t\r\t\t\t\r\t| spaces temp suitStreak previousCard previous card current highestSuitStreak count dataInHand max word |\rsuitStreak := OrderedCollection new.\r\rdataInHand := Dictionary new.\rdataInHand at: $C put: \'\'. dataInHand at: $D put: \'\'. dataInHand at: $H put: \'\'. dataInHand at: $S put: \'\'.\r1 to: streaks size do: [ :i | \r\tcard := streaks at: i.\r\tcurrent := card at: card size.\r\tTranscript show: (dataInHand at: current); cr.\r\tdataInHand at: current put: ((dataInHand at: current) , \' \' , card).\r\tTranscript show: (dataInHand at: current); cr.].\r\t\r\tTranscript show: (dataInHand); cr.\r\t\r\tsuitStreak := OrderedCollection new.\r\ttemp := OrderedCollection new.\r\tmax := 0.\r\tdataInHand keysAndValuesDo: [:aKey :aValue | \r\t\tcount := 1. spaces := 0. word := \'\'.\r\t\taValue do: [:a | Transcript show: \'h\'. Transcript show: (a); cr. (a ~= \' \' & (count ~= 1) ) \r\t\t\tifTrue: [word := word , a asString. Transcript show: word.]\r\t\t\tifFalse: [ (count ~= 1) ifTrue: [temp add: word. word := \'\' ]. count := count + 1. spaces := spaces + 1. Transcript show: ((count - spaces)); cr.]  ]. \r\t\tTranscript show: (temp); cr.\r\t\t(temp size > max) ifTrue: [max := temp size. suitStreak := temp ] ].\r\t\r\tTranscript show: (suitStreak); cr.\r\r\thighestSuitStreak := OrderedCollection new.\r\t(suitStreak size >= 5) \r\tifTrue: [\r\t\t(suitStreak size -4) to: (suitStreak size) do: [:i | highestSuitStreak add: (suitStreak at: i)]]\r\tifFalse: [highestSuitStreak := suitStreak].\r\r\t^highestSuitStreak',			#stamp : 'MagdalenaDhima 1/30/2021 20:19',			#package : #CPS506		}	}}