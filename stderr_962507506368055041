[31mError: You should not remove inherited methods
[0mClyAllMethodGroup(Object)>>error:
ClyAllMethodGroup(ClyInheritedMethodGroup)>>removeWithMethods
ByteSymbol(Symbol)>>value:
Array(SequenceableCollection)>>do:
ClyRemoveMethodGroupCommand>>execute
ClyMethodGroupContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand in Block: [ self prepareCommandForExecution....
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent: in Block: [ | selArgCount |...
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[31mArgumentsCountMismatch: This block accepts 2 arguments, but was called with 1 argument.
[0mBlockClosure>>numArgsError:
BlockClosure>>value:
SortedCollection(OrderedCollection)>>do:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mArgumentsCountMismatch: This block accepts 2 arguments, but was called with 1 argument.
[0mBlockClosure>>numArgsError:
BlockClosure>>value:
[ :each | newCollection addLast: (aBlock value: each) ] in SortedCollection>>collect: in Block: [ :each | newCollection addLast: (aBlock value: ea...etc...
SortedCollection(OrderedCollection)>>do:
SortedCollection>>collect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
[0m[31mError: Reading a number failed: a digit between 0 and 9 expected
[0mNumberParser(Object)>>error:
NumberParser>>expected:
NumberParser>>readNamedFloatOrFail
NumberParser>>nextNumber
Number class>>readFrom:
Number class(Object)>>readFromString:
ByteString(String)>>asNumber
[ :x :y | x asNumber < y asNumber ] in UndefinedObject>>DoIt in Block: [ :x :y | x asNumber < y asNumber ]
SortedCollection>>sort:to:
SortedCollection>>reSort
SortedCollection>>addAll:
Array(Collection)>>asSortedCollection:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of ByteString did not understand #%
[0mByteString(Object)>>doesNotUnderstand: #%
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of ByteString did not understand #%
[0mByteString(Object)>>doesNotUnderstand: #%
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of ByteString did not understand #%
[0mByteString(Object)>>doesNotUnderstand: #%
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of Character did not understand #-
[0mCharacter(Object)>>doesNotUnderstand: #-
[ :element | element perform: selector with: self ] in SmallInteger(Number)>>adaptToCollection:andSend: in Block: [ :element | element perform: selector with: self ...etc...
ByteString(SequenceableCollection)>>collect:
SmallInteger(Number)>>adaptToCollection:andSend:
ByteString(Collection)>>-
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mError: Instances of False are not indexable
[0mFalse(Object)>>error:
False(Object)>>errorNotIndexable
False(Object)>>at:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mError: Instances of False are not indexable
[0mFalse(Object)>>error:
False(Object)>>errorNotIndexable
False(Object)>>at:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of Character did not understand #-
[0mCharacter(Object)>>doesNotUnderstand: #-
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of Character did not understand #-
[0mCharacter(Object)>>doesNotUnderstand: #-
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mError: Instances of False are not indexable
[0mFalse(Object)>>error:
False(Object)>>errorNotIndexable
False(Object)>>at:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mError: Instances of False are not indexable
[0mFalse(Object)>>error:
False(Object)>>errorNotIndexable
False(Object)>>at:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mError: Instances of False are not indexable
[0mFalse(Object)>>error:
False(Object)>>errorNotIndexable
False(Object)>>at:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mError: Instances of False are not indexable
[0mFalse(Object)>>error:
False(Object)>>errorNotIndexable
False(Object)>>at:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mError: Instances of False are not indexable
[0mFalse(Object)>>error:
False(Object)>>errorNotIndexable
False(Object)>>at:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mError: Instances of False are not indexable
[0mFalse(Object)>>error:
False(Object)>>errorNotIndexable
False(Object)>>at:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mError: Instances of False are not indexable
[0mFalse(Object)>>error:
False(Object)>>errorNotIndexable
False(Object)>>at:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of Character did not understand #-
[0mCharacter(Object)>>doesNotUnderstand: #-
[ :element | element perform: selector with: self ] in SmallInteger(Number)>>adaptToCollection:andSend: in Block: [ :element | element perform: selector with: self ...etc...
ByteString(SequenceableCollection)>>collect:
SmallInteger(Number)>>adaptToCollection:andSend:
ByteString(Collection)>>-
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mError: Instances of False are not indexable
[0mFalse(Object)>>error:
False(Object)>>errorNotIndexable
False(Object)>>at:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mError: Instances of False are not indexable
[0mFalse(Object)>>error:
False(Object)>>errorNotIndexable
False(Object)>>at:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mSubscriptOutOfBounds: 6
[0mArray(Object)>>errorSubscriptBounds:
Array(Object)>>at:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mSubscriptOutOfBounds: 6
[0mArray(Object)>>errorSubscriptBounds:
Array(Object)>>at:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mArgumentsCountMismatch: This block accepts 2 arguments, but was called with 1 argument.
[0mBlockClosure>>numArgsError:
BlockClosure>>value:
Array(SequenceableCollection)>>collect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mArgumentsCountMismatch: This block accepts 2 arguments, but was called with 1 argument.
[0mBlockClosure>>numArgsError:
BlockClosure>>value:
Array(SequenceableCollection)>>collect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mSubscriptOutOfBounds: 6
[0mArray(Object)>>errorSubscriptBounds:
Array(Object)>>at:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of False did not understand #'>='
[0mFalse(Object)>>doesNotUnderstand: #'>='
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of False did not understand #'>='
[0mFalse(Object)>>doesNotUnderstand: #'>='
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of False did not understand #'>='
[0mFalse(Object)>>doesNotUnderstand: #'>='
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of False did not understand #'>='
[0mFalse(Object)>>doesNotUnderstand: #'>='
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Character did not understand #-
[0mCharacter(Object)>>doesNotUnderstand: #-
[ :element | element perform: selector with: self ] in SmallInteger(Number)>>adaptToCollection:andSend: in Block: [ :element | element perform: selector with: self ...etc...
ByteString(SequenceableCollection)>>collect:
SmallInteger(Number)>>adaptToCollection:andSend:
ByteString(Collection)>>-
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of Character did not understand #-
[0mCharacter(Object)>>doesNotUnderstand: #-
[ :element | element perform: selector with: self ] in SmallInteger(Number)>>adaptToCollection:andSend: in Block: [ :element | element perform: selector with: self ...etc...
ByteString(SequenceableCollection)>>collect:
SmallInteger(Number)>>adaptToCollection:andSend:
ByteString(Collection)>>-
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SmallInteger did not understand #,
[0mSmallInteger(Object)>>doesNotUnderstand: #,
[ :e | (e copyFrom: 1 to: e size - 1) asNumber , (e at: e size) ] in UndefinedObject>>DoIt in Block: [ :e | (e copyFrom: 1 to: e size - 1) asNumber , (...etc...
[ :each | each ifNotNil: [ newSet add: (aBlock value: each enclosedElement) ] ] in Set>>collect: in Block: [ :each | each ifNotNil: [ newSet add: (aBlock val...etc...
Array(SequenceableCollection)>>do:
Set>>collect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SmallInteger did not understand #,
[0mSmallInteger(Object)>>doesNotUnderstand: #,
[ :e | (e copyFrom: 1 to: e size - 1) asNumber , (e at: e size) ] in UndefinedObject>>DoIt in Block: [ :e | (e copyFrom: 1 to: e size - 1) asNumber , (...etc...
[ :each | each ifNotNil: [ newSet add: (aBlock value: each enclosedElement) ] ] in Set>>collect: in Block: [ :each | each ifNotNil: [ newSet add: (aBlock val...etc...
Array(SequenceableCollection)>>do:
Set>>collect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SmallInteger did not understand #,
[0mSmallInteger(Object)>>doesNotUnderstand: #,
[ :e | (e copyFrom: 1 to: e size - 1) asNumber , (e at: e size) ] in UndefinedObject>>DoIt in Block: [ :e | (e copyFrom: 1 to: e size - 1) asNumber , (...etc...
[ :each | each ifNotNil: [ newSet add: (aBlock value: each enclosedElement) ] ] in Set>>collect: in Block: [ :each | each ifNotNil: [ newSet add: (aBlock val...etc...
Array(SequenceableCollection)>>do:
Set>>collect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Character did not understand #-
[0mCharacter(Object)>>doesNotUnderstand: #-
[ :element | element perform: selector with: self ] in SmallInteger(Number)>>adaptToCollection:andSend: in Block: [ :element | element perform: selector with: self ...etc...
ByteString(SequenceableCollection)>>collect:
SmallInteger(Number)>>adaptToCollection:andSend:
ByteString(Collection)>>-
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mError: only integers should be used as indices
[0mByteString(Object)>>error:
ByteString(Object)>>errorNonIntegerIndex
ByteString(Object)>>at:
ByteString>>at:
[ :e | 
(e at: 1 ~= 1)
	ifTrue: [ e ] ] in UndefinedObject>>DoIt in Block: [ :e | ...
Array(SequenceableCollection)>>collect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mError: only integers should be used as indices
[0mByteString(Object)>>error:
ByteString(Object)>>errorNonIntegerIndex
ByteString(Object)>>at:
ByteString>>at:
[ :e | 
(e at: 1 ~= 1)
	ifTrue: [ ^ e ] ] in UndefinedObject>>DoIt in Block: [ :e | ...
Array(SequenceableCollection)>>collect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mError: only integers should be used as indices
[0mByteString(Object)>>error:
ByteString(Object)>>errorNonIntegerIndex
ByteString(Object)>>at:
ByteString>>at:
[ :e | 
(e at: 1 ~= '1')
	ifTrue: [ ^ e ] ] in UndefinedObject>>DoIt in Block: [ :e | ...
Array(SequenceableCollection)>>collect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mError: only integers should be used as indices
[0mByteString(Object)>>error:
ByteString(Object)>>errorNonIntegerIndex
ByteString(Object)>>at:
ByteString>>at:
[ :e | 
(e at: 1 ~= '1')
	ifTrue: [ e ] ] in UndefinedObject>>DoIt in Block: [ :e | ...
Array(SequenceableCollection)>>collect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mError: only integers should be used as indices
[0mByteString(Object)>>error:
ByteString(Object)>>errorNonIntegerIndex
ByteString(Object)>>at:
ByteString>>at:
[ :e | (e at: 1 ~= '1') e ] in UndefinedObject>>DoIt in Block: [ :e | (e at: 1 ~= '1') e ]
Array(SequenceableCollection)>>collect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mError: only integers should be used as indices
[0mByteString(Object)>>error:
ByteString(Object)>>errorNonIntegerIndex
ByteString(Object)>>at:
ByteString>>at:
[ :e | (e at: 1 ~= '1') e ] in UndefinedObject>>DoIt in Block: [ :e | (e at: 1 ~= '1') e ]
Array(SequenceableCollection)>>collect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mError: only integers should be used as indices
[0mByteString(Object)>>error:
ByteString(Object)>>errorNonIntegerIndex
ByteString(Object)>>at:
ByteString>>at:
[ :e | 
(e at: 1 ~= 1)
	ifTrue: [ e ] ] in UndefinedObject>>DoIt in Block: [ :e | ...
Array(SequenceableCollection)>>collect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of True did not understand #-
[0mTrue(Object)>>doesNotUnderstand: #-
ByteString(SequenceableCollection)>>copyFrom:to:
[ :e | 
(e copyFrom: 1 to: 2 ~= 1)
	ifTrue: [ e ] ] in UndefinedObject>>DoIt in Block: [ :e | ...
Array(SequenceableCollection)>>collect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of False did not understand #-
[0mFalse(Object)>>doesNotUnderstand: #-
ByteString(SequenceableCollection)>>copyFrom:to:
[ :e | 
(e copyFrom: 1 to: 1 ~= 1)
	ifTrue: [ e ] ] in UndefinedObject>>DoIt in Block: [ :e | ...
Array(SequenceableCollection)>>collect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of True did not understand #-
[0mTrue(Object)>>doesNotUnderstand: #-
ByteString(SequenceableCollection)>>copyFrom:to:
[ :e | 
(e copyFrom: 1 to: 2 ~= 1)
	ifTrue: [ ^ e ] ] in UndefinedObject>>DoIt in Block: [ :e | ...
Array(SequenceableCollection)>>collect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mError: only integers should be used as indices
[0mByteString(Object)>>error:
ByteString(Object)>>errorNonIntegerIndex
ByteString(Object)>>at:
ByteString>>at:
[ :e | 
(e at: 1 ~= 1)
	ifTrue: [ e ] ] in UndefinedObject>>DoIt in Block: [ :e | ...
Array(SequenceableCollection)>>collect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mError: only integers should be used as indices
[0mByteString(Object)>>error:
ByteString(Object)>>errorNonIntegerIndex
ByteString(Object)>>at:
ByteString>>at:
[ :e | (e at: 1 ~= 1) e ] in UndefinedObject>>DoIt in Block: [ :e | (e at: 1 ~= 1) e ]
Array(SequenceableCollection)>>collect:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31m#'<=' was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #'<='
UndefinedObject>>doesNotUnderstand: #'<='
SortedCollection>>defaultSort:to:
SortedCollection>>sort:to:
SortedCollection>>reSort
SortedCollection>>addAll:
SortedCollection class(OrderedCollection class)>>newFrom:
Array(Object)>>as:
Array(Collection)>>asSortedCollection
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31m#'<=' was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #'<='
UndefinedObject>>doesNotUnderstand: #'<='
SortedCollection>>defaultSort:to:
SortedCollection>>sort:to:
SortedCollection>>reSort
SortedCollection>>addAll:
SortedCollection class(OrderedCollection class)>>newFrom:
Array(Object)>>as:
Array(Collection)>>asSortedCollection
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31m#'<=' was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #'<='
UndefinedObject>>doesNotUnderstand: #'<='
SortedCollection>>defaultSort:to:
SortedCollection>>sort:to:
SortedCollection>>reSort
SortedCollection>>addAll:
SortedCollection class(OrderedCollection class)>>newFrom:
Array(Object)>>as:
Array(Collection)>>asSortedCollection
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m[31m#add: was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #add:
UndefinedObject>>doesNotUnderstand: #add:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31m#add: was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #add:
UndefinedObject>>doesNotUnderstand: #add:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31m#add: was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #add:
UndefinedObject>>doesNotUnderstand: #add:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31m#add: was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #add:
UndefinedObject>>doesNotUnderstand: #add:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31m#add: was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #add:
UndefinedObject>>doesNotUnderstand: #add:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mError: Instances of SmallInteger are not indexable
[0mSmallInteger(Object)>>error:
SmallInteger(Object)>>errorNotIndexable
SmallInteger(Object)>>size
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mError: Instances of SmallInteger are not indexable
[0mSmallInteger(Object)>>error:
SmallInteger(Object)>>errorNotIndexable
SmallInteger(Object)>>size
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mError: Instances of SmallInteger are not indexable
[0mSmallInteger(Object)>>error:
SmallInteger(Object)>>errorNotIndexable
SmallInteger(Object)>>size
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of Metaclass did not understand #commonSuperclassWith:
[0mMetaclass(Object)>>doesNotUnderstand: #commonSuperclassWith:
[ :name | 
| type1 type2 |
type2 := stackTop at: name.
(typeStack top includesKey: name)
	ifFalse: [ typeStack top at: name put: type2 ]
	ifTrue: [ type1 := typeStack top at: name.
		type1 == type2
			ifFalse: [ typeStack top at: name put: (type2 commonSuperclassWith: type1) ] ] ] in TypingVisitor>>visitBlockNode: in Block: [ :name | ...
[ :association | aBlock value: association key ] in Dictionary>>keysDo: in Block: [ :association | aBlock value: association key ]
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
Dictionary>>keysDo:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
TypingVisitor(RBProgramNodeVisitor)>>visitBlockNode:
TypingVisitor>>visitBlockNode:
RBBlockNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
TypingVisitor(RBProgramNodeVisitor)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
TypingVisitor(RBProgramNodeVisitor)>>visitNode:
[ :each | self visitNode: each ] in TypingVisitor(RBProgramNodeVisitor)>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
[0m